# ä¸ªäººç…§ç‰‡ç›´æ’­åº”ç”¨è¯¦ç»†å¼€å‘æ–¹æ¡ˆ

## 1. é¡¹ç›®æ¦‚è¿°

### 1.1 äº§å“å®šä½

åŸºäºåƒç´ èŠå£«åŠŸèƒ½æ¨¡å¼ï¼Œå¼€å‘ä¸ªäººä½¿ç”¨çš„å¤šç«¯ç…§ç‰‡ç›´æ’­åº”ç”¨ï¼Œä¸»è¦ç”¨äºå©šç¤¼ã€æ´»åŠ¨ç­‰åœºæ™¯çš„å®æ—¶ç…§ç‰‡åˆ†äº«ã€‚

### 1.2 æ ¸å¿ƒä»·å€¼

- **å®æ—¶æ€§**: æ‹æ‘„åç«‹å³åˆ†äº«ç»™å®¢äººæŸ¥çœ‹
- **ä¾¿æ·æ€§**: ä¸€é”®ç”Ÿæˆåˆ†äº«é“¾æ¥ï¼Œå®¢äººæ‰«ç å³çœ‹
- **ä¸“ä¸šæ€§**: æ”¯æŒä¸“ä¸šç›¸æœºï¼Œè‡ªåŠ¨å¤„ç†ä¼˜åŒ–
- **ç§å¯†æ€§**: ä¸ªäººéƒ¨ç½²ï¼Œæ•°æ®å®Œå…¨å¯æ§
- **å®‰å…¨æ€§**: æ”¯æŒè®¿é—®ç ä¿æŠ¤ï¼Œé˜²æ­¢é“¾æ¥æ³„éœ²
- **æ™ºèƒ½åŒ–**: AIè¾…åŠ©é€‰ç‰‡ï¼Œè‡ªåŠ¨æ ‡ç­¾åˆ†ç±»

## 2. è¯¦ç»†åŠŸèƒ½è®¾è®¡

### 2.1 æ‹æ‘„ç«¯åŠŸèƒ½çŸ©é˜µ

| åŠŸèƒ½æ¨¡å—     | åŸºç¡€ç‰ˆ | è¿›é˜¶ç‰ˆ   | ä¸“ä¸šç‰ˆ |
| -------- | --- | ----- | --- |
| æ‰‹æœºæ‹ç…§     | âœ…   | âœ…     | âœ…   |
| ç›¸æœºWiFiè¿æ¥ | âŒ   | âœ…     | âœ…   |
| ç›¸æœºUSBè¿æ¥  | âŒ   | âŒ     | âœ…   |
| å®æ—¶é¢„è§ˆ     | æ‰‹æœº  | æ‰‹æœº+ç›¸æœº | å…¨è®¾å¤‡ |
| è¿œç¨‹æ§åˆ¶     | âŒ   | åŸºç¡€    | é«˜çº§  |
| æ‰¹é‡å¤„ç†     | âŒ   | âœ…     | âœ…   |
| AIé€‰ç‰‡     | âŒ   | âŒ     | âœ…   |
| è®¿é—®ç ä¿æŠ¤   | âŒ   | âœ…     | âœ…   |
| åŠ¨æ€æ°´å°     | âŒ   | âœ…     | âœ…   |
| ç…§ç‰‡æ ‡ç­¾     | âŒ   | âœ…     | âœ…   |
| å®¡æ ¸æ¨¡å¼     | âŒ   | âŒ     | âœ…   |
| å¤šè¯­è¨€æ”¯æŒ   | âŒ   | âœ…     | âœ…   |
| æ–­ç‚¹ç»­ä¼      | âŒ   | âœ…     | âœ…   |
| WebPå‹ç¼©    | âŒ   | âœ…     | âœ…   |

### 2.2 è¯¦ç»†ç”¨æˆ·æµç¨‹

#### æ‘„å½±å¸ˆç«¯æµç¨‹

```mermaid
flowchart TD
    A[æ‰“å¼€App] --> B[åˆ›å»ºæ‹æ‘„ç›¸å†Œ]
    B --> C[è¿æ¥ç›¸æœº/ä½¿ç”¨æ‰‹æœº]
    C --> D[å¼€å§‹æ‹æ‘„]
    D --> E[ç…§ç‰‡è‡ªåŠ¨ä¸Šä¼ ]
    E --> F[ç”Ÿæˆåˆ†äº«é“¾æ¥]
    F --> G[åˆ†äº«ç»™å®¢äºº]
    G --> H[å®æ—¶ç›‘æ§è®¿é—®]

    D --> I[æœ¬åœ°é¢„è§ˆç­›é€‰]
    I --> J[æ‰¹é‡ä¸Šä¼ é€‰ä¸­ç…§ç‰‡]
    J --> E
```

#### å®¢äººç«¯æµç¨‹

```mermaid
flowchart TD
    A[æ‰«ç /ç‚¹å‡»é“¾æ¥] --> B[è¿›å…¥å±•ç¤ºé¡µé¢]
    B --> C[æŸ¥çœ‹å®æ—¶ç…§ç‰‡]
    C --> D[ç‚¹å‡»æ”¾å¤§æŸ¥çœ‹]
    D --> E[é€‰æ‹©ä¸‹è½½ç…§ç‰‡]
    E --> F[æ‰¹é‡æ‰“åŒ…ä¸‹è½½]

    C --> G[åˆ†äº«ç»™æœ‹å‹]
    C --> H[æ”¶è—å–œæ¬¢çš„ç…§ç‰‡]
```

## 3. è¯¦ç»†æŠ€æœ¯æ¶æ„

### 3.1 æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æ‹æ‘„ç«¯åº”ç”¨     â”‚    â”‚   äº‘ç«¯æœåŠ¡       â”‚    â”‚   å±•ç¤ºç«¯åº”ç”¨     â”‚
â”‚                â”‚    â”‚                â”‚    â”‚                â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Flutter App â”‚ â”‚â—„â”€â”€â–ºâ”‚ â”‚ Node.js API â”‚ â”‚â—„â”€â”€â–ºâ”‚ â”‚ Next.js Web â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Electron    â”‚ â”‚    â”‚ â”‚ WebSocket   â”‚ â”‚    â”‚ â”‚ Mobile PWA  â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                       â”‚ â”‚ å›¾ç‰‡å¤„ç†é˜Ÿåˆ— â”‚ â”‚
                       â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                       â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
                       â”‚ â”‚ OSSå­˜å‚¨     â”‚ â”‚
                       â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
                       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 åç«¯APIè¯¦ç»†è®¾è®¡

#### 3.2.1 APIæ¥å£è§„èŒƒ

```javascript
// åŸºç¡€å“åº”æ ¼å¼
{
  "code": 200,
  "message": "success",
  "data": {},
  "timestamp": 1640995200000
}

// é”™è¯¯å“åº”æ ¼å¼
{
  "code": 400,
  "message": "å‚æ•°é”™è¯¯",
  "error": "validation_failed",
  "details": ["å­—æ®µxxxä¸èƒ½ä¸ºç©º"]
}
```

#### 3.2.2 æ ¸å¿ƒAPIæ¥å£

```javascript
// routes/session.js - ç›¸å†Œç®¡ç†
const express = require('express');
const router = express.Router();

// åˆ›å»ºæ‹æ‘„ç›¸å†Œ
router.post('/sessions', async (req, res) => {
  /*
  POST /api/sessions
  Body: {
    "name": "å°æ˜å©šç¤¼ç°åœº",
    "description": "2024å¹´6æœˆ1æ—¥å©šç¤¼",
    "settings": {
      "auto_upload": true,
      "quality": "high",
      "watermark": {
        "enabled": true,
        "text": "æ‘„å½±å¸ˆåç§°",
        "position": "bottom-right",
        "opacity": 0.7
      },
      "access_protection": {
        "enabled": true,
        "access_code": "1234"
      },
      "review_mode": false,
      "auto_tagging": true,
      "multi_resolution": true,
      "webp_compression": true,
      "language": "zh-CN"
    }
  }
  Response: {
    "data": {
      "id": 123,
      "name": "å°æ˜å©šç¤¼ç°åœº",
      "share_code": "ABC123",
      "share_url": "https://yourdomain.com/s/ABC123?code=1234",
      "qr_code": "data:image/png;base64,...",
      "access_code": "1234"
    }
  }
  */
});

// è·å–ç›¸å†Œè¯¦æƒ…
router.get('/sessions/:id', async (req, res) => {
  /*
  GET /api/sessions/123
  Response: {
    "data": {
      "id": 123,
      "name": "å°æ˜å©šç¤¼ç°åœº",
      "photo_count": 156,
      "view_count": 89,
      "created_at": "2024-06-01T10:00:00Z",
      "status": "active"
    }
  }
  */
});

// routes/photo.js - å›¾ç‰‡ç®¡ç†
const multer = require('multer');
const sharp = require('sharp');

// é…ç½®æ–‡ä»¶ä¸Šä¼ 
const upload = multer({
  dest: 'uploads/',
  limits: {
    fileSize: 50 * 1024 * 1024 // 50MB
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('åªå…è®¸ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶'));
    }
  }
});

// ä¸Šä¼ ç…§ç‰‡
router.post('/sessions/:sessionId/photos', upload.array('photos', 20), async (req, res) => {
  /*
  POST /api/sessions/123/photos
  Content-Type: multipart/form-data
  Files: photos[]
  Body: {
    "tags": ["æ–°éƒæ–°å¨˜", "å…¨ä½“åˆç…§"],
    "watermark_text": "æ‘„å½±å¸ˆåç§°",
    "auto_tag": true,
    "review_required": false
  }

  å¤„ç†æµç¨‹:
  1. æ¥æ”¶ä¸Šä¼ çš„å›¾ç‰‡æ–‡ä»¶
  2. AIè‡ªåŠ¨æ ‡ç­¾è¯†åˆ«ï¼ˆå¦‚æœå¼€å¯ï¼‰
  3. æ·»åŠ åŠ¨æ€æ°´å°ï¼ˆå¦‚æœå¼€å¯ï¼‰
  4. ç”Ÿæˆå¤šåˆ†è¾¨ç‡ç‰ˆæœ¬ï¼ˆç¼©ç•¥å›¾ã€ä¸­ç­‰ã€åŸå›¾ï¼‰
  5. WebPå’ŒJPEGåŒæ ¼å¼å‹ç¼©
  6. ä¸Šä¼ åˆ°äº‘å­˜å‚¨
  7. ä¿å­˜æ•°æ®åº“è®°å½•ï¼ˆåŒ…å«æ ‡ç­¾ä¿¡æ¯ï¼‰
  8. å®¡æ ¸æ¨¡å¼æ£€æŸ¥ï¼ˆå¦‚æœå¼€å¯ï¼‰
  9. é€šè¿‡WebSocketæ¨é€ç»™åœ¨çº¿ç”¨æˆ·
  */

  try {
    const files = req.files;
    const sessionId = req.params.sessionId;
    const { tags, watermark_text, auto_tag, review_required } = req.body;
    const uploadResults = [];
    const session = await db.sessions.findById(sessionId);

    for (const file of files) {
      let processedTags = tags || [];
      
      // AIè‡ªåŠ¨æ ‡ç­¾è¯†åˆ«
      if (auto_tag && session.settings.auto_tagging) {
        const aiTags = await aiTaggingService.analyzImage(file.path);
        processedTags = [...processedTags, ...aiTags];
      }

      // æ·»åŠ åŠ¨æ€æ°´å°
      let watermarkOptions = null;
      if (session.settings.watermark.enabled) {
        watermarkOptions = {
          text: watermark_text || session.settings.watermark.text,
          position: session.settings.watermark.position,
          opacity: session.settings.watermark.opacity
        };
      }

      // ç”Ÿæˆå¤šåˆ†è¾¨ç‡ç‰ˆæœ¬
      const versions = await generateMultiResolution(file.path, watermarkOptions);
      
      // ä¸Šä¼ åˆ°äº‘å­˜å‚¨
      const uploadUrls = {};
      for (const [size, buffer] of Object.entries(versions)) {
        uploadUrls[size] = await uploadToOSS(buffer, `${size}/${file.filename}`);
      }

      // ä¿å­˜åˆ°æ•°æ®åº“
      const photo = await db.photos.create({
        session_id: sessionId,
        filename: file.originalname,
        original_url: uploadUrls.original,
        medium_url: uploadUrls.medium,
        thumbnail_url: uploadUrls.thumbnail,
        webp_url: uploadUrls.webp,
        file_size: versions.original.length,
        tags: processedTags,
        status: review_required ? 'pending' : 'published',
        upload_time: new Date()
      });

      uploadResults.push(photo);

      // WebSocketæ¨é€ï¼ˆä»…å‘å¸ƒçŠ¶æ€çš„ç…§ç‰‡ï¼‰
      if (photo.status === 'published') {
        io.to(`session_${sessionId}`).emit('new_photo', {
          id: photo.id,
          thumbnail_url: uploadUrls.thumbnail,
          webp_url: uploadUrls.webp,
          tags: processedTags,
          upload_time: photo.upload_time
        });
      }
    }

    res.json({
      code: 200,
      message: 'ä¸Šä¼ æˆåŠŸ',
      data: { photos: uploadResults }
    });

  } catch (error) {
    res.status(500).json({
      code: 500,
      message: 'ä¸Šä¼ å¤±è´¥',
      error: error.message
    });
  }
});

// è·å–ç›¸å†Œç…§ç‰‡åˆ—è¡¨
router.get('/sessions/:sessionId/photos', async (req, res) => {
  /*
  GET /api/sessions/123/photos?page=1&limit=20&sort=desc&tags=æ–°éƒæ–°å¨˜&code=1234
  Headers: {
    "Accept-Language": "zh-CN"
  }
  Response: {
    "data": {
      "photos": [
        {
          "id": 1001,
          "thumbnail_url": "https://cdn.example.com/thumbs/photo1.jpg",
          "medium_url": "https://cdn.example.com/medium/photo1.jpg",
          "original_url": "https://cdn.example.com/photos/photo1.jpg",
          "webp_url": "https://cdn.example.com/webp/photo1.webp",
          "upload_time": "2024-06-01T10:30:00Z",
          "file_size": 2048576,
          "tags": ["æ–°éƒæ–°å¨˜", "å®¤å†…", "æ­£å¼"],
          "status": "published"
        }
      ],
      "pagination": {
        "page": 1,
        "limit": 20,
        "total": 156,
        "has_more": true
      },
      "available_tags": ["æ–°éƒæ–°å¨˜", "å…¨ä½“åˆç…§", "å®¤å†…", "æˆ·å¤–", "æ­£å¼", "è½»æ¾"]
    }
  }
  */
});

// è®¿é—®ç éªŒè¯
router.post('/sessions/:sessionId/verify', async (req, res) => {
  /*
  POST /api/sessions/123/verify
  Body: {
    "access_code": "1234"
  }
  Response: {
    "data": {
      "valid": true,
      "session_info": {
        "name": "å°æ˜å©šç¤¼ç°åœº",
        "description": "2024å¹´6æœˆ1æ—¥å©šç¤¼",
        "photo_count": 156
      }
    }
  }
  */
});

// ç…§ç‰‡å®¡æ ¸ç®¡ç†
router.patch('/sessions/:sessionId/photos/:photoId/review', async (req, res) => {
  /*
  PATCH /api/sessions/123/photos/1001/review
  Body: {
    "action": "approve", // approve, reject
    "reason": "è´¨é‡ä¸ä½³" // å¯é€‰ï¼Œæ‹’ç»åŸå› 
  }
  Response: {
    "data": {
      "id": 1001,
      "status": "published",
      "reviewed_at": "2024-06-01T10:35:00Z"
    }
  }
  */
});

// æ‰¹é‡ç…§ç‰‡æ“ä½œ
router.post('/sessions/:sessionId/photos/batch', async (req, res) => {
  /*
  POST /api/sessions/123/photos/batch
  Body: {
    "action": "add_tags", // add_tags, remove_tags, approve, reject
    "photo_ids": [1001, 1002, 1003],
    "tags": ["ç²¾é€‰", "æ¨è"]
  }
  Response: {
    "data": {
      "updated_count": 3,
      "success": true
    }
  }
  */
});
```

#### 3.2.3 WebSocketå®æ—¶é€šä¿¡

```javascript
// socket.js - WebSocketå¤„ç†
const socketIo = require('socket.io');

function initSocket(server) {
  const io = socketIo(server, {
    cors: {
      origin: "*",
      methods: ["GET", "POST"]
    }
  });

  io.on('connection', (socket) => {
    console.log('ç”¨æˆ·è¿æ¥:', socket.id);

    // åŠ å…¥ç›¸å†Œæˆ¿é—´
    socket.on('join_session', (sessionId) => {
      socket.join(`session_${sessionId}`);
      console.log(`ç”¨æˆ· ${socket.id} åŠ å…¥ç›¸å†Œ ${sessionId}`);

      // å¹¿æ’­åœ¨çº¿äººæ•°
      const roomSize = io.sockets.adapter.rooms.get(`session_${sessionId}`)?.size || 0;
      io.to(`session_${sessionId}`).emit('online_count', roomSize);
    });

    // ç¦»å¼€ç›¸å†Œæˆ¿é—´
    socket.on('leave_session', (sessionId) => {
      socket.leave(`session_${sessionId}`);
      const roomSize = io.sockets.adapter.rooms.get(`session_${sessionId}`)?.size || 0;
      io.to(`session_${sessionId}`).emit('online_count', roomSize);
    });

    // æ–­å¼€è¿æ¥
    socket.on('disconnect', () => {
      console.log('ç”¨æˆ·æ–­å¼€è¿æ¥:', socket.id);
    });
  });

  return io;
}

module.exports = initSocket;
```

### 3.3 å‰ç«¯è¯¦ç»†å®ç°

#### 3.3.1 Flutterç§»åŠ¨ç«¯å®ç°

```dart
// lib/models/session.dart - æ•°æ®æ¨¡å‹
class Session {
  final int id;
  final String name;
  final String shareCode;
  final String shareUrl;
  final int photoCount;
  final DateTime createdAt;

  Session({
    required this.id,
    required this.name,
    required this.shareCode,
    required this.shareUrl,
    required this.photoCount,
    required this.createdAt,
  });

  factory Session.fromJson(Map<String, dynamic> json) {
    return Session(
      id: json['id'],
      name: json['name'],
      shareCode: json['share_code'],
      shareUrl: json['share_url'],
      photoCount: json['photo_count'],
      createdAt: DateTime.parse(json['created_at']),
    );
  }
}

// lib/services/api_service.dart - APIæœåŠ¡
class ApiService {
  static const String baseUrl = 'https://your-api.com/api';
  final Dio _dio = Dio();

  ApiService() {
    _dio.options.baseUrl = baseUrl;
    _dio.options.connectTimeout = Duration(seconds: 10);
    _dio.options.receiveTimeout = Duration(seconds: 30);
  }

  // åˆ›å»ºç›¸å†Œ
  Future<Session> createSession(String name, String description) async {
    try {
      final response = await _dio.post('/sessions', data: {
        'name': name,
        'description': description,
        'settings': {
          'auto_upload': true,
          'quality': 'high',
          'watermark': false,
        }
      });

      if (response.data['code'] == 200) {
        return Session.fromJson(response.data['data']);
      } else {
        throw Exception(response.data['message']);
      }
    } catch (e) {
      throw Exception('åˆ›å»ºç›¸å†Œå¤±è´¥: $e');
    }
  }

  // ä¸Šä¼ ç…§ç‰‡
  Future<List<Photo>> uploadPhotos(int sessionId, List<File> photos) async {
    try {
      FormData formData = FormData();

      for (int i = 0; i < photos.length; i++) {
        formData.files.add(MapEntry(
          'photos',
          await MultipartFile.fromFile(
            photos[i].path,
            filename: 'photo_${DateTime.now().millisecondsSinceEpoch}_$i.jpg',
          ),
        ));
      }

      final response = await _dio.post(
        '/sessions/$sessionId/photos',
        data: formData,
        onSendProgress: (sent, total) {
          print('ä¸Šä¼ è¿›åº¦: ${(sent / total * 100).toStringAsFixed(1)}%');
        },
      );

      if (response.data['code'] == 200) {
        List<Photo> uploadedPhotos = [];
        for (var photoJson in response.data['data']['photos']) {
          uploadedPhotos.add(Photo.fromJson(photoJson));
        }
        return uploadedPhotos;
      } else {
        throw Exception(response.data['message']);
      }
    } catch (e) {
      throw Exception('ä¸Šä¼ å¤±è´¥: $e');
    }
  }
}

// lib/screens/camera_screen.dart - æ‹æ‘„ç•Œé¢
class CameraScreen extends StatefulWidget {
  final Session session;

  CameraScreen({required this.session});

  @override
  _CameraScreenState createState() => _CameraScreenState();
}

class _CameraScreenState extends State<CameraScreen> {
  CameraController? _controller;
  bool _isInitialized = false;
  List<File> _pendingPhotos = [];
  bool _isUploading = false;

  @override
  void initState() {
    super.initState();
    _initializeCamera();
  }

  Future<void> _initializeCamera() async {
    final cameras = await availableCameras();
    if (cameras.isNotEmpty) {
      _controller = CameraController(
        cameras.first,
        ResolutionPreset.high,
        enableAudio: false,
      );

      await _controller!.initialize();
      setState(() {
        _isInitialized = true;
      });
    }
  }

  Future<void> _takePicture() async {
    if (!_controller!.value.isInitialized) return;

    try {
      final XFile photo = await _controller!.takePicture();
      final File photoFile = File(photo.path);

      setState(() {
        _pendingPhotos.add(photoFile);
      });

      // è‡ªåŠ¨ä¸Šä¼ ï¼ˆå¦‚æœå¼€å¯ï¼‰
      if (widget.session.settings.autoUpload) {
        _uploadPendingPhotos();
      }

      // æ’­æ”¾å¿«é—¨éŸ³æ•ˆ
      SystemSound.play(SystemSoundType.click);

    } catch (e) {
      print('æ‹ç…§å¤±è´¥: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('æ‹ç…§å¤±è´¥: $e')),
      );
    }
  }

  Future<void> _uploadPendingPhotos() async {
    if (_pendingPhotos.isEmpty || _isUploading) return;

    setState(() {
      _isUploading = true;
    });

    try {
      final apiService = GetIt.instance<ApiService>();
      await apiService.uploadPhotos(widget.session.id, _pendingPhotos);

      setState(() {
        _pendingPhotos.clear();
      });

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('${_pendingPhotos.length}å¼ ç…§ç‰‡ä¸Šä¼ æˆåŠŸ')),
      );

    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('ä¸Šä¼ å¤±è´¥: $e')),
      );
    } finally {
      setState(() {
        _isUploading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (!_isInitialized) {
      return Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    return Scaffold(
      body: Stack(
        children: [
          // ç›¸æœºé¢„è§ˆ
          Positioned.fill(
            child: CameraPreview(_controller!),
          ),

          // é¡¶éƒ¨å·¥å…·æ 
          Positioned(
            top: MediaQuery.of(context).padding.top,
            left: 0,
            right: 0,
            child: Container(
              padding: EdgeInsets.all(16),
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: [Colors.black54, Colors.transparent],
                ),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  IconButton(
                    icon: Icon(Icons.arrow_back, color: Colors.white),
                    onPressed: () => Navigator.pop(context),
                  ),
                  Text(
                    widget.session.name,
                    style: TextStyle(color: Colors.white, fontSize: 18),
                  ),
                  IconButton(
                    icon: Icon(Icons.settings, color: Colors.white),
                    onPressed: () {
                      // æ‰“å¼€è®¾ç½®
                    },
                  ),
                ],
              ),
            ),
          ),

          // åº•éƒ¨æ§åˆ¶æ 
          Positioned(
            bottom: 0,
            left: 0,
            right: 0,
            child: Container(
              padding: EdgeInsets.all(20),
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.bottomCenter,
                  end: Alignment.topCenter,
                  colors: [Colors.black54, Colors.transparent],
                ),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  // ç…§ç‰‡é¢„è§ˆ
                  GestureDetector(
                    onTap: () {
                      // æŸ¥çœ‹å¾…ä¸Šä¼ ç…§ç‰‡
                    },
                    child: Container(
                      width: 60,
                      height: 60,
                      decoration: BoxDecoration(
                        border: Border.all(color: Colors.white, width: 2),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Stack(
                        children: [
                          if (_pendingPhotos.isNotEmpty)
                            ClipRRect(
                              borderRadius: BorderRadius.circular(6),
                              child: Image.file(
                                _pendingPhotos.last,
                                width: 56,
                                height: 56,
                                fit: BoxFit.cover,
                              ),
                            ),
                          if (_pendingPhotos.length > 1)
                            Positioned(
                              top: 4,
                              right: 4,
                              child: Container(
                                padding: EdgeInsets.all(2),
                                decoration: BoxDecoration(
                                  color: Colors.red,
                                  borderRadius: BorderRadius.circular(10),
                                ),
                                child: Text(
                                  '${_pendingPhotos.length}',
                                  style: TextStyle(
                                    color: Colors.white,
                                    fontSize: 12,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ),
                            ),
                        ],
                      ),
                    ),
                  ),

                  // æ‹ç…§æŒ‰é’®
                  GestureDetector(
                    onTap: _takePicture,
                    child: Container(
                      width: 80,
                      height: 80,
                      decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        border: Border.all(color: Colors.white, width: 4),
                      ),
                      child: Container(
                        margin: EdgeInsets.all(8),
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          color: Colors.white,
                        ),
                      ),
                    ),
                  ),

                  // ä¸Šä¼ çŠ¶æ€
                  Container(
                    width: 60,
                    height: 60,
                    child: _isUploading
                        ? CircularProgressIndicator(color: Colors.white)
                        : IconButton(
                            icon: Icon(Icons.cloud_upload, color: Colors.white, size: 30),
                            onPressed: _uploadPendingPhotos,
                          ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}
```

#### 3.3.2 Next.js Webç«¯å®ç°

```javascript
// pages/s/[shareCode].js - åˆ†äº«å±•ç¤ºé¡µé¢
import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import io from 'socket.io-client';
import Masonry from 'react-masonry-css';
import Lightbox from 'react-image-lightbox';
import 'react-image-lightbox/style.css';

export default function SharePage({ session, photos: initialPhotos }) {
  const router = useRouter();
  const { shareCode } = router.query;

  const [photos, setPhotos] = useState(initialPhotos || []);
  const [socket, setSocket] = useState(null);
  const [onlineCount, setOnlineCount] = useState(0);
  const [lightboxIndex, setLightboxIndex] = useState(-1);
  const [selectedPhotos, setSelectedPhotos] = useState(new Set());

  useEffect(() => {
    if (!session) return;

    // å»ºç«‹WebSocketè¿æ¥
    const newSocket = io(process.env.NEXT_PUBLIC_API_URL);

    newSocket.on('connect', () => {
      console.log('WebSocketå·²è¿æ¥');
      newSocket.emit('join_session', session.id);
    });

    newSocket.on('new_photo', (photo) => {
      setPhotos(prev => [photo, ...prev]);

      // æ˜¾ç¤ºæ–°ç…§ç‰‡é€šçŸ¥
      showNotification('æ–°ç…§ç‰‡å·²æ·»åŠ !');
    });

    newSocket.on('online_count', (count) => {
      setOnlineCount(count);
    });

    setSocket(newSocket);

    return () => {
      newSocket.emit('leave_session', session.id);
      newSocket.disconnect();
    };
  }, [session]);

  const showNotification = (message) => {
    if (Notification.permission === 'granted') {
      new Notification('ç…§ç‰‡ç›´æ’­', {
        body: message,
        icon: '/icon-192x192.png'
      });
    }
  };

  const togglePhotoSelection = (photoId) => {
    const newSelection = new Set(selectedPhotos);
    if (newSelection.has(photoId)) {
      newSelection.delete(photoId);
    } else {
      newSelection.add(photoId);
    }
    setSelectedPhotos(newSelection);
  };

  const downloadSelectedPhotos = async () => {
    if (selectedPhotos.size === 0) return;

    const photoIds = Array.from(selectedPhotos);
    try {
      const response = await request(app)
        .post('/api/sessions')
        .send(sessionData)
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.name).toBe(sessionData.name);
      expect(response.body.data.session_id).toBeDefined();
    });

    it('åº”è¯¥éªŒè¯å¿…å¡«å­—æ®µ', async () => {
      const response = await request(app)
        .post('/api/sessions')
        .send({})
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('name');
    });
  });

  describe('GET /api/sessions/:id', () => {
    it('åº”è¯¥è¿”å›ç›¸å†Œè¯¦æƒ…', async () => {
      const session = await db.sessions.create({
        name: 'æµ‹è¯•ç›¸å†Œ',
        description: 'æµ‹è¯•æè¿°'
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}`)
        .expect(200);

      expect(response.body.data.name).toBe(session.name);
    });

    it('åº”è¯¥è¿”å›404å½“ç›¸å†Œä¸å­˜åœ¨', async () => {
      const response = await request(app)
        .get('/api/sessions/nonexistent')
        .expect(404);

      expect(response.body.code).toBe(404);
    });
  });
});
```

```javascript
// tests/api/photo.test.js
const request = require('supertest');
const path = require('path');
const app = require('../../app');
const db = require('../../models');

describe('Photo API', () => {
  let session;

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
    
    session = await db.sessions.create({
      name: 'æµ‹è¯•ç›¸å†Œ',
      description: 'æµ‹è¯•æè¿°'
    });
  });

  describe('POST /api/sessions/:id/photos', () => {
    it('åº”è¯¥æˆåŠŸä¸Šä¼ ç…§ç‰‡', async () => {
      const testImagePath = path.join(__dirname, '../fixtures/test-image.jpg');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testImagePath)
        .field('tags', JSON.stringify(['æµ‹è¯•', 'æ ·ä¾‹']))
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.photo_id).toBeDefined();
      expect(response.body.data.urls).toBeDefined();
    });

    it('åº”è¯¥æ‹’ç»éå›¾ç‰‡æ–‡ä»¶', async () => {
      const testFilePath = path.join(__dirname, '../fixtures/test-file.txt');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testFilePath)
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('å›¾ç‰‡');
    });
  });

  describe('GET /api/sessions/:id/photos', () => {
    it('åº”è¯¥è¿”å›ç…§ç‰‡åˆ—è¡¨', async () => {
      // åˆ›å»ºæµ‹è¯•ç…§ç‰‡
      await db.photos.create({
        session_id: session.id,
        filename: 'test.jpg',
        urls: { thumbnail: 'thumb.jpg', original: 'orig.jpg' },
        tags: ['æµ‹è¯•']
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].filename).toBe('test.jpg');
    });

    it('åº”è¯¥æ”¯æŒæ ‡ç­¾è¿‡æ»¤', async () => {
      await db.photos.bulkCreate([
        {
          session_id: session.id,
          filename: 'test1.jpg',
          urls: {},
          tags: ['äººç‰©']
        },
        {
          session_id: session.id,
          filename: 'test2.jpg',
          urls: {},
          tags: ['é£æ™¯']
        }
      ]);

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos?tags=äººç‰©`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].tags).toContain('äººç‰©');
    });
  });
});
```

### 5.2 é›†æˆæµ‹è¯•

```javascript
// tests/integration/workflow.test.js
const request = require('supertest');
const app = require('../../app');
const db = require('../../models');
const WebSocket = require('ws');

describe('å®Œæ•´å·¥ä½œæµç¨‹æµ‹è¯•', () => {
  let session;
  let ws;

  beforeAll(async () => {
    // å¯åŠ¨WebSocketè¿æ¥
    ws = new WebSocket('ws://localhost:3000');
    await new Promise(resolve => ws.on('open', resolve));
  });

  afterAll(() => {
    ws.close();
  });

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
  });

  it('åº”è¯¥å®Œæˆå®Œæ•´çš„æ‹æ‘„åˆ†äº«æµç¨‹', async () => {
    // 1. åˆ›å»ºç›¸å†Œ
    const sessionResponse = await request(app)
      .post('/api/sessions')
      .send({
        name: 'å©šç¤¼æ‹æ‘„',
        description: 'å¼ ä¸‰æå››çš„å©šç¤¼',
        settings: {
          watermark: {
            enabled: true,
            text: 'å¼ ä¸‰â¤æå›› 2024.01.01'
          },
          access_protection: {
            enabled: true,
            access_code: '1234'
          }
        }
      })
      .expect(201);

    const sessionId = sessionResponse.body.data.session_id;

    // 2. åŠ å…¥ç›¸å†ŒWebSocketæˆ¿é—´
    ws.send(JSON.stringify({
      type: 'join_session',
      session_id: sessionId
    }));

    // 3. ä¸Šä¼ ç…§ç‰‡
    const uploadResponse = await request(app)
      .post(`/api/sessions/${sessionId}/photos`)
      .attach('photo', path.join(__dirname, '../fixtures/wedding.jpg'))
      .field('watermark_text', 'å¼ ä¸‰â¤æå›› 2024.01.01')
      .field('auto_tag', 'true')
      .expect(201);

    const photoId = uploadResponse.body.data.photo_id;

    // 4. éªŒè¯WebSocketæ¨é€
    const wsMessage = await new Promise(resolve => {
      ws.on('message', data => {
        const message = JSON.parse(data);
        if (message.type === 'new_photo') {
          resolve(message);
        }
      });
    });

    expect(wsMessage.data.photo_id).toBe(photoId);

    // 5. è®¿å®¢è®¿é—®ï¼ˆéœ€è¦è®¿é—®ç ï¼‰
    const guestResponse = await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=1234`)
      .expect(200);

    expect(guestResponse.body.data.photos).toHaveLength(1);

    // 6. é”™è¯¯è®¿é—®ç æµ‹è¯•
    await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=wrong`)
      .expect(403);
  });

  it('åº”è¯¥æ”¯æŒæ–­ç‚¹ç»­ä¼ ', async () => {
    const session = await db.sessions.create({
      name: 'æµ‹è¯•ç›¸å†Œ'
    });

    // 1. åˆå§‹åŒ–ä¸Šä¼ 
    const initResponse = await request(app)
      .post('/api/upload/init')
      .send({
        filename: 'large-photo.jpg',
        fileSize: 5 * 1024 * 1024, // 5MB
        chunkSize: 1024 * 1024 // 1MB
      })
      .expect(200);

    const uploadId = initResponse.body.data.uploadId;

    // 2. ä¸Šä¼ åˆ†ç‰‡
    const chunk1 = Buffer.alloc(1024 * 1024, 'a');
    await request(app)
      .post(`/api/upload/chunk/${uploadId}/0`)
      .send(chunk1)
      .expect(200);

    // 3. æ£€æŸ¥ä¸Šä¼ çŠ¶æ€
    const statusResponse = await request(app)
      .get(`/api/upload/status/${uploadId}`)
      .expect(200);

    expect(statusResponse.body.data.uploaded).toBe(1);
    expect(statusResponse.body.data.total).toBe(5);
  });
});
```

### 5.3 æ€§èƒ½æµ‹è¯•

```javascript
// tests/performance/load.test.js
const autocannon = require('autocannon');
const app = require('../../app');

describe('æ€§èƒ½æµ‹è¯•', () => {
  let server;

  beforeAll(() => {
    server = app.listen(0);
  });

  afterAll(() => {
    server.close();
  });

  it('APIå¹¶å‘æ€§èƒ½æµ‹è¯•', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions`,
      method: 'GET',
      connections: 100,
      duration: 10,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    expect(result.errors).toBe(0);
    expect(result.requests.average).toBeGreaterThan(100); // å¹³å‡æ¯ç§’100+è¯·æ±‚
  });

  it('å›¾ç‰‡ä¸Šä¼ æ€§èƒ½æµ‹è¯•', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions/test/photos`,
      method: 'POST',
      connections: 10,
      duration: 30,
      setupClient: (client) => {
        // æ¨¡æ‹Ÿæ–‡ä»¶ä¸Šä¼ 
        client.setBody(Buffer.alloc(1024 * 100, 'test')); // 100KBæµ‹è¯•æ–‡ä»¶
        client.setHeaders({
          'Content-Type': 'multipart/form-data'
        });
      }
    });

    expect(result.errors).toBe(0);
    expect(result.latency.p99).toBeLessThan(5000); // 99%è¯·æ±‚åœ¨5ç§’å†…å®Œæˆ
  });
});
```

## 6. é¡¹ç›®è§„åˆ’

### 6.1 å¼€å‘é˜¶æ®µ

#### ç¬¬ä¸€é˜¶æ®µï¼šMVPç‰ˆæœ¬ï¼ˆ4-6å‘¨ï¼‰

**æ ¸å¿ƒåŠŸèƒ½**
- åŸºç¡€ç›¸å†Œç®¡ç†ï¼ˆåˆ›å»ºã€æŸ¥çœ‹ï¼‰
- ç…§ç‰‡ä¸Šä¼ å’Œå±•ç¤º
- ç®€å•çš„å®æ—¶æ¨é€
- åŸºç¡€çš„Webç«¯æŸ¥çœ‹ç•Œé¢
- ç§»åŠ¨ç«¯æ‹æ‘„åº”ç”¨ï¼ˆåŸºç¡€ç‰ˆï¼‰

**æŠ€æœ¯æ ˆ**
- åç«¯ï¼šNode.js + Express + PostgreSQL
- å‰ç«¯ï¼šNext.js + React
- ç§»åŠ¨ç«¯ï¼šFlutter
- å®æ—¶é€šä¿¡ï¼šSocket.IO
- æ–‡ä»¶å­˜å‚¨ï¼šæœ¬åœ°å­˜å‚¨

**é‡Œç¨‹ç¢‘**
- Week 1-2: åç«¯APIåŸºç¡€æ¶æ„
- Week 3-4: å‰ç«¯ç•Œé¢å¼€å‘
- Week 5-6: ç§»åŠ¨ç«¯åº”ç”¨å¼€å‘å’Œé›†æˆæµ‹è¯•

#### ç¬¬äºŒé˜¶æ®µï¼šåŠŸèƒ½å¢å¼ºï¼ˆ6-8å‘¨ï¼‰

**æ–°å¢åŠŸèƒ½**
- è®¿é—®ç ä¿æŠ¤
- å›¾ç‰‡æ°´å°
- å¤šåˆ†è¾¨ç‡æ”¯æŒ
- åŸºç¡€æ ‡ç­¾ç³»ç»Ÿ
- äº‘å­˜å‚¨é›†æˆï¼ˆé˜¿é‡Œäº‘OSSï¼‰
- æ€§èƒ½ä¼˜åŒ–

**æŠ€æœ¯å‡çº§**
- Redisç¼“å­˜
- å›¾ç‰‡å¤„ç†é˜Ÿåˆ—
- CDNé›†æˆ
- ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ

**é‡Œç¨‹ç¢‘**
- Week 1-2: å®‰å…¨åŠŸèƒ½å’Œè®¿é—®æ§åˆ¶
- Week 3-4: å›¾ç‰‡å¤„ç†å’Œå­˜å‚¨ä¼˜åŒ–
- Week 5-6: æ ‡ç­¾ç³»ç»Ÿå’Œæœç´¢åŠŸèƒ½
- Week 7-8: æ€§èƒ½ä¼˜åŒ–å’Œç›‘æ§

#### ç¬¬ä¸‰é˜¶æ®µï¼šé«˜çº§åŠŸèƒ½ï¼ˆ8-10å‘¨ï¼‰

**é«˜çº§åŠŸèƒ½**
- AIè‡ªåŠ¨æ ‡ç­¾
- ç…§ç‰‡å®¡æ ¸ç³»ç»Ÿ
- æ–­ç‚¹ç»­ä¼ 
- å¤šè¯­è¨€æ”¯æŒ
- é«˜çº§æ°´å°å®šåˆ¶
- æ‰¹é‡æ“ä½œ

**å•†ä¸šåŒ–åŠŸèƒ½**
- ç”¨æˆ·ç³»ç»Ÿå’Œæƒé™ç®¡ç†
- å¥—é¤å’Œè®¡è´¹
- æ•°æ®åˆ†æå’ŒæŠ¥è¡¨
- APIå¼€æ”¾å¹³å°

**é‡Œç¨‹ç¢‘**
- Week 1-3: AIåŠŸèƒ½é›†æˆ
- Week 4-6: å®¡æ ¸å’Œç®¡ç†ç³»ç»Ÿ
- Week 7-8: å•†ä¸šåŒ–åŠŸèƒ½
- Week 9-10: æµ‹è¯•å’Œä¸Šçº¿å‡†å¤‡

### 6.2 å›¢é˜Ÿé…ç½®

**æ ¸å¿ƒå›¢é˜Ÿï¼ˆ5-7äººï¼‰**
- é¡¹ç›®ç»ç† Ã— 1
- åç«¯å¼€å‘ Ã— 2
- å‰ç«¯å¼€å‘ Ã— 1
- ç§»åŠ¨ç«¯å¼€å‘ Ã— 1
- UI/UXè®¾è®¡å¸ˆ Ã— 1
- æµ‹è¯•å·¥ç¨‹å¸ˆ Ã— 1

**æŠ€èƒ½è¦æ±‚**
- åç«¯ï¼šNode.jsã€æ•°æ®åº“è®¾è®¡ã€äº‘æœåŠ¡ã€æ€§èƒ½ä¼˜åŒ–
- å‰ç«¯ï¼šReactã€Next.jsã€å“åº”å¼è®¾è®¡
- ç§»åŠ¨ç«¯ï¼šFlutterã€ç›¸æœºAPIã€æ–‡ä»¶ä¸Šä¼ 
- è®¾è®¡ï¼šUIè®¾è®¡ã€ç”¨æˆ·ä½“éªŒã€åŸå‹è®¾è®¡
- æµ‹è¯•ï¼šè‡ªåŠ¨åŒ–æµ‹è¯•ã€æ€§èƒ½æµ‹è¯•ã€å®‰å…¨æµ‹è¯•

### 6.3 æˆæœ¬ä¼°ç®—

#### å¼€å‘æˆæœ¬
- äººåŠ›æˆæœ¬ï¼š50-70ä¸‡ï¼ˆ6ä¸ªæœˆï¼‰
- è®¾å¤‡å’Œå·¥å…·ï¼š5-10ä¸‡
- ç¬¬ä¸‰æ–¹æœåŠ¡ï¼š2-5ä¸‡
- **æ€»è®¡ï¼š57-85ä¸‡**

#### è¿è¥æˆæœ¬ï¼ˆæœˆï¼‰
- æœåŠ¡å™¨ï¼š5,000-15,000å…ƒ
- äº‘å­˜å‚¨ï¼š2,000-8,000å…ƒ
- CDNï¼š1,000-5,000å…ƒ
- ç›‘æ§å’Œå®‰å…¨ï¼š1,000-3,000å…ƒ
- **æœˆè¿è¥æˆæœ¬ï¼š9,000-31,000å…ƒ**

#### æ”¶å…¥æ¨¡å¼
- åŸºç¡€ç‰ˆï¼šå…è´¹ï¼ˆé™åˆ¶åŠŸèƒ½ï¼‰
- ä¸“ä¸šç‰ˆï¼š299å…ƒ/æœˆï¼ˆå®Œæ•´åŠŸèƒ½ï¼‰
- ä¼ä¸šç‰ˆï¼š999å…ƒ/æœˆï¼ˆå®šåˆ¶æœåŠ¡ï¼‰
- æŒ‰éœ€æœåŠ¡ï¼š1-5å…ƒ/GBå­˜å‚¨

## 7. é£é™©è¯„ä¼°ä¸åº”å¯¹

### 7.1 æŠ€æœ¯é£é™©

#### é«˜é£é™©
**1. å¤§æ–‡ä»¶ä¸Šä¼ ç¨³å®šæ€§**
- é£é™©ï¼šç½‘ç»œä¸ç¨³å®šå¯¼è‡´ä¸Šä¼ å¤±è´¥
- åº”å¯¹ï¼šæ–­ç‚¹ç»­ä¼ ã€é‡è¯•æœºåˆ¶ã€è¿›åº¦ä¿å­˜
- é¢„æ¡ˆï¼šæœ¬åœ°ç¼“å­˜ã€ç¦»çº¿ä¸Šä¼ é˜Ÿåˆ—

**2. å®æ—¶æ€§èƒ½ç“¶é¢ˆ**
- é£é™©ï¼šé«˜å¹¶å‘æ—¶WebSocketè¿æ¥æ•°è¿‡å¤š
- åº”å¯¹ï¼šè¿æ¥æ± ç®¡ç†ã€è´Ÿè½½å‡è¡¡ã€Redisé›†ç¾¤
- é¢„æ¡ˆï¼šé™çº§ä¸ºè½®è¯¢æ¨¡å¼

#### ä¸­é£é™©
**3. å›¾ç‰‡å¤„ç†æ€§èƒ½**
- é£é™©ï¼šå¤§é‡å›¾ç‰‡åŒæ—¶å¤„ç†å¯¼è‡´æœåŠ¡å™¨å‹åŠ›
- åº”å¯¹ï¼šå¼‚æ­¥é˜Ÿåˆ—ã€åˆ†å¸ƒå¼å¤„ç†ã€ç¼“å­˜ç­–ç•¥
- é¢„æ¡ˆï¼šå¤–éƒ¨å›¾ç‰‡å¤„ç†æœåŠ¡

**4. å­˜å‚¨æˆæœ¬æ§åˆ¶**
- é£é™©ï¼šå­˜å‚¨è´¹ç”¨å¿«é€Ÿå¢é•¿
- åº”å¯¹ï¼šæ™ºèƒ½å‹ç¼©ã€å®šæœŸæ¸…ç†ã€åˆ†å±‚å­˜å‚¨
- é¢„æ¡ˆï¼šç”¨æˆ·ä»˜è´¹å­˜å‚¨æ¨¡å¼

### 7.2 ä¸šåŠ¡é£é™©

#### é«˜é£é™©
**1. ç”¨æˆ·éšç§å’Œæ•°æ®å®‰å…¨**
- é£é™©ï¼šç…§ç‰‡æ³„éœ²ã€æ•°æ®è¢«ç›—
- åº”å¯¹ï¼šåŠ å¯†å­˜å‚¨ã€è®¿é—®æ§åˆ¶ã€å®‰å…¨å®¡è®¡
- é¢„æ¡ˆï¼šä¿é™©å’Œæ³•å¾‹ä¿æŠ¤

**2. ç‰ˆæƒå’Œæ³•å¾‹é—®é¢˜**
- é£é™©ï¼šç”¨æˆ·ä¸Šä¼ ä¾µæƒå†…å®¹
- åº”å¯¹ï¼šå†…å®¹å®¡æ ¸ã€ç”¨æˆ·åè®®ã€ä¸¾æŠ¥æœºåˆ¶
- é¢„æ¡ˆï¼šå¿«é€Ÿåˆ é™¤å’Œæ³•å¾‹æ”¯æŒ

#### ä¸­é£é™©
**3. å¸‚åœºç«äº‰**
- é£é™©ï¼šå¤§å‚æ¨å‡ºç±»ä¼¼äº§å“
- åº”å¯¹ï¼šå·®å¼‚åŒ–åŠŸèƒ½ã€ç”¨æˆ·ç²˜æ€§ã€å¿«é€Ÿè¿­ä»£
- é¢„æ¡ˆï¼šç»†åˆ†å¸‚åœºå®šä½

**4. ç”¨æˆ·è·å–æˆæœ¬**
- é£é™©ï¼šè·å®¢æˆæœ¬è¿‡é«˜
- åº”å¯¹ï¼šå£ç¢‘è¥é”€ã€åˆä½œæ¨å¹¿ã€å…è´¹è¯•ç”¨
- é¢„æ¡ˆï¼šè°ƒæ•´å•†ä¸šæ¨¡å¼

### 7.3 è¿è¥é£é™©

#### ä¸­é£é™©
**1. æœåŠ¡å¯ç”¨æ€§**
- é£é™©ï¼šæœåŠ¡ä¸­æ–­å½±å“ç”¨æˆ·ä½“éªŒ
- åº”å¯¹ï¼šå¤šåœ°éƒ¨ç½²ã€è‡ªåŠ¨æ•…éšœè½¬ç§»ã€ç›‘æ§å‘Šè­¦
- é¢„æ¡ˆï¼šç´§æ€¥æ¢å¤æµç¨‹

**2. å›¢é˜Ÿç¨³å®šæ€§**
- é£é™©ï¼šæ ¸å¿ƒå¼€å‘äººå‘˜ç¦»èŒ
- åº”å¯¹ï¼šçŸ¥è¯†æ–‡æ¡£åŒ–ã€ä»£ç è§„èŒƒã€å›¢é˜Ÿå»ºè®¾
- é¢„æ¡ˆï¼šå¤–åŒ…å’Œæ‹›è˜è®¡åˆ’

### 7.4 åº”æ€¥é¢„æ¡ˆ

**æŠ€æœ¯æ•…éšœåº”æ€¥**
1. å»ºç«‹24å°æ—¶ç›‘æ§å’Œå‘Šè­¦
2. åˆ¶å®šæ•…éšœç­‰çº§å’Œå“åº”æ—¶é—´
3. å‡†å¤‡å›æ»šå’Œé™çº§æ–¹æ¡ˆ
4. å®šæœŸè¿›è¡Œæ•…éšœæ¼”ç»ƒ

**æ•°æ®å®‰å…¨åº”æ€¥**
1. å®šæœŸæ•°æ®å¤‡ä»½å’Œæ¢å¤æµ‹è¯•
2. å»ºç«‹æ•°æ®æ³„éœ²å“åº”æµç¨‹
3. å‡†å¤‡æ³•å¾‹å’Œå…¬å…³åº”å¯¹
4. ç”¨æˆ·é€šçŸ¥å’Œè¡¥å¿æœºåˆ¶

**ä¸šåŠ¡è¿ç»­æ€§**
1. å¤šäº‘éƒ¨ç½²é¿å…å•ç‚¹æ•…éšœ
2. æ ¸å¿ƒåŠŸèƒ½ç¦»çº¿å¯ç”¨
3. åˆä½œä¼™ä¼´å¤‡é€‰æ–¹æ¡ˆ
4. èµ„é‡‘å‚¨å¤‡å’Œèèµ„è®¡åˆ’

## 8. æ€»ç»“

æœ¬å¼€å‘æ–¹æ¡ˆä¸ºä¸ªäººç…§ç‰‡ç›´æ’­åº”ç”¨æä¾›äº†å®Œæ•´çš„æŠ€æœ¯æ¶æ„å’Œå®æ–½è·¯å¾„ã€‚æ–¹æ¡ˆå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

### 8.1 æŠ€æœ¯ä¼˜åŠ¿
- **ç°ä»£åŒ–æŠ€æœ¯æ ˆ**ï¼šé‡‡ç”¨Node.jsã€Reactã€Flutterç­‰ä¸»æµæŠ€æœ¯
- **å¯æ‰©å±•æ¶æ„**ï¼šå¾®æœåŠ¡è®¾è®¡ï¼Œæ”¯æŒæ°´å¹³æ‰©å±•
- **æ€§èƒ½ä¼˜åŒ–**ï¼šå¤šçº§ç¼“å­˜ã€CDNã€å›¾ç‰‡å‹ç¼©ç­‰ä¼˜åŒ–ç­–ç•¥
- **å®‰å…¨å¯é **ï¼šè®¿é—®æ§åˆ¶ã€æ•°æ®åŠ å¯†ã€å¤‡ä»½æ¢å¤

### 8.2 åŠŸèƒ½å®Œæ•´æ€§
- **æ ¸å¿ƒåŠŸèƒ½é½å…¨**ï¼šæ‹æ‘„ã€ä¸Šä¼ ã€åˆ†äº«ã€æŸ¥çœ‹å®Œæ•´æµç¨‹
- **ç”¨æˆ·ä½“éªŒä¼˜ç§€**ï¼šå®æ—¶æ¨é€ã€æ–­ç‚¹ç»­ä¼ ã€å¤šç«¯é€‚é…
- **ç®¡ç†åŠŸèƒ½å¼ºå¤§**ï¼šæ ‡ç­¾åˆ†ç±»ã€å®¡æ ¸ç³»ç»Ÿã€æ•°æ®åˆ†æ
- **å•†ä¸šåŒ–å°±ç»ª**ï¼šç”¨æˆ·ç³»ç»Ÿã€è®¡è´¹æ¨¡å¼ã€APIå¼€æ”¾

### 8.3 å®æ–½å¯è¡Œæ€§
- **åˆ†é˜¶æ®µå¼€å‘**ï¼šMVPâ†’åŠŸèƒ½å¢å¼ºâ†’å•†ä¸šåŒ–ï¼Œé£é™©å¯æ§
- **æˆæœ¬åˆç†**ï¼šå¼€å‘å’Œè¿è¥æˆæœ¬åœ¨å¯æ¥å—èŒƒå›´
- **å›¢é˜Ÿè¦æ±‚æ˜ç¡®**ï¼šæŠ€èƒ½è¦æ±‚å’Œäººå‘˜é…ç½®æ¸…æ™°
- **é£é™©å¯æ§**ï¼šè¯†åˆ«ä¸»è¦é£é™©å¹¶åˆ¶å®šåº”å¯¹ç­–ç•¥

### 8.4 å¸‚åœºå‰æ™¯
- **éœ€æ±‚æ˜ç¡®**ï¼šæ‘„å½±å¸ˆå’Œæ´»åŠ¨ç»„ç»‡è€…æœ‰çœŸå®éœ€æ±‚
- **å·®å¼‚åŒ–æ˜æ˜¾**ï¼šä¸“æ³¨äºä¸“ä¸šæ‘„å½±åœºæ™¯
- **å•†ä¸šæ¨¡å¼æ¸…æ™°**ï¼šå¤šç§æ”¶è´¹æ¨¡å¼ï¼Œå¯æŒç»­å‘å±•
- **æ‰©å±•æ€§å¼º**ï¼šå¯æ‹“å±•åˆ°æ›´å¤šå‚ç›´é¢†åŸŸ

**å»ºè®®ç«‹å³å¯åŠ¨MVPå¼€å‘ï¼ŒéªŒè¯æ ¸å¿ƒåŠŸèƒ½å’Œå¸‚åœºéœ€æ±‚ï¼Œä¸ºåç»­åŠŸèƒ½è¿­ä»£å’Œå•†ä¸šåŒ–å¥ å®šåŸºç¡€ã€‚** fetch(`/api/download`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sessionId: session.id,
          photoIds: photoIds
        })
      });

      if (response.ok) {
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${session.name}_selected_photos.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
      } else {
        throw new Error('ä¸‹è½½å¤±è´¥');
      }
    } catch (error) {
      alert('ä¸‹è½½å¤±è´¥: ' + error.message);
    }
  };

  const breakpointColumns = {
    default: 4,
    1100: 3,
    700: 2,
    500: 1
  };

  if (!session) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <h1 className="text-2xl font-bold text-gray-800 mb-4">
            æ‰¾ä¸åˆ°æ­¤åˆ†äº«
          </h1>
          <p className="text-gray-600">
            è¯·æ£€æŸ¥é“¾æ¥æ˜¯å¦æ­£ç¡®ï¼Œæˆ–è”ç³»åˆ†äº«è€…
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* å¤´éƒ¨ */}
      <header className="bg-white shadow-sm border-b">
        <div className="container mx-auto px-4 py-4">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-2xl font-bold text-gray-800">
                {session.name}
              </h1>
              <p className="text-gray-600">
                {photos.length} å¼ ç…§ç‰‡ Â· {onlineCount} äººåœ¨çº¿
              </p>
            </div>

            <div className="flex items-center space-x-4">
              {selectedPhotos.size > 0 && (
                <button
                  onClick={downloadSelectedPhotos}
                  className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors"
                >
                  ä¸‹è½½é€‰ä¸­ ({selectedPhotos.size})
                </button>
              )}

              <button className="bg-gray-200 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-300 transition-colors">
                åˆ†äº«
              </button>
            </div>
          </div>
        </div>
      </header>

      {/* ç…§ç‰‡ç½‘æ ¼ */}
      <main className="container mx-auto px-4 py-6">
        {photos.length === 0 ? (
          <div className="text-center py-12">
            <div className="text-6xl mb-4">ğŸ“¸</div>
            <h3 className="text-xl font-semibold text-gray-800 mb-2">
              æš‚æ— ç…§ç‰‡
            </h3>
            <p className="text-gray-600">
              æ‘„å½±å¸ˆæ­£åœ¨å‡†å¤‡ä¸­ï¼Œè¯·ç¨ååˆ·æ–°é¡µé¢
            </p>
          </div>
        ) : (
          <Masonry
            breakpointCols={breakpointColumns}
            className="flex w-auto -ml-4"
            columnClassName="pl-4 bg-clip-padding"
          >
            {photos.map((photo, index) => (
              <div
                key={photo.id}
                className="mb-4 relative group cursor-pointer"
                onClick={() => setLightboxIndex(index)}
              >
                <img
                  src={photo.thumbnail_url}
                  alt={`ç…§ç‰‡ ${photo.id}`}
                  className="w-full rounded-lg shadow-md hover:shadow-lg transition-shadow"
                  loading="lazy"
                />

                {/* é€‰æ‹©è¦†ç›–å±‚ */}
                <div className="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-20 transition-all rounded-lg flex items-center justify-center">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      togglePhotoSelection(photo.id);
                    }}
                    className={`w-8 h-8 rounded-full border-2 transition-all ${
                      selectedPhotos.has(photo.id)
                        ? 'bg-blue-600 border-blue-600'
                        : 'border-white bg-white bg-opacity-80'
                    } opacity-0 group-hover:opacity-100`}
                  >
                    {selectedPhotos.has(photo.id) && (
                      <svg className="w-4 h-4 text-white mx-auto" fill="currentColor" viewBox="0 0 20 20">
                        <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                      </svg>
                    )}
                  </button>
                </div>

                {/* æ—¶é—´æˆ³ */}
                <div className="absolute bottom-2 left-2 bg-black bg-opacity-60 text-white text-xs px-2 py-1 rounded">
                  {new Date(photo.upload_time).toLocaleTimeString()}
                </div>
              </div>
            ))}
          </Masonry>
        )}
      </main>

      {/* ç¯ç®±ç»„ä»¶ */}
      {lightboxIndex >= 0 && (
        <Lightbox
          mainSrc={photos[lightboxIndex].original_url}
          nextSrc={photos[(lightboxIndex + 1) % photos.length]?.original_url}
          prevSrc={photos[(lightboxIndex + photos.length - 1) % photos.length]?.original_url}
          onCloseRequest={() => setLightboxIndex(-1)}
          onMovePrevRequest={() =>
            setLightboxIndex((lightboxIndex + photos.length - 1) % photos.length)
          }
          onMoveNextRequest={() =>
            setLightboxIndex((lightboxIndex + 1) % photos.length)
          }
          imageTitle={`ç…§ç‰‡ ${lightboxIndex + 1} / ${photos.length}`}
          imageCaption={new Date(photos[lightboxIndex].upload_time).toLocaleString()}
        />
      )}
    </div>
  );
}

// æœåŠ¡ç«¯æ¸²æŸ“è·å–æ•°æ®
export async function getServerSideProps({ params }) {
  const { shareCode } = params;

  try {
    const sessionResponse = await fetch(`${process.env.API_URL}/api/sessions/by-code/${shareCode}`);
    if (!sessionResponse.ok) {
      return { props: { session: null, photos: [] } };
    }

    const sessionData = await sessionResponse.json();
    const session = sessionData.data;

    const photosResponse = await fetch(`${process.env.API_URL}/api/sessions/${session.id}/photos?limit=50`);
    const photosData = await photosResponse.json();
    const photos = photosData.data.photos;

    return {
      props: {
        session,
        photos
      }
    };
  } catch (error) {
    console.error('è·å–æ•°æ®å¤±è´¥:', error);
    return { props: { session: null, photos: [] } };
  }
}
```

### 3.4 ç›¸æœºè¿æ¥è¯¦ç»†å®ç°

#### 3.4.1 WiFiç›¸æœºè¿æ¥ï¼ˆä»¥ä½³èƒ½ä¸ºä¾‹ï¼‰

```javascript
// lib/camera/canon_wifi.js - ä½³èƒ½WiFiè¿æ¥
class CanonWiFiCamera {
  constructor() {
    this.baseUrl = null;
    this.sessionId = null;
    this.isConnected = false;
  }

  // å‘ç°ç›¸æœº
  async discoverCamera() {
    // æ‰«æå±€åŸŸç½‘ä¸­çš„ä½³èƒ½ç›¸æœº
    const possibleIPs = this.generateIPRange('192.168.1', 1, 254);

    for (const ip of possibleIPs) {
      try {
        const response = await request(app)
        .post('/api/sessions')
        .send(sessionData)
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.name).toBe(sessionData.name);
      expect(response.body.data.session_id).toBeDefined();
    });

    it('åº”è¯¥éªŒè¯å¿…å¡«å­—æ®µ', async () => {
      const response = await request(app)
        .post('/api/sessions')
        .send({})
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('name');
    });
  });

  describe('GET /api/sessions/:id', () => {
    it('åº”è¯¥è¿”å›ç›¸å†Œè¯¦æƒ…', async () => {
      const session = await db.sessions.create({
        name: 'æµ‹è¯•ç›¸å†Œ',
        description: 'æµ‹è¯•æè¿°'
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}`)
        .expect(200);

      expect(response.body.data.name).toBe(session.name);
    });

    it('åº”è¯¥è¿”å›404å½“ç›¸å†Œä¸å­˜åœ¨', async () => {
      const response = await request(app)
        .get('/api/sessions/nonexistent')
        .expect(404);

      expect(response.body.code).toBe(404);
    });
  });
});
```

```javascript
// tests/api/photo.test.js
const request = require('supertest');
const path = require('path');
const app = require('../../app');
const db = require('../../models');

describe('Photo API', () => {
  let session;

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
    
    session = await db.sessions.create({
      name: 'æµ‹è¯•ç›¸å†Œ',
      description: 'æµ‹è¯•æè¿°'
    });
  });

  describe('POST /api/sessions/:id/photos', () => {
    it('åº”è¯¥æˆåŠŸä¸Šä¼ ç…§ç‰‡', async () => {
      const testImagePath = path.join(__dirname, '../fixtures/test-image.jpg');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testImagePath)
        .field('tags', JSON.stringify(['æµ‹è¯•', 'æ ·ä¾‹']))
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.photo_id).toBeDefined();
      expect(response.body.data.urls).toBeDefined();
    });

    it('åº”è¯¥æ‹’ç»éå›¾ç‰‡æ–‡ä»¶', async () => {
      const testFilePath = path.join(__dirname, '../fixtures/test-file.txt');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testFilePath)
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('å›¾ç‰‡');
    });
  });

  describe('GET /api/sessions/:id/photos', () => {
    it('åº”è¯¥è¿”å›ç…§ç‰‡åˆ—è¡¨', async () => {
      // åˆ›å»ºæµ‹è¯•ç…§ç‰‡
      await db.photos.create({
        session_id: session.id,
        filename: 'test.jpg',
        urls: { thumbnail: 'thumb.jpg', original: 'orig.jpg' },
        tags: ['æµ‹è¯•']
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].filename).toBe('test.jpg');
    });

    it('åº”è¯¥æ”¯æŒæ ‡ç­¾è¿‡æ»¤', async () => {
      await db.photos.bulkCreate([
        {
          session_id: session.id,
          filename: 'test1.jpg',
          urls: {},
          tags: ['äººç‰©']
        },
        {
          session_id: session.id,
          filename: 'test2.jpg',
          urls: {},
          tags: ['é£æ™¯']
        }
      ]);

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos?tags=äººç‰©`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].tags).toContain('äººç‰©');
    });
  });
});
```

### 5.2 é›†æˆæµ‹è¯•

```javascript
// tests/integration/workflow.test.js
const request = require('supertest');
const app = require('../../app');
const db = require('../../models');
const WebSocket = require('ws');

describe('å®Œæ•´å·¥ä½œæµç¨‹æµ‹è¯•', () => {
  let session;
  let ws;

  beforeAll(async () => {
    // å¯åŠ¨WebSocketè¿æ¥
    ws = new WebSocket('ws://localhost:3000');
    await new Promise(resolve => ws.on('open', resolve));
  });

  afterAll(() => {
    ws.close();
  });

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
  });

  it('åº”è¯¥å®Œæˆå®Œæ•´çš„æ‹æ‘„åˆ†äº«æµç¨‹', async () => {
    // 1. åˆ›å»ºç›¸å†Œ
    const sessionResponse = await request(app)
      .post('/api/sessions')
      .send({
        name: 'å©šç¤¼æ‹æ‘„',
        description: 'å¼ ä¸‰æå››çš„å©šç¤¼',
        settings: {
          watermark: {
            enabled: true,
            text: 'å¼ ä¸‰â¤æå›› 2024.01.01'
          },
          access_protection: {
            enabled: true,
            access_code: '1234'
          }
        }
      })
      .expect(201);

    const sessionId = sessionResponse.body.data.session_id;

    // 2. åŠ å…¥ç›¸å†ŒWebSocketæˆ¿é—´
    ws.send(JSON.stringify({
      type: 'join_session',
      session_id: sessionId
    }));

    // 3. ä¸Šä¼ ç…§ç‰‡
    const uploadResponse = await request(app)
      .post(`/api/sessions/${sessionId}/photos`)
      .attach('photo', path.join(__dirname, '../fixtures/wedding.jpg'))
      .field('watermark_text', 'å¼ ä¸‰â¤æå›› 2024.01.01')
      .field('auto_tag', 'true')
      .expect(201);

    const photoId = uploadResponse.body.data.photo_id;

    // 4. éªŒè¯WebSocketæ¨é€
    const wsMessage = await new Promise(resolve => {
      ws.on('message', data => {
        const message = JSON.parse(data);
        if (message.type === 'new_photo') {
          resolve(message);
        }
      });
    });

    expect(wsMessage.data.photo_id).toBe(photoId);

    // 5. è®¿å®¢è®¿é—®ï¼ˆéœ€è¦è®¿é—®ç ï¼‰
    const guestResponse = await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=1234`)
      .expect(200);

    expect(guestResponse.body.data.photos).toHaveLength(1);

    // 6. é”™è¯¯è®¿é—®ç æµ‹è¯•
    await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=wrong`)
      .expect(403);
  });

  it('åº”è¯¥æ”¯æŒæ–­ç‚¹ç»­ä¼ ', async () => {
    const session = await db.sessions.create({
      name: 'æµ‹è¯•ç›¸å†Œ'
    });

    // 1. åˆå§‹åŒ–ä¸Šä¼ 
    const initResponse = await request(app)
      .post('/api/upload/init')
      .send({
        filename: 'large-photo.jpg',
        fileSize: 5 * 1024 * 1024, // 5MB
        chunkSize: 1024 * 1024 // 1MB
      })
      .expect(200);

    const uploadId = initResponse.body.data.uploadId;

    // 2. ä¸Šä¼ åˆ†ç‰‡
    const chunk1 = Buffer.alloc(1024 * 1024, 'a');
    await request(app)
      .post(`/api/upload/chunk/${uploadId}/0`)
      .send(chunk1)
      .expect(200);

    // 3. æ£€æŸ¥ä¸Šä¼ çŠ¶æ€
    const statusResponse = await request(app)
      .get(`/api/upload/status/${uploadId}`)
      .expect(200);

    expect(statusResponse.body.data.uploaded).toBe(1);
    expect(statusResponse.body.data.total).toBe(5);
  });
});
```

### 5.3 æ€§èƒ½æµ‹è¯•

```javascript
// tests/performance/load.test.js
const autocannon = require('autocannon');
const app = require('../../app');

describe('æ€§èƒ½æµ‹è¯•', () => {
  let server;

  beforeAll(() => {
    server = app.listen(0);
  });

  afterAll(() => {
    server.close();
  });

  it('APIå¹¶å‘æ€§èƒ½æµ‹è¯•', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions`,
      method: 'GET',
      connections: 100,
      duration: 10,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    expect(result.errors).toBe(0);
    expect(result.requests.average).toBeGreaterThan(100); // å¹³å‡æ¯ç§’100+è¯·æ±‚
  });

  it('å›¾ç‰‡ä¸Šä¼ æ€§èƒ½æµ‹è¯•', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions/test/photos`,
      method: 'POST',
      connections: 10,
      duration: 30,
      setupClient: (client) => {
        // æ¨¡æ‹Ÿæ–‡ä»¶ä¸Šä¼ 
        client.setBody(Buffer.alloc(1024 * 100, 'test')); // 100KBæµ‹è¯•æ–‡ä»¶
        client.setHeaders({
          'Content-Type': 'multipart/form-data'
        });
      }
    });

    expect(result.errors).toBe(0);
    expect(result.latency.p99).toBeLessThan(5000); // 99%è¯·æ±‚åœ¨5ç§’å†…å®Œæˆ
  });
});
```

## 6. é¡¹ç›®è§„åˆ’

### 6.1 å¼€å‘é˜¶æ®µ

#### ç¬¬ä¸€é˜¶æ®µï¼šMVPç‰ˆæœ¬ï¼ˆ4-6å‘¨ï¼‰

**æ ¸å¿ƒåŠŸèƒ½**
- åŸºç¡€ç›¸å†Œç®¡ç†ï¼ˆåˆ›å»ºã€æŸ¥çœ‹ï¼‰
- ç…§ç‰‡ä¸Šä¼ å’Œå±•ç¤º
- ç®€å•çš„å®æ—¶æ¨é€
- åŸºç¡€çš„Webç«¯æŸ¥çœ‹ç•Œé¢
- ç§»åŠ¨ç«¯æ‹æ‘„åº”ç”¨ï¼ˆåŸºç¡€ç‰ˆï¼‰

**æŠ€æœ¯æ ˆ**
- åç«¯ï¼šNode.js + Express + PostgreSQL
- å‰ç«¯ï¼šNext.js + React
- ç§»åŠ¨ç«¯ï¼šFlutter
- å®æ—¶é€šä¿¡ï¼šSocket.IO
- æ–‡ä»¶å­˜å‚¨ï¼šæœ¬åœ°å­˜å‚¨

**é‡Œç¨‹ç¢‘**
- Week 1-2: åç«¯APIåŸºç¡€æ¶æ„
- Week 3-4: å‰ç«¯ç•Œé¢å¼€å‘
- Week 5-6: ç§»åŠ¨ç«¯åº”ç”¨å¼€å‘å’Œé›†æˆæµ‹è¯•

#### ç¬¬äºŒé˜¶æ®µï¼šåŠŸèƒ½å¢å¼ºï¼ˆ6-8å‘¨ï¼‰

**æ–°å¢åŠŸèƒ½**
- è®¿é—®ç ä¿æŠ¤
- å›¾ç‰‡æ°´å°
- å¤šåˆ†è¾¨ç‡æ”¯æŒ
- åŸºç¡€æ ‡ç­¾ç³»ç»Ÿ
- äº‘å­˜å‚¨é›†æˆï¼ˆé˜¿é‡Œäº‘OSSï¼‰
- æ€§èƒ½ä¼˜åŒ–

**æŠ€æœ¯å‡çº§**
- Redisç¼“å­˜
- å›¾ç‰‡å¤„ç†é˜Ÿåˆ—
- CDNé›†æˆ
- ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ

**é‡Œç¨‹ç¢‘**
- Week 1-2: å®‰å…¨åŠŸèƒ½å’Œè®¿é—®æ§åˆ¶
- Week 3-4: å›¾ç‰‡å¤„ç†å’Œå­˜å‚¨ä¼˜åŒ–
- Week 5-6: æ ‡ç­¾ç³»ç»Ÿå’Œæœç´¢åŠŸèƒ½
- Week 7-8: æ€§èƒ½ä¼˜åŒ–å’Œç›‘æ§

#### ç¬¬ä¸‰é˜¶æ®µï¼šé«˜çº§åŠŸèƒ½ï¼ˆ8-10å‘¨ï¼‰

**é«˜çº§åŠŸèƒ½**
- AIè‡ªåŠ¨æ ‡ç­¾
- ç…§ç‰‡å®¡æ ¸ç³»ç»Ÿ
- æ–­ç‚¹ç»­ä¼ 
- å¤šè¯­è¨€æ”¯æŒ
- é«˜çº§æ°´å°å®šåˆ¶
- æ‰¹é‡æ“ä½œ

**å•†ä¸šåŒ–åŠŸèƒ½**
- ç”¨æˆ·ç³»ç»Ÿå’Œæƒé™ç®¡ç†
- å¥—é¤å’Œè®¡è´¹
- æ•°æ®åˆ†æå’ŒæŠ¥è¡¨
- APIå¼€æ”¾å¹³å°

**é‡Œç¨‹ç¢‘**
- Week 1-3: AIåŠŸèƒ½é›†æˆ
- Week 4-6: å®¡æ ¸å’Œç®¡ç†ç³»ç»Ÿ
- Week 7-8: å•†ä¸šåŒ–åŠŸèƒ½
- Week 9-10: æµ‹è¯•å’Œä¸Šçº¿å‡†å¤‡

### 6.2 å›¢é˜Ÿé…ç½®

**æ ¸å¿ƒå›¢é˜Ÿï¼ˆ5-7äººï¼‰**
- é¡¹ç›®ç»ç† Ã— 1
- åç«¯å¼€å‘ Ã— 2
- å‰ç«¯å¼€å‘ Ã— 1
- ç§»åŠ¨ç«¯å¼€å‘ Ã— 1
- UI/UXè®¾è®¡å¸ˆ Ã— 1
- æµ‹è¯•å·¥ç¨‹å¸ˆ Ã— 1

**æŠ€èƒ½è¦æ±‚**
- åç«¯ï¼šNode.jsã€æ•°æ®åº“è®¾è®¡ã€äº‘æœåŠ¡ã€æ€§èƒ½ä¼˜åŒ–
- å‰ç«¯ï¼šReactã€Next.jsã€å“åº”å¼è®¾è®¡
- ç§»åŠ¨ç«¯ï¼šFlutterã€ç›¸æœºAPIã€æ–‡ä»¶ä¸Šä¼ 
- è®¾è®¡ï¼šUIè®¾è®¡ã€ç”¨æˆ·ä½“éªŒã€åŸå‹è®¾è®¡
- æµ‹è¯•ï¼šè‡ªåŠ¨åŒ–æµ‹è¯•ã€æ€§èƒ½æµ‹è¯•ã€å®‰å…¨æµ‹è¯•

### 6.3 æˆæœ¬ä¼°ç®—

#### å¼€å‘æˆæœ¬
- äººåŠ›æˆæœ¬ï¼š50-70ä¸‡ï¼ˆ6ä¸ªæœˆï¼‰
- è®¾å¤‡å’Œå·¥å…·ï¼š5-10ä¸‡
- ç¬¬ä¸‰æ–¹æœåŠ¡ï¼š2-5ä¸‡
- **æ€»è®¡ï¼š57-85ä¸‡**

#### è¿è¥æˆæœ¬ï¼ˆæœˆï¼‰
- æœåŠ¡å™¨ï¼š5,000-15,000å…ƒ
- äº‘å­˜å‚¨ï¼š2,000-8,000å…ƒ
- CDNï¼š1,000-5,000å…ƒ
- ç›‘æ§å’Œå®‰å…¨ï¼š1,000-3,000å…ƒ
- **æœˆè¿è¥æˆæœ¬ï¼š9,000-31,000å…ƒ**

#### æ”¶å…¥æ¨¡å¼
- åŸºç¡€ç‰ˆï¼šå…è´¹ï¼ˆé™åˆ¶åŠŸèƒ½ï¼‰
- ä¸“ä¸šç‰ˆï¼š299å…ƒ/æœˆï¼ˆå®Œæ•´åŠŸèƒ½ï¼‰
- ä¼ä¸šç‰ˆï¼š999å…ƒ/æœˆï¼ˆå®šåˆ¶æœåŠ¡ï¼‰
- æŒ‰éœ€æœåŠ¡ï¼š1-5å…ƒ/GBå­˜å‚¨

## 7. é£é™©è¯„ä¼°ä¸åº”å¯¹

### 7.1 æŠ€æœ¯é£é™©

#### é«˜é£é™©
**1. å¤§æ–‡ä»¶ä¸Šä¼ ç¨³å®šæ€§**
- é£é™©ï¼šç½‘ç»œä¸ç¨³å®šå¯¼è‡´ä¸Šä¼ å¤±è´¥
- åº”å¯¹ï¼šæ–­ç‚¹ç»­ä¼ ã€é‡è¯•æœºåˆ¶ã€è¿›åº¦ä¿å­˜
- é¢„æ¡ˆï¼šæœ¬åœ°ç¼“å­˜ã€ç¦»çº¿ä¸Šä¼ é˜Ÿåˆ—

**2. å®æ—¶æ€§èƒ½ç“¶é¢ˆ**
- é£é™©ï¼šé«˜å¹¶å‘æ—¶WebSocketè¿æ¥æ•°è¿‡å¤š
- åº”å¯¹ï¼šè¿æ¥æ± ç®¡ç†ã€è´Ÿè½½å‡è¡¡ã€Redisé›†ç¾¤
- é¢„æ¡ˆï¼šé™çº§ä¸ºè½®è¯¢æ¨¡å¼

#### ä¸­é£é™©
**3. å›¾ç‰‡å¤„ç†æ€§èƒ½**
- é£é™©ï¼šå¤§é‡å›¾ç‰‡åŒæ—¶å¤„ç†å¯¼è‡´æœåŠ¡å™¨å‹åŠ›
- åº”å¯¹ï¼šå¼‚æ­¥é˜Ÿåˆ—ã€åˆ†å¸ƒå¼å¤„ç†ã€ç¼“å­˜ç­–ç•¥
- é¢„æ¡ˆï¼šå¤–éƒ¨å›¾ç‰‡å¤„ç†æœåŠ¡

**4. å­˜å‚¨æˆæœ¬æ§åˆ¶**
- é£é™©ï¼šå­˜å‚¨è´¹ç”¨å¿«é€Ÿå¢é•¿
- åº”å¯¹ï¼šæ™ºèƒ½å‹ç¼©ã€å®šæœŸæ¸…ç†ã€åˆ†å±‚å­˜å‚¨
- é¢„æ¡ˆï¼šç”¨æˆ·ä»˜è´¹å­˜å‚¨æ¨¡å¼

### 7.2 ä¸šåŠ¡é£é™©

#### é«˜é£é™©
**1. ç”¨æˆ·éšç§å’Œæ•°æ®å®‰å…¨**
- é£é™©ï¼šç…§ç‰‡æ³„éœ²ã€æ•°æ®è¢«ç›—
- åº”å¯¹ï¼šåŠ å¯†å­˜å‚¨ã€è®¿é—®æ§åˆ¶ã€å®‰å…¨å®¡è®¡
- é¢„æ¡ˆï¼šä¿é™©å’Œæ³•å¾‹ä¿æŠ¤

**2. ç‰ˆæƒå’Œæ³•å¾‹é—®é¢˜**
- é£é™©ï¼šç”¨æˆ·ä¸Šä¼ ä¾µæƒå†…å®¹
- åº”å¯¹ï¼šå†…å®¹å®¡æ ¸ã€ç”¨æˆ·åè®®ã€ä¸¾æŠ¥æœºåˆ¶
- é¢„æ¡ˆï¼šå¿«é€Ÿåˆ é™¤å’Œæ³•å¾‹æ”¯æŒ

#### ä¸­é£é™©
**3. å¸‚åœºç«äº‰**
- é£é™©ï¼šå¤§å‚æ¨å‡ºç±»ä¼¼äº§å“
- åº”å¯¹ï¼šå·®å¼‚åŒ–åŠŸèƒ½ã€ç”¨æˆ·ç²˜æ€§ã€å¿«é€Ÿè¿­ä»£
- é¢„æ¡ˆï¼šç»†åˆ†å¸‚åœºå®šä½

**4. ç”¨æˆ·è·å–æˆæœ¬**
- é£é™©ï¼šè·å®¢æˆæœ¬è¿‡é«˜
- åº”å¯¹ï¼šå£ç¢‘è¥é”€ã€åˆä½œæ¨å¹¿ã€å…è´¹è¯•ç”¨
- é¢„æ¡ˆï¼šè°ƒæ•´å•†ä¸šæ¨¡å¼

### 7.3 è¿è¥é£é™©

#### ä¸­é£é™©
**1. æœåŠ¡å¯ç”¨æ€§**
- é£é™©ï¼šæœåŠ¡ä¸­æ–­å½±å“ç”¨æˆ·ä½“éªŒ
- åº”å¯¹ï¼šå¤šåœ°éƒ¨ç½²ã€è‡ªåŠ¨æ•…éšœè½¬ç§»ã€ç›‘æ§å‘Šè­¦
- é¢„æ¡ˆï¼šç´§æ€¥æ¢å¤æµç¨‹

**2. å›¢é˜Ÿç¨³å®šæ€§**
- é£é™©ï¼šæ ¸å¿ƒå¼€å‘äººå‘˜ç¦»èŒ
- åº”å¯¹ï¼šçŸ¥è¯†æ–‡æ¡£åŒ–ã€ä»£ç è§„èŒƒã€å›¢é˜Ÿå»ºè®¾
- é¢„æ¡ˆï¼šå¤–åŒ…å’Œæ‹›è˜è®¡åˆ’

### 7.4 åº”æ€¥é¢„æ¡ˆ

**æŠ€æœ¯æ•…éšœåº”æ€¥**
1. å»ºç«‹24å°æ—¶ç›‘æ§å’Œå‘Šè­¦
2. åˆ¶å®šæ•…éšœç­‰çº§å’Œå“åº”æ—¶é—´
3. å‡†å¤‡å›æ»šå’Œé™çº§æ–¹æ¡ˆ
4. å®šæœŸè¿›è¡Œæ•…éšœæ¼”ç»ƒ

**æ•°æ®å®‰å…¨åº”æ€¥**
1. å®šæœŸæ•°æ®å¤‡ä»½å’Œæ¢å¤æµ‹è¯•
2. å»ºç«‹æ•°æ®æ³„éœ²å“åº”æµç¨‹
3. å‡†å¤‡æ³•å¾‹å’Œå…¬å…³åº”å¯¹
4. ç”¨æˆ·é€šçŸ¥å’Œè¡¥å¿æœºåˆ¶

**ä¸šåŠ¡è¿ç»­æ€§**
1. å¤šäº‘éƒ¨ç½²é¿å…å•ç‚¹æ•…éšœ
2. æ ¸å¿ƒåŠŸèƒ½ç¦»çº¿å¯ç”¨
3. åˆä½œä¼™ä¼´å¤‡é€‰æ–¹æ¡ˆ
4. èµ„é‡‘å‚¨å¤‡å’Œèèµ„è®¡åˆ’

## 8. æ€»ç»“

æœ¬å¼€å‘æ–¹æ¡ˆä¸ºä¸ªäººç…§ç‰‡ç›´æ’­åº”ç”¨æä¾›äº†å®Œæ•´çš„æŠ€æœ¯æ¶æ„å’Œå®æ–½è·¯å¾„ã€‚æ–¹æ¡ˆå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

### 8.1 æŠ€æœ¯ä¼˜åŠ¿
- **ç°ä»£åŒ–æŠ€æœ¯æ ˆ**ï¼šé‡‡ç”¨Node.jsã€Reactã€Flutterç­‰ä¸»æµæŠ€æœ¯
- **å¯æ‰©å±•æ¶æ„**ï¼šå¾®æœåŠ¡è®¾è®¡ï¼Œæ”¯æŒæ°´å¹³æ‰©å±•
- **æ€§èƒ½ä¼˜åŒ–**ï¼šå¤šçº§ç¼“å­˜ã€CDNã€å›¾ç‰‡å‹ç¼©ç­‰ä¼˜åŒ–ç­–ç•¥
- **å®‰å…¨å¯é **ï¼šè®¿é—®æ§åˆ¶ã€æ•°æ®åŠ å¯†ã€å¤‡ä»½æ¢å¤

### 8.2 åŠŸèƒ½å®Œæ•´æ€§
- **æ ¸å¿ƒåŠŸèƒ½é½å…¨**ï¼šæ‹æ‘„ã€ä¸Šä¼ ã€åˆ†äº«ã€æŸ¥çœ‹å®Œæ•´æµç¨‹
- **ç”¨æˆ·ä½“éªŒä¼˜ç§€**ï¼šå®æ—¶æ¨é€ã€æ–­ç‚¹ç»­ä¼ ã€å¤šç«¯é€‚é…
- **ç®¡ç†åŠŸèƒ½å¼ºå¤§**ï¼šæ ‡ç­¾åˆ†ç±»ã€å®¡æ ¸ç³»ç»Ÿã€æ•°æ®åˆ†æ
- **å•†ä¸šåŒ–å°±ç»ª**ï¼šç”¨æˆ·ç³»ç»Ÿã€è®¡è´¹æ¨¡å¼ã€APIå¼€æ”¾

### 8.3 å®æ–½å¯è¡Œæ€§
- **åˆ†é˜¶æ®µå¼€å‘**ï¼šMVPâ†’åŠŸèƒ½å¢å¼ºâ†’å•†ä¸šåŒ–ï¼Œé£é™©å¯æ§
- **æˆæœ¬åˆç†**ï¼šå¼€å‘å’Œè¿è¥æˆæœ¬åœ¨å¯æ¥å—èŒƒå›´
- **å›¢é˜Ÿè¦æ±‚æ˜ç¡®**ï¼šæŠ€èƒ½è¦æ±‚å’Œäººå‘˜é…ç½®æ¸…æ™°
- **é£é™©å¯æ§**ï¼šè¯†åˆ«ä¸»è¦é£é™©å¹¶åˆ¶å®šåº”å¯¹ç­–ç•¥

### 8.4 å¸‚åœºå‰æ™¯
- **éœ€æ±‚æ˜ç¡®**ï¼šæ‘„å½±å¸ˆå’Œæ´»åŠ¨ç»„ç»‡è€…æœ‰çœŸå®éœ€æ±‚
- **å·®å¼‚åŒ–æ˜æ˜¾**ï¼šä¸“æ³¨äºä¸“ä¸šæ‘„å½±åœºæ™¯
- **å•†ä¸šæ¨¡å¼æ¸…æ™°**ï¼šå¤šç§æ”¶è´¹æ¨¡å¼ï¼Œå¯æŒç»­å‘å±•
- **æ‰©å±•æ€§å¼º**ï¼šå¯æ‹“å±•åˆ°æ›´å¤šå‚ç›´é¢†åŸŸ

**å»ºè®®ç«‹å³å¯åŠ¨MVPå¼€å‘ï¼ŒéªŒè¯æ ¸å¿ƒåŠŸèƒ½å’Œå¸‚åœºéœ€æ±‚ï¼Œä¸ºåç»­åŠŸèƒ½è¿­ä»£å’Œå•†ä¸šåŒ–å¥ å®šåŸºç¡€ã€‚** fetch(`http://${ip}:8080/ccapi`, {
          timeout: 1000
        });

        if (response.ok) {
          const data = await response.json();
          if (data.manufacturer === 'Canon') {
            this.baseUrl = `http://${ip}:8080/ccapi`;
            return {
              ip: ip,
              model: data.productname,
              firmware: data.firmwareversion
            };
          }
        }
      } catch (error) {
        // å¿½ç•¥è¿æ¥é”™è¯¯ï¼Œç»§ç»­æ‰«æ
        continue;
      }
    }

    throw new Error('æœªæ‰¾åˆ°ä½³èƒ½ç›¸æœº');
  }

  // å»ºç«‹è¿æ¥
  async connect() {
    if (!this.baseUrl) {
      await this.discoverCamera();
    }

    try {
      // è·å–ç›¸å†ŒID
      const sessionResponse = await fetch(`${this.baseUrl}/ver100/session`, {
        method: 'POST'
      });

      if (sessionResponse.ok) {
        const sessionData = await sessionResponse.json();
        this.sessionId = sessionData.sessionid;
        this.isConnected = true;
        return true;
      }
    } catch (error) {
      throw new Error(`è¿æ¥ç›¸æœºå¤±è´¥: ${error.message}`);
    }

    return false;
  }

  // æ‹æ‘„ç…§ç‰‡
  async takePicture() {
    if (!this.isConnected) {
      throw new Error('ç›¸æœºæœªè¿æ¥');
    }

    try {
      // è§¦å‘æ‹æ‘„
      const shootResponse = await fetch(`${this.baseUrl}/ver100/shooting/control/shutterbutton`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          action: 'full_press'
        })
      });

      if (!shootResponse.ok) {
        throw new Error('æ‹æ‘„å¤±è´¥');
      }

      // ç­‰å¾…æ‹æ‘„å®Œæˆ
      await this.waitForCapture();

      // è·å–æœ€æ–°ç…§ç‰‡
      const photoInfo = await this.getLatestPhoto();
      return photoInfo;

    } catch (error) {
      throw new Error(`æ‹æ‘„å¤±è´¥: ${error.message}`);
    }
  }

  // ç­‰å¾…æ‹æ‘„å®Œæˆ
  async waitForCapture(maxWait = 10000) {
    const startTime = Date.now();

    while (Date.now() - startTime < maxWait) {
      try {
        const statusResponse = await fetch(`${this.baseUrl}/ver100/shooting/control/shutterbutton`);
        const statusData = await statusResponse.json();

        if (statusData.state === 'release') {
          return true;
        }

        await new Promise(resolve => setTimeout(resolve, 100));
      } catch (error) {
        // ç»§ç»­ç­‰å¾…
      }
    }

    throw new Error('æ‹æ‘„è¶…æ—¶');
  }

  // è·å–æœ€æ–°ç…§ç‰‡ä¿¡æ¯
  async getLatestPhoto() {
    try {
      const contentsResponse = await fetch(`${this.baseUrl}/ver100/contents/sd`);
      const contentsData = await contentsResponse.json();

      // è·å–æœ€æ–°çš„ç…§ç‰‡
      const latestPhoto = contentsData.contents[0];

      return {
        filename: latestPhoto.name,
        url: `${this.baseUrl}${latestPhoto.url}`,
        size: latestPhoto.size,
        datetime: latestPhoto.datetime
      };
    } catch (error) {
      throw new Error(`è·å–ç…§ç‰‡ä¿¡æ¯å¤±è´¥: ${error.message}`);
    }
  }

  // ä¸‹è½½ç…§ç‰‡
  async downloadPhoto(photoUrl) {
    try {
      const response = await request(app)
        .post('/api/sessions')
        .send(sessionData)
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.name).toBe(sessionData.name);
      expect(response.body.data.session_id).toBeDefined();
    });

    it('åº”è¯¥éªŒè¯å¿…å¡«å­—æ®µ', async () => {
      const response = await request(app)
        .post('/api/sessions')
        .send({})
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('name');
    });
  });

  describe('GET /api/sessions/:id', () => {
    it('åº”è¯¥è¿”å›ç›¸å†Œè¯¦æƒ…', async () => {
      const session = await db.sessions.create({
        name: 'æµ‹è¯•ç›¸å†Œ',
        description: 'æµ‹è¯•æè¿°'
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}`)
        .expect(200);

      expect(response.body.data.name).toBe(session.name);
    });

    it('åº”è¯¥è¿”å›404å½“ç›¸å†Œä¸å­˜åœ¨', async () => {
      const response = await request(app)
        .get('/api/sessions/nonexistent')
        .expect(404);

      expect(response.body.code).toBe(404);
    });
  });
});
```

```javascript
// tests/api/photo.test.js
const request = require('supertest');
const path = require('path');
const app = require('../../app');
const db = require('../../models');

describe('Photo API', () => {
  let session;

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
    
    session = await db.sessions.create({
      name: 'æµ‹è¯•ç›¸å†Œ',
      description: 'æµ‹è¯•æè¿°'
    });
  });

  describe('POST /api/sessions/:id/photos', () => {
    it('åº”è¯¥æˆåŠŸä¸Šä¼ ç…§ç‰‡', async () => {
      const testImagePath = path.join(__dirname, '../fixtures/test-image.jpg');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testImagePath)
        .field('tags', JSON.stringify(['æµ‹è¯•', 'æ ·ä¾‹']))
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.photo_id).toBeDefined();
      expect(response.body.data.urls).toBeDefined();
    });

    it('åº”è¯¥æ‹’ç»éå›¾ç‰‡æ–‡ä»¶', async () => {
      const testFilePath = path.join(__dirname, '../fixtures/test-file.txt');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testFilePath)
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('å›¾ç‰‡');
    });
  });

  describe('GET /api/sessions/:id/photos', () => {
    it('åº”è¯¥è¿”å›ç…§ç‰‡åˆ—è¡¨', async () => {
      // åˆ›å»ºæµ‹è¯•ç…§ç‰‡
      await db.photos.create({
        session_id: session.id,
        filename: 'test.jpg',
        urls: { thumbnail: 'thumb.jpg', original: 'orig.jpg' },
        tags: ['æµ‹è¯•']
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].filename).toBe('test.jpg');
    });

    it('åº”è¯¥æ”¯æŒæ ‡ç­¾è¿‡æ»¤', async () => {
      await db.photos.bulkCreate([
        {
          session_id: session.id,
          filename: 'test1.jpg',
          urls: {},
          tags: ['äººç‰©']
        },
        {
          session_id: session.id,
          filename: 'test2.jpg',
          urls: {},
          tags: ['é£æ™¯']
        }
      ]);

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos?tags=äººç‰©`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].tags).toContain('äººç‰©');
    });
  });
});
```

### 5.2 é›†æˆæµ‹è¯•

```javascript
// tests/integration/workflow.test.js
const request = require('supertest');
const app = require('../../app');
const db = require('../../models');
const WebSocket = require('ws');

describe('å®Œæ•´å·¥ä½œæµç¨‹æµ‹è¯•', () => {
  let session;
  let ws;

  beforeAll(async () => {
    // å¯åŠ¨WebSocketè¿æ¥
    ws = new WebSocket('ws://localhost:3000');
    await new Promise(resolve => ws.on('open', resolve));
  });

  afterAll(() => {
    ws.close();
  });

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
  });

  it('åº”è¯¥å®Œæˆå®Œæ•´çš„æ‹æ‘„åˆ†äº«æµç¨‹', async () => {
    // 1. åˆ›å»ºç›¸å†Œ
    const sessionResponse = await request(app)
      .post('/api/sessions')
      .send({
        name: 'å©šç¤¼æ‹æ‘„',
        description: 'å¼ ä¸‰æå››çš„å©šç¤¼',
        settings: {
          watermark: {
            enabled: true,
            text: 'å¼ ä¸‰â¤æå›› 2024.01.01'
          },
          access_protection: {
            enabled: true,
            access_code: '1234'
          }
        }
      })
      .expect(201);

    const sessionId = sessionResponse.body.data.session_id;

    // 2. åŠ å…¥ç›¸å†ŒWebSocketæˆ¿é—´
    ws.send(JSON.stringify({
      type: 'join_session',
      session_id: sessionId
    }));

    // 3. ä¸Šä¼ ç…§ç‰‡
    const uploadResponse = await request(app)
      .post(`/api/sessions/${sessionId}/photos`)
      .attach('photo', path.join(__dirname, '../fixtures/wedding.jpg'))
      .field('watermark_text', 'å¼ ä¸‰â¤æå›› 2024.01.01')
      .field('auto_tag', 'true')
      .expect(201);

    const photoId = uploadResponse.body.data.photo_id;

    // 4. éªŒè¯WebSocketæ¨é€
    const wsMessage = await new Promise(resolve => {
      ws.on('message', data => {
        const message = JSON.parse(data);
        if (message.type === 'new_photo') {
          resolve(message);
        }
      });
    });

    expect(wsMessage.data.photo_id).toBe(photoId);

    // 5. è®¿å®¢è®¿é—®ï¼ˆéœ€è¦è®¿é—®ç ï¼‰
    const guestResponse = await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=1234`)
      .expect(200);

    expect(guestResponse.body.data.photos).toHaveLength(1);

    // 6. é”™è¯¯è®¿é—®ç æµ‹è¯•
    await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=wrong`)
      .expect(403);
  });

  it('åº”è¯¥æ”¯æŒæ–­ç‚¹ç»­ä¼ ', async () => {
    const session = await db.sessions.create({
      name: 'æµ‹è¯•ç›¸å†Œ'
    });

    // 1. åˆå§‹åŒ–ä¸Šä¼ 
    const initResponse = await request(app)
      .post('/api/upload/init')
      .send({
        filename: 'large-photo.jpg',
        fileSize: 5 * 1024 * 1024, // 5MB
        chunkSize: 1024 * 1024 // 1MB
      })
      .expect(200);

    const uploadId = initResponse.body.data.uploadId;

    // 2. ä¸Šä¼ åˆ†ç‰‡
    const chunk1 = Buffer.alloc(1024 * 1024, 'a');
    await request(app)
      .post(`/api/upload/chunk/${uploadId}/0`)
      .send(chunk1)
      .expect(200);

    // 3. æ£€æŸ¥ä¸Šä¼ çŠ¶æ€
    const statusResponse = await request(app)
      .get(`/api/upload/status/${uploadId}`)
      .expect(200);

    expect(statusResponse.body.data.uploaded).toBe(1);
    expect(statusResponse.body.data.total).toBe(5);
  });
});
```

### 5.3 æ€§èƒ½æµ‹è¯•

```javascript
// tests/performance/load.test.js
const autocannon = require('autocannon');
const app = require('../../app');

describe('æ€§èƒ½æµ‹è¯•', () => {
  let server;

  beforeAll(() => {
    server = app.listen(0);
  });

  afterAll(() => {
    server.close();
  });

  it('APIå¹¶å‘æ€§èƒ½æµ‹è¯•', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions`,
      method: 'GET',
      connections: 100,
      duration: 10,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    expect(result.errors).toBe(0);
    expect(result.requests.average).toBeGreaterThan(100); // å¹³å‡æ¯ç§’100+è¯·æ±‚
  });

  it('å›¾ç‰‡ä¸Šä¼ æ€§èƒ½æµ‹è¯•', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions/test/photos`,
      method: 'POST',
      connections: 10,
      duration: 30,
      setupClient: (client) => {
        // æ¨¡æ‹Ÿæ–‡ä»¶ä¸Šä¼ 
        client.setBody(Buffer.alloc(1024 * 100, 'test')); // 100KBæµ‹è¯•æ–‡ä»¶
        client.setHeaders({
          'Content-Type': 'multipart/form-data'
        });
      }
    });

    expect(result.errors).toBe(0);
    expect(result.latency.p99).toBeLessThan(5000); // 99%è¯·æ±‚åœ¨5ç§’å†…å®Œæˆ
  });
});
```

## 6. é¡¹ç›®è§„åˆ’

### 6.1 å¼€å‘é˜¶æ®µ

#### ç¬¬ä¸€é˜¶æ®µï¼šMVPç‰ˆæœ¬ï¼ˆ4-6å‘¨ï¼‰

**æ ¸å¿ƒåŠŸèƒ½**
- åŸºç¡€ç›¸å†Œç®¡ç†ï¼ˆåˆ›å»ºã€æŸ¥çœ‹ï¼‰
- ç…§ç‰‡ä¸Šä¼ å’Œå±•ç¤º
- ç®€å•çš„å®æ—¶æ¨é€
- åŸºç¡€çš„Webç«¯æŸ¥çœ‹ç•Œé¢
- ç§»åŠ¨ç«¯æ‹æ‘„åº”ç”¨ï¼ˆåŸºç¡€ç‰ˆï¼‰

**æŠ€æœ¯æ ˆ**
- åç«¯ï¼šNode.js + Express + PostgreSQL
- å‰ç«¯ï¼šNext.js + React
- ç§»åŠ¨ç«¯ï¼šFlutter
- å®æ—¶é€šä¿¡ï¼šSocket.IO
- æ–‡ä»¶å­˜å‚¨ï¼šæœ¬åœ°å­˜å‚¨

**é‡Œç¨‹ç¢‘**
- Week 1-2: åç«¯APIåŸºç¡€æ¶æ„
- Week 3-4: å‰ç«¯ç•Œé¢å¼€å‘
- Week 5-6: ç§»åŠ¨ç«¯åº”ç”¨å¼€å‘å’Œé›†æˆæµ‹è¯•

#### ç¬¬äºŒé˜¶æ®µï¼šåŠŸèƒ½å¢å¼ºï¼ˆ6-8å‘¨ï¼‰

**æ–°å¢åŠŸèƒ½**
- è®¿é—®ç ä¿æŠ¤
- å›¾ç‰‡æ°´å°
- å¤šåˆ†è¾¨ç‡æ”¯æŒ
- åŸºç¡€æ ‡ç­¾ç³»ç»Ÿ
- äº‘å­˜å‚¨é›†æˆï¼ˆé˜¿é‡Œäº‘OSSï¼‰
- æ€§èƒ½ä¼˜åŒ–

**æŠ€æœ¯å‡çº§**
- Redisç¼“å­˜
- å›¾ç‰‡å¤„ç†é˜Ÿåˆ—
- CDNé›†æˆ
- ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ

**é‡Œç¨‹ç¢‘**
- Week 1-2: å®‰å…¨åŠŸèƒ½å’Œè®¿é—®æ§åˆ¶
- Week 3-4: å›¾ç‰‡å¤„ç†å’Œå­˜å‚¨ä¼˜åŒ–
- Week 5-6: æ ‡ç­¾ç³»ç»Ÿå’Œæœç´¢åŠŸèƒ½
- Week 7-8: æ€§èƒ½ä¼˜åŒ–å’Œç›‘æ§

#### ç¬¬ä¸‰é˜¶æ®µï¼šé«˜çº§åŠŸèƒ½ï¼ˆ8-10å‘¨ï¼‰

**é«˜çº§åŠŸèƒ½**
- AIè‡ªåŠ¨æ ‡ç­¾
- ç…§ç‰‡å®¡æ ¸ç³»ç»Ÿ
- æ–­ç‚¹ç»­ä¼ 
- å¤šè¯­è¨€æ”¯æŒ
- é«˜çº§æ°´å°å®šåˆ¶
- æ‰¹é‡æ“ä½œ

**å•†ä¸šåŒ–åŠŸèƒ½**
- ç”¨æˆ·ç³»ç»Ÿå’Œæƒé™ç®¡ç†
- å¥—é¤å’Œè®¡è´¹
- æ•°æ®åˆ†æå’ŒæŠ¥è¡¨
- APIå¼€æ”¾å¹³å°

**é‡Œç¨‹ç¢‘**
- Week 1-3: AIåŠŸèƒ½é›†æˆ
- Week 4-6: å®¡æ ¸å’Œç®¡ç†ç³»ç»Ÿ
- Week 7-8: å•†ä¸šåŒ–åŠŸèƒ½
- Week 9-10: æµ‹è¯•å’Œä¸Šçº¿å‡†å¤‡

### 6.2 å›¢é˜Ÿé…ç½®

**æ ¸å¿ƒå›¢é˜Ÿï¼ˆ5-7äººï¼‰**
- é¡¹ç›®ç»ç† Ã— 1
- åç«¯å¼€å‘ Ã— 2
- å‰ç«¯å¼€å‘ Ã— 1
- ç§»åŠ¨ç«¯å¼€å‘ Ã— 1
- UI/UXè®¾è®¡å¸ˆ Ã— 1
- æµ‹è¯•å·¥ç¨‹å¸ˆ Ã— 1

**æŠ€èƒ½è¦æ±‚**
- åç«¯ï¼šNode.jsã€æ•°æ®åº“è®¾è®¡ã€äº‘æœåŠ¡ã€æ€§èƒ½ä¼˜åŒ–
- å‰ç«¯ï¼šReactã€Next.jsã€å“åº”å¼è®¾è®¡
- ç§»åŠ¨ç«¯ï¼šFlutterã€ç›¸æœºAPIã€æ–‡ä»¶ä¸Šä¼ 
- è®¾è®¡ï¼šUIè®¾è®¡ã€ç”¨æˆ·ä½“éªŒã€åŸå‹è®¾è®¡
- æµ‹è¯•ï¼šè‡ªåŠ¨åŒ–æµ‹è¯•ã€æ€§èƒ½æµ‹è¯•ã€å®‰å…¨æµ‹è¯•

### 6.3 æˆæœ¬ä¼°ç®—

#### å¼€å‘æˆæœ¬
- äººåŠ›æˆæœ¬ï¼š50-70ä¸‡ï¼ˆ6ä¸ªæœˆï¼‰
- è®¾å¤‡å’Œå·¥å…·ï¼š5-10ä¸‡
- ç¬¬ä¸‰æ–¹æœåŠ¡ï¼š2-5ä¸‡
- **æ€»è®¡ï¼š57-85ä¸‡**

#### è¿è¥æˆæœ¬ï¼ˆæœˆï¼‰
- æœåŠ¡å™¨ï¼š5,000-15,000å…ƒ
- äº‘å­˜å‚¨ï¼š2,000-8,000å…ƒ
- CDNï¼š1,000-5,000å…ƒ
- ç›‘æ§å’Œå®‰å…¨ï¼š1,000-3,000å…ƒ
- **æœˆè¿è¥æˆæœ¬ï¼š9,000-31,000å…ƒ**

#### æ”¶å…¥æ¨¡å¼
- åŸºç¡€ç‰ˆï¼šå…è´¹ï¼ˆé™åˆ¶åŠŸèƒ½ï¼‰
- ä¸“ä¸šç‰ˆï¼š299å…ƒ/æœˆï¼ˆå®Œæ•´åŠŸèƒ½ï¼‰
- ä¼ä¸šç‰ˆï¼š999å…ƒ/æœˆï¼ˆå®šåˆ¶æœåŠ¡ï¼‰
- æŒ‰éœ€æœåŠ¡ï¼š1-5å…ƒ/GBå­˜å‚¨

## 7. é£é™©è¯„ä¼°ä¸åº”å¯¹

### 7.1 æŠ€æœ¯é£é™©

#### é«˜é£é™©
**1. å¤§æ–‡ä»¶ä¸Šä¼ ç¨³å®šæ€§**
- é£é™©ï¼šç½‘ç»œä¸ç¨³å®šå¯¼è‡´ä¸Šä¼ å¤±è´¥
- åº”å¯¹ï¼šæ–­ç‚¹ç»­ä¼ ã€é‡è¯•æœºåˆ¶ã€è¿›åº¦ä¿å­˜
- é¢„æ¡ˆï¼šæœ¬åœ°ç¼“å­˜ã€ç¦»çº¿ä¸Šä¼ é˜Ÿåˆ—

**2. å®æ—¶æ€§èƒ½ç“¶é¢ˆ**
- é£é™©ï¼šé«˜å¹¶å‘æ—¶WebSocketè¿æ¥æ•°è¿‡å¤š
- åº”å¯¹ï¼šè¿æ¥æ± ç®¡ç†ã€è´Ÿè½½å‡è¡¡ã€Redisé›†ç¾¤
- é¢„æ¡ˆï¼šé™çº§ä¸ºè½®è¯¢æ¨¡å¼

#### ä¸­é£é™©
**3. å›¾ç‰‡å¤„ç†æ€§èƒ½**
- é£é™©ï¼šå¤§é‡å›¾ç‰‡åŒæ—¶å¤„ç†å¯¼è‡´æœåŠ¡å™¨å‹åŠ›
- åº”å¯¹ï¼šå¼‚æ­¥é˜Ÿåˆ—ã€åˆ†å¸ƒå¼å¤„ç†ã€ç¼“å­˜ç­–ç•¥
- é¢„æ¡ˆï¼šå¤–éƒ¨å›¾ç‰‡å¤„ç†æœåŠ¡

**4. å­˜å‚¨æˆæœ¬æ§åˆ¶**
- é£é™©ï¼šå­˜å‚¨è´¹ç”¨å¿«é€Ÿå¢é•¿
- åº”å¯¹ï¼šæ™ºèƒ½å‹ç¼©ã€å®šæœŸæ¸…ç†ã€åˆ†å±‚å­˜å‚¨
- é¢„æ¡ˆï¼šç”¨æˆ·ä»˜è´¹å­˜å‚¨æ¨¡å¼

### 7.2 ä¸šåŠ¡é£é™©

#### é«˜é£é™©
**1. ç”¨æˆ·éšç§å’Œæ•°æ®å®‰å…¨**
- é£é™©ï¼šç…§ç‰‡æ³„éœ²ã€æ•°æ®è¢«ç›—
- åº”å¯¹ï¼šåŠ å¯†å­˜å‚¨ã€è®¿é—®æ§åˆ¶ã€å®‰å…¨å®¡è®¡
- é¢„æ¡ˆï¼šä¿é™©å’Œæ³•å¾‹ä¿æŠ¤

**2. ç‰ˆæƒå’Œæ³•å¾‹é—®é¢˜**
- é£é™©ï¼šç”¨æˆ·ä¸Šä¼ ä¾µæƒå†…å®¹
- åº”å¯¹ï¼šå†…å®¹å®¡æ ¸ã€ç”¨æˆ·åè®®ã€ä¸¾æŠ¥æœºåˆ¶
- é¢„æ¡ˆï¼šå¿«é€Ÿåˆ é™¤å’Œæ³•å¾‹æ”¯æŒ

#### ä¸­é£é™©
**3. å¸‚åœºç«äº‰**
- é£é™©ï¼šå¤§å‚æ¨å‡ºç±»ä¼¼äº§å“
- åº”å¯¹ï¼šå·®å¼‚åŒ–åŠŸèƒ½ã€ç”¨æˆ·ç²˜æ€§ã€å¿«é€Ÿè¿­ä»£
- é¢„æ¡ˆï¼šç»†åˆ†å¸‚åœºå®šä½

**4. ç”¨æˆ·è·å–æˆæœ¬**
- é£é™©ï¼šè·å®¢æˆæœ¬è¿‡é«˜
- åº”å¯¹ï¼šå£ç¢‘è¥é”€ã€åˆä½œæ¨å¹¿ã€å…è´¹è¯•ç”¨
- é¢„æ¡ˆï¼šè°ƒæ•´å•†ä¸šæ¨¡å¼

### 7.3 è¿è¥é£é™©

#### ä¸­é£é™©
**1. æœåŠ¡å¯ç”¨æ€§**
- é£é™©ï¼šæœåŠ¡ä¸­æ–­å½±å“ç”¨æˆ·ä½“éªŒ
- åº”å¯¹ï¼šå¤šåœ°éƒ¨ç½²ã€è‡ªåŠ¨æ•…éšœè½¬ç§»ã€ç›‘æ§å‘Šè­¦
- é¢„æ¡ˆï¼šç´§æ€¥æ¢å¤æµç¨‹

**2. å›¢é˜Ÿç¨³å®šæ€§**
- é£é™©ï¼šæ ¸å¿ƒå¼€å‘äººå‘˜ç¦»èŒ
- åº”å¯¹ï¼šçŸ¥è¯†æ–‡æ¡£åŒ–ã€ä»£ç è§„èŒƒã€å›¢é˜Ÿå»ºè®¾
- é¢„æ¡ˆï¼šå¤–åŒ…å’Œæ‹›è˜è®¡åˆ’

### 7.4 åº”æ€¥é¢„æ¡ˆ

**æŠ€æœ¯æ•…éšœåº”æ€¥**
1. å»ºç«‹24å°æ—¶ç›‘æ§å’Œå‘Šè­¦
2. åˆ¶å®šæ•…éšœç­‰çº§å’Œå“åº”æ—¶é—´
3. å‡†å¤‡å›æ»šå’Œé™çº§æ–¹æ¡ˆ
4. å®šæœŸè¿›è¡Œæ•…éšœæ¼”ç»ƒ

**æ•°æ®å®‰å…¨åº”æ€¥**
1. å®šæœŸæ•°æ®å¤‡ä»½å’Œæ¢å¤æµ‹è¯•
2. å»ºç«‹æ•°æ®æ³„éœ²å“åº”æµç¨‹
3. å‡†å¤‡æ³•å¾‹å’Œå…¬å…³åº”å¯¹
4. ç”¨æˆ·é€šçŸ¥å’Œè¡¥å¿æœºåˆ¶

**ä¸šåŠ¡è¿ç»­æ€§**
1. å¤šäº‘éƒ¨ç½²é¿å…å•ç‚¹æ•…éšœ
2. æ ¸å¿ƒåŠŸèƒ½ç¦»çº¿å¯ç”¨
3. åˆä½œä¼™ä¼´å¤‡é€‰æ–¹æ¡ˆ
4. èµ„é‡‘å‚¨å¤‡å’Œèèµ„è®¡åˆ’

## 8. æ€»ç»“

æœ¬å¼€å‘æ–¹æ¡ˆä¸ºä¸ªäººç…§ç‰‡ç›´æ’­åº”ç”¨æä¾›äº†å®Œæ•´çš„æŠ€æœ¯æ¶æ„å’Œå®æ–½è·¯å¾„ã€‚æ–¹æ¡ˆå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

### 8.1 æŠ€æœ¯ä¼˜åŠ¿
- **ç°ä»£åŒ–æŠ€æœ¯æ ˆ**ï¼šé‡‡ç”¨Node.jsã€Reactã€Flutterç­‰ä¸»æµæŠ€æœ¯
- **å¯æ‰©å±•æ¶æ„**ï¼šå¾®æœåŠ¡è®¾è®¡ï¼Œæ”¯æŒæ°´å¹³æ‰©å±•
- **æ€§èƒ½ä¼˜åŒ–**ï¼šå¤šçº§ç¼“å­˜ã€CDNã€å›¾ç‰‡å‹ç¼©ç­‰ä¼˜åŒ–ç­–ç•¥
- **å®‰å…¨å¯é **ï¼šè®¿é—®æ§åˆ¶ã€æ•°æ®åŠ å¯†ã€å¤‡ä»½æ¢å¤

### 8.2 åŠŸèƒ½å®Œæ•´æ€§
- **æ ¸å¿ƒåŠŸèƒ½é½å…¨**ï¼šæ‹æ‘„ã€ä¸Šä¼ ã€åˆ†äº«ã€æŸ¥çœ‹å®Œæ•´æµç¨‹
- **ç”¨æˆ·ä½“éªŒä¼˜ç§€**ï¼šå®æ—¶æ¨é€ã€æ–­ç‚¹ç»­ä¼ ã€å¤šç«¯é€‚é…
- **ç®¡ç†åŠŸèƒ½å¼ºå¤§**ï¼šæ ‡ç­¾åˆ†ç±»ã€å®¡æ ¸ç³»ç»Ÿã€æ•°æ®åˆ†æ
- **å•†ä¸šåŒ–å°±ç»ª**ï¼šç”¨æˆ·ç³»ç»Ÿã€è®¡è´¹æ¨¡å¼ã€APIå¼€æ”¾

### 8.3 å®æ–½å¯è¡Œæ€§
- **åˆ†é˜¶æ®µå¼€å‘**ï¼šMVPâ†’åŠŸèƒ½å¢å¼ºâ†’å•†ä¸šåŒ–ï¼Œé£é™©å¯æ§
- **æˆæœ¬åˆç†**ï¼šå¼€å‘å’Œè¿è¥æˆæœ¬åœ¨å¯æ¥å—èŒƒå›´
- **å›¢é˜Ÿè¦æ±‚æ˜ç¡®**ï¼šæŠ€èƒ½è¦æ±‚å’Œäººå‘˜é…ç½®æ¸…æ™°
- **é£é™©å¯æ§**ï¼šè¯†åˆ«ä¸»è¦é£é™©å¹¶åˆ¶å®šåº”å¯¹ç­–ç•¥

### 8.4 å¸‚åœºå‰æ™¯
- **éœ€æ±‚æ˜ç¡®**ï¼šæ‘„å½±å¸ˆå’Œæ´»åŠ¨ç»„ç»‡è€…æœ‰çœŸå®éœ€æ±‚
- **å·®å¼‚åŒ–æ˜æ˜¾**ï¼šä¸“æ³¨äºä¸“ä¸šæ‘„å½±åœºæ™¯
- **å•†ä¸šæ¨¡å¼æ¸…æ™°**ï¼šå¤šç§æ”¶è´¹æ¨¡å¼ï¼Œå¯æŒç»­å‘å±•
- **æ‰©å±•æ€§å¼º**ï¼šå¯æ‹“å±•åˆ°æ›´å¤šå‚ç›´é¢†åŸŸ

**å»ºè®®ç«‹å³å¯åŠ¨MVPå¼€å‘ï¼ŒéªŒè¯æ ¸å¿ƒåŠŸèƒ½å’Œå¸‚åœºéœ€æ±‚ï¼Œä¸ºåç»­åŠŸèƒ½è¿­ä»£å’Œå•†ä¸šåŒ–å¥ å®šåŸºç¡€ã€‚** fetch(photoUrl);
      if (response.ok) {
        return await response.arrayBuffer();
      } else {
        throw new Error('ä¸‹è½½å¤±è´¥');
      }
    } catch (error) {
      throw new Error(`ä¸‹è½½ç…§ç‰‡å¤±è´¥: ${error.message}`);
    }
  }

  // è·å–å®æ—¶é¢„è§ˆ
  async getLiveView() {
    if (!this.isConnected) return null;

    try {
      const response = await request(app)
        .post('/api/sessions')
        .send(sessionData)
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.name).toBe(sessionData.name);
      expect(response.body.data.session_id).toBeDefined();
    });

    it('åº”è¯¥éªŒè¯å¿…å¡«å­—æ®µ', async () => {
      const response = await request(app)
        .post('/api/sessions')
        .send({})
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('name');
    });
  });

  describe('GET /api/sessions/:id', () => {
    it('åº”è¯¥è¿”å›ç›¸å†Œè¯¦æƒ…', async () => {
      const session = await db.sessions.create({
        name: 'æµ‹è¯•ç›¸å†Œ',
        description: 'æµ‹è¯•æè¿°'
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}`)
        .expect(200);

      expect(response.body.data.name).toBe(session.name);
    });

    it('åº”è¯¥è¿”å›404å½“ç›¸å†Œä¸å­˜åœ¨', async () => {
      const response = await request(app)
        .get('/api/sessions/nonexistent')
        .expect(404);

      expect(response.body.code).toBe(404);
    });
  });
});
```

```javascript
// tests/api/photo.test.js
const request = require('supertest');
const path = require('path');
const app = require('../../app');
const db = require('../../models');

describe('Photo API', () => {
  let session;

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
    
    session = await db.sessions.create({
      name: 'æµ‹è¯•ç›¸å†Œ',
      description: 'æµ‹è¯•æè¿°'
    });
  });

  describe('POST /api/sessions/:id/photos', () => {
    it('åº”è¯¥æˆåŠŸä¸Šä¼ ç…§ç‰‡', async () => {
      const testImagePath = path.join(__dirname, '../fixtures/test-image.jpg');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testImagePath)
        .field('tags', JSON.stringify(['æµ‹è¯•', 'æ ·ä¾‹']))
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.photo_id).toBeDefined();
      expect(response.body.data.urls).toBeDefined();
    });

    it('åº”è¯¥æ‹’ç»éå›¾ç‰‡æ–‡ä»¶', async () => {
      const testFilePath = path.join(__dirname, '../fixtures/test-file.txt');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testFilePath)
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('å›¾ç‰‡');
    });
  });

  describe('GET /api/sessions/:id/photos', () => {
    it('åº”è¯¥è¿”å›ç…§ç‰‡åˆ—è¡¨', async () => {
      // åˆ›å»ºæµ‹è¯•ç…§ç‰‡
      await db.photos.create({
        session_id: session.id,
        filename: 'test.jpg',
        urls: { thumbnail: 'thumb.jpg', original: 'orig.jpg' },
        tags: ['æµ‹è¯•']
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].filename).toBe('test.jpg');
    });

    it('åº”è¯¥æ”¯æŒæ ‡ç­¾è¿‡æ»¤', async () => {
      await db.photos.bulkCreate([
        {
          session_id: session.id,
          filename: 'test1.jpg',
          urls: {},
          tags: ['äººç‰©']
        },
        {
          session_id: session.id,
          filename: 'test2.jpg',
          urls: {},
          tags: ['é£æ™¯']
        }
      ]);

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos?tags=äººç‰©`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].tags).toContain('äººç‰©');
    });
  });
});
```

### 5.2 é›†æˆæµ‹è¯•

```javascript
// tests/integration/workflow.test.js
const request = require('supertest');
const app = require('../../app');
const db = require('../../models');
const WebSocket = require('ws');

describe('å®Œæ•´å·¥ä½œæµç¨‹æµ‹è¯•', () => {
  let session;
  let ws;

  beforeAll(async () => {
    // å¯åŠ¨WebSocketè¿æ¥
    ws = new WebSocket('ws://localhost:3000');
    await new Promise(resolve => ws.on('open', resolve));
  });

  afterAll(() => {
    ws.close();
  });

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
  });

  it('åº”è¯¥å®Œæˆå®Œæ•´çš„æ‹æ‘„åˆ†äº«æµç¨‹', async () => {
    // 1. åˆ›å»ºç›¸å†Œ
    const sessionResponse = await request(app)
      .post('/api/sessions')
      .send({
        name: 'å©šç¤¼æ‹æ‘„',
        description: 'å¼ ä¸‰æå››çš„å©šç¤¼',
        settings: {
          watermark: {
            enabled: true,
            text: 'å¼ ä¸‰â¤æå›› 2024.01.01'
          },
          access_protection: {
            enabled: true,
            access_code: '1234'
          }
        }
      })
      .expect(201);

    const sessionId = sessionResponse.body.data.session_id;

    // 2. åŠ å…¥ç›¸å†ŒWebSocketæˆ¿é—´
    ws.send(JSON.stringify({
      type: 'join_session',
      session_id: sessionId
    }));

    // 3. ä¸Šä¼ ç…§ç‰‡
    const uploadResponse = await request(app)
      .post(`/api/sessions/${sessionId}/photos`)
      .attach('photo', path.join(__dirname, '../fixtures/wedding.jpg'))
      .field('watermark_text', 'å¼ ä¸‰â¤æå›› 2024.01.01')
      .field('auto_tag', 'true')
      .expect(201);

    const photoId = uploadResponse.body.data.photo_id;

    // 4. éªŒè¯WebSocketæ¨é€
    const wsMessage = await new Promise(resolve => {
      ws.on('message', data => {
        const message = JSON.parse(data);
        if (message.type === 'new_photo') {
          resolve(message);
        }
      });
    });

    expect(wsMessage.data.photo_id).toBe(photoId);

    // 5. è®¿å®¢è®¿é—®ï¼ˆéœ€è¦è®¿é—®ç ï¼‰
    const guestResponse = await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=1234`)
      .expect(200);

    expect(guestResponse.body.data.photos).toHaveLength(1);

    // 6. é”™è¯¯è®¿é—®ç æµ‹è¯•
    await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=wrong`)
      .expect(403);
  });

  it('åº”è¯¥æ”¯æŒæ–­ç‚¹ç»­ä¼ ', async () => {
    const session = await db.sessions.create({
      name: 'æµ‹è¯•ç›¸å†Œ'
    });

    // 1. åˆå§‹åŒ–ä¸Šä¼ 
    const initResponse = await request(app)
      .post('/api/upload/init')
      .send({
        filename: 'large-photo.jpg',
        fileSize: 5 * 1024 * 1024, // 5MB
        chunkSize: 1024 * 1024 // 1MB
      })
      .expect(200);

    const uploadId = initResponse.body.data.uploadId;

    // 2. ä¸Šä¼ åˆ†ç‰‡
    const chunk1 = Buffer.alloc(1024 * 1024, 'a');
    await request(app)
      .post(`/api/upload/chunk/${uploadId}/0`)
      .send(chunk1)
      .expect(200);

    // 3. æ£€æŸ¥ä¸Šä¼ çŠ¶æ€
    const statusResponse = await request(app)
      .get(`/api/upload/status/${uploadId}`)
      .expect(200);

    expect(statusResponse.body.data.uploaded).toBe(1);
    expect(statusResponse.body.data.total).toBe(5);
  });
});
```

### 5.3 æ€§èƒ½æµ‹è¯•

```javascript
// tests/performance/load.test.js
const autocannon = require('autocannon');
const app = require('../../app');

describe('æ€§èƒ½æµ‹è¯•', () => {
  let server;

  beforeAll(() => {
    server = app.listen(0);
  });

  afterAll(() => {
    server.close();
  });

  it('APIå¹¶å‘æ€§èƒ½æµ‹è¯•', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions`,
      method: 'GET',
      connections: 100,
      duration: 10,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    expect(result.errors).toBe(0);
    expect(result.requests.average).toBeGreaterThan(100); // å¹³å‡æ¯ç§’100+è¯·æ±‚
  });

  it('å›¾ç‰‡ä¸Šä¼ æ€§èƒ½æµ‹è¯•', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions/test/photos`,
      method: 'POST',
      connections: 10,
      duration: 30,
      setupClient: (client) => {
        // æ¨¡æ‹Ÿæ–‡ä»¶ä¸Šä¼ 
        client.setBody(Buffer.alloc(1024 * 100, 'test')); // 100KBæµ‹è¯•æ–‡ä»¶
        client.setHeaders({
          'Content-Type': 'multipart/form-data'
        });
      }
    });

    expect(result.errors).toBe(0);
    expect(result.latency.p99).toBeLessThan(5000); // 99%è¯·æ±‚åœ¨5ç§’å†…å®Œæˆ
  });
});
```

## 6. é¡¹ç›®è§„åˆ’

### 6.1 å¼€å‘é˜¶æ®µ

#### ç¬¬ä¸€é˜¶æ®µï¼šMVPç‰ˆæœ¬ï¼ˆ4-6å‘¨ï¼‰

**æ ¸å¿ƒåŠŸèƒ½**
- åŸºç¡€ç›¸å†Œç®¡ç†ï¼ˆåˆ›å»ºã€æŸ¥çœ‹ï¼‰
- ç…§ç‰‡ä¸Šä¼ å’Œå±•ç¤º
- ç®€å•çš„å®æ—¶æ¨é€
- åŸºç¡€çš„Webç«¯æŸ¥çœ‹ç•Œé¢
- ç§»åŠ¨ç«¯æ‹æ‘„åº”ç”¨ï¼ˆåŸºç¡€ç‰ˆï¼‰

**æŠ€æœ¯æ ˆ**
- åç«¯ï¼šNode.js + Express + PostgreSQL
- å‰ç«¯ï¼šNext.js + React
- ç§»åŠ¨ç«¯ï¼šFlutter
- å®æ—¶é€šä¿¡ï¼šSocket.IO
- æ–‡ä»¶å­˜å‚¨ï¼šæœ¬åœ°å­˜å‚¨

**é‡Œç¨‹ç¢‘**
- Week 1-2: åç«¯APIåŸºç¡€æ¶æ„
- Week 3-4: å‰ç«¯ç•Œé¢å¼€å‘
- Week 5-6: ç§»åŠ¨ç«¯åº”ç”¨å¼€å‘å’Œé›†æˆæµ‹è¯•

#### ç¬¬äºŒé˜¶æ®µï¼šåŠŸèƒ½å¢å¼ºï¼ˆ6-8å‘¨ï¼‰

**æ–°å¢åŠŸèƒ½**
- è®¿é—®ç ä¿æŠ¤
- å›¾ç‰‡æ°´å°
- å¤šåˆ†è¾¨ç‡æ”¯æŒ
- åŸºç¡€æ ‡ç­¾ç³»ç»Ÿ
- äº‘å­˜å‚¨é›†æˆï¼ˆé˜¿é‡Œäº‘OSSï¼‰
- æ€§èƒ½ä¼˜åŒ–

**æŠ€æœ¯å‡çº§**
- Redisç¼“å­˜
- å›¾ç‰‡å¤„ç†é˜Ÿåˆ—
- CDNé›†æˆ
- ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ

**é‡Œç¨‹ç¢‘**
- Week 1-2: å®‰å…¨åŠŸèƒ½å’Œè®¿é—®æ§åˆ¶
- Week 3-4: å›¾ç‰‡å¤„ç†å’Œå­˜å‚¨ä¼˜åŒ–
- Week 5-6: æ ‡ç­¾ç³»ç»Ÿå’Œæœç´¢åŠŸèƒ½
- Week 7-8: æ€§èƒ½ä¼˜åŒ–å’Œç›‘æ§

#### ç¬¬ä¸‰é˜¶æ®µï¼šé«˜çº§åŠŸèƒ½ï¼ˆ8-10å‘¨ï¼‰

**é«˜çº§åŠŸèƒ½**
- AIè‡ªåŠ¨æ ‡ç­¾
- ç…§ç‰‡å®¡æ ¸ç³»ç»Ÿ
- æ–­ç‚¹ç»­ä¼ 
- å¤šè¯­è¨€æ”¯æŒ
- é«˜çº§æ°´å°å®šåˆ¶
- æ‰¹é‡æ“ä½œ

**å•†ä¸šåŒ–åŠŸèƒ½**
- ç”¨æˆ·ç³»ç»Ÿå’Œæƒé™ç®¡ç†
- å¥—é¤å’Œè®¡è´¹
- æ•°æ®åˆ†æå’ŒæŠ¥è¡¨
- APIå¼€æ”¾å¹³å°

**é‡Œç¨‹ç¢‘**
- Week 1-3: AIåŠŸèƒ½é›†æˆ
- Week 4-6: å®¡æ ¸å’Œç®¡ç†ç³»ç»Ÿ
- Week 7-8: å•†ä¸šåŒ–åŠŸèƒ½
- Week 9-10: æµ‹è¯•å’Œä¸Šçº¿å‡†å¤‡

### 6.2 å›¢é˜Ÿé…ç½®

**æ ¸å¿ƒå›¢é˜Ÿï¼ˆ5-7äººï¼‰**
- é¡¹ç›®ç»ç† Ã— 1
- åç«¯å¼€å‘ Ã— 2
- å‰ç«¯å¼€å‘ Ã— 1
- ç§»åŠ¨ç«¯å¼€å‘ Ã— 1
- UI/UXè®¾è®¡å¸ˆ Ã— 1
- æµ‹è¯•å·¥ç¨‹å¸ˆ Ã— 1

**æŠ€èƒ½è¦æ±‚**
- åç«¯ï¼šNode.jsã€æ•°æ®åº“è®¾è®¡ã€äº‘æœåŠ¡ã€æ€§èƒ½ä¼˜åŒ–
- å‰ç«¯ï¼šReactã€Next.jsã€å“åº”å¼è®¾è®¡
- ç§»åŠ¨ç«¯ï¼šFlutterã€ç›¸æœºAPIã€æ–‡ä»¶ä¸Šä¼ 
- è®¾è®¡ï¼šUIè®¾è®¡ã€ç”¨æˆ·ä½“éªŒã€åŸå‹è®¾è®¡
- æµ‹è¯•ï¼šè‡ªåŠ¨åŒ–æµ‹è¯•ã€æ€§èƒ½æµ‹è¯•ã€å®‰å…¨æµ‹è¯•

### 6.3 æˆæœ¬ä¼°ç®—

#### å¼€å‘æˆæœ¬
- äººåŠ›æˆæœ¬ï¼š50-70ä¸‡ï¼ˆ6ä¸ªæœˆï¼‰
- è®¾å¤‡å’Œå·¥å…·ï¼š5-10ä¸‡
- ç¬¬ä¸‰æ–¹æœåŠ¡ï¼š2-5ä¸‡
- **æ€»è®¡ï¼š57-85ä¸‡**

#### è¿è¥æˆæœ¬ï¼ˆæœˆï¼‰
- æœåŠ¡å™¨ï¼š5,000-15,000å…ƒ
- äº‘å­˜å‚¨ï¼š2,000-8,000å…ƒ
- CDNï¼š1,000-5,000å…ƒ
- ç›‘æ§å’Œå®‰å…¨ï¼š1,000-3,000å…ƒ
- **æœˆè¿è¥æˆæœ¬ï¼š9,000-31,000å…ƒ**

#### æ”¶å…¥æ¨¡å¼
- åŸºç¡€ç‰ˆï¼šå…è´¹ï¼ˆé™åˆ¶åŠŸèƒ½ï¼‰
- ä¸“ä¸šç‰ˆï¼š299å…ƒ/æœˆï¼ˆå®Œæ•´åŠŸèƒ½ï¼‰
- ä¼ä¸šç‰ˆï¼š999å…ƒ/æœˆï¼ˆå®šåˆ¶æœåŠ¡ï¼‰
- æŒ‰éœ€æœåŠ¡ï¼š1-5å…ƒ/GBå­˜å‚¨

## 7. é£é™©è¯„ä¼°ä¸åº”å¯¹

### 7.1 æŠ€æœ¯é£é™©

#### é«˜é£é™©
**1. å¤§æ–‡ä»¶ä¸Šä¼ ç¨³å®šæ€§**
- é£é™©ï¼šç½‘ç»œä¸ç¨³å®šå¯¼è‡´ä¸Šä¼ å¤±è´¥
- åº”å¯¹ï¼šæ–­ç‚¹ç»­ä¼ ã€é‡è¯•æœºåˆ¶ã€è¿›åº¦ä¿å­˜
- é¢„æ¡ˆï¼šæœ¬åœ°ç¼“å­˜ã€ç¦»çº¿ä¸Šä¼ é˜Ÿåˆ—

**2. å®æ—¶æ€§èƒ½ç“¶é¢ˆ**
- é£é™©ï¼šé«˜å¹¶å‘æ—¶WebSocketè¿æ¥æ•°è¿‡å¤š
- åº”å¯¹ï¼šè¿æ¥æ± ç®¡ç†ã€è´Ÿè½½å‡è¡¡ã€Redisé›†ç¾¤
- é¢„æ¡ˆï¼šé™çº§ä¸ºè½®è¯¢æ¨¡å¼

#### ä¸­é£é™©
**3. å›¾ç‰‡å¤„ç†æ€§èƒ½**
- é£é™©ï¼šå¤§é‡å›¾ç‰‡åŒæ—¶å¤„ç†å¯¼è‡´æœåŠ¡å™¨å‹åŠ›
- åº”å¯¹ï¼šå¼‚æ­¥é˜Ÿåˆ—ã€åˆ†å¸ƒå¼å¤„ç†ã€ç¼“å­˜ç­–ç•¥
- é¢„æ¡ˆï¼šå¤–éƒ¨å›¾ç‰‡å¤„ç†æœåŠ¡

**4. å­˜å‚¨æˆæœ¬æ§åˆ¶**
- é£é™©ï¼šå­˜å‚¨è´¹ç”¨å¿«é€Ÿå¢é•¿
- åº”å¯¹ï¼šæ™ºèƒ½å‹ç¼©ã€å®šæœŸæ¸…ç†ã€åˆ†å±‚å­˜å‚¨
- é¢„æ¡ˆï¼šç”¨æˆ·ä»˜è´¹å­˜å‚¨æ¨¡å¼

### 7.2 ä¸šåŠ¡é£é™©

#### é«˜é£é™©
**1. ç”¨æˆ·éšç§å’Œæ•°æ®å®‰å…¨**
- é£é™©ï¼šç…§ç‰‡æ³„éœ²ã€æ•°æ®è¢«ç›—
- åº”å¯¹ï¼šåŠ å¯†å­˜å‚¨ã€è®¿é—®æ§åˆ¶ã€å®‰å…¨å®¡è®¡
- é¢„æ¡ˆï¼šä¿é™©å’Œæ³•å¾‹ä¿æŠ¤

**2. ç‰ˆæƒå’Œæ³•å¾‹é—®é¢˜**
- é£é™©ï¼šç”¨æˆ·ä¸Šä¼ ä¾µæƒå†…å®¹
- åº”å¯¹ï¼šå†…å®¹å®¡æ ¸ã€ç”¨æˆ·åè®®ã€ä¸¾æŠ¥æœºåˆ¶
- é¢„æ¡ˆï¼šå¿«é€Ÿåˆ é™¤å’Œæ³•å¾‹æ”¯æŒ

#### ä¸­é£é™©
**3. å¸‚åœºç«äº‰**
- é£é™©ï¼šå¤§å‚æ¨å‡ºç±»ä¼¼äº§å“
- åº”å¯¹ï¼šå·®å¼‚åŒ–åŠŸèƒ½ã€ç”¨æˆ·ç²˜æ€§ã€å¿«é€Ÿè¿­ä»£
- é¢„æ¡ˆï¼šç»†åˆ†å¸‚åœºå®šä½

**4. ç”¨æˆ·è·å–æˆæœ¬**
- é£é™©ï¼šè·å®¢æˆæœ¬è¿‡é«˜
- åº”å¯¹ï¼šå£ç¢‘è¥é”€ã€åˆä½œæ¨å¹¿ã€å…è´¹è¯•ç”¨
- é¢„æ¡ˆï¼šè°ƒæ•´å•†ä¸šæ¨¡å¼

### 7.3 è¿è¥é£é™©

#### ä¸­é£é™©
**1. æœåŠ¡å¯ç”¨æ€§**
- é£é™©ï¼šæœåŠ¡ä¸­æ–­å½±å“ç”¨æˆ·ä½“éªŒ
- åº”å¯¹ï¼šå¤šåœ°éƒ¨ç½²ã€è‡ªåŠ¨æ•…éšœè½¬ç§»ã€ç›‘æ§å‘Šè­¦
- é¢„æ¡ˆï¼šç´§æ€¥æ¢å¤æµç¨‹

**2. å›¢é˜Ÿç¨³å®šæ€§**
- é£é™©ï¼šæ ¸å¿ƒå¼€å‘äººå‘˜ç¦»èŒ
- åº”å¯¹ï¼šçŸ¥è¯†æ–‡æ¡£åŒ–ã€ä»£ç è§„èŒƒã€å›¢é˜Ÿå»ºè®¾
- é¢„æ¡ˆï¼šå¤–åŒ…å’Œæ‹›è˜è®¡åˆ’

### 7.4 åº”æ€¥é¢„æ¡ˆ

**æŠ€æœ¯æ•…éšœåº”æ€¥**
1. å»ºç«‹24å°æ—¶ç›‘æ§å’Œå‘Šè­¦
2. åˆ¶å®šæ•…éšœç­‰çº§å’Œå“åº”æ—¶é—´
3. å‡†å¤‡å›æ»šå’Œé™çº§æ–¹æ¡ˆ
4. å®šæœŸè¿›è¡Œæ•…éšœæ¼”ç»ƒ

**æ•°æ®å®‰å…¨åº”æ€¥**
1. å®šæœŸæ•°æ®å¤‡ä»½å’Œæ¢å¤æµ‹è¯•
2. å»ºç«‹æ•°æ®æ³„éœ²å“åº”æµç¨‹
3. å‡†å¤‡æ³•å¾‹å’Œå…¬å…³åº”å¯¹
4. ç”¨æˆ·é€šçŸ¥å’Œè¡¥å¿æœºåˆ¶

**ä¸šåŠ¡è¿ç»­æ€§**
1. å¤šäº‘éƒ¨ç½²é¿å…å•ç‚¹æ•…éšœ
2. æ ¸å¿ƒåŠŸèƒ½ç¦»çº¿å¯ç”¨
3. åˆä½œä¼™ä¼´å¤‡é€‰æ–¹æ¡ˆ
4. èµ„é‡‘å‚¨å¤‡å’Œèèµ„è®¡åˆ’

## 8. æ€»ç»“

æœ¬å¼€å‘æ–¹æ¡ˆä¸ºä¸ªäººç…§ç‰‡ç›´æ’­åº”ç”¨æä¾›äº†å®Œæ•´çš„æŠ€æœ¯æ¶æ„å’Œå®æ–½è·¯å¾„ã€‚æ–¹æ¡ˆå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

### 8.1 æŠ€æœ¯ä¼˜åŠ¿
- **ç°ä»£åŒ–æŠ€æœ¯æ ˆ**ï¼šé‡‡ç”¨Node.jsã€Reactã€Flutterç­‰ä¸»æµæŠ€æœ¯
- **å¯æ‰©å±•æ¶æ„**ï¼šå¾®æœåŠ¡è®¾è®¡ï¼Œæ”¯æŒæ°´å¹³æ‰©å±•
- **æ€§èƒ½ä¼˜åŒ–**ï¼šå¤šçº§ç¼“å­˜ã€CDNã€å›¾ç‰‡å‹ç¼©ç­‰ä¼˜åŒ–ç­–ç•¥
- **å®‰å…¨å¯é **ï¼šè®¿é—®æ§åˆ¶ã€æ•°æ®åŠ å¯†ã€å¤‡ä»½æ¢å¤

### 8.2 åŠŸèƒ½å®Œæ•´æ€§
- **æ ¸å¿ƒåŠŸèƒ½é½å…¨**ï¼šæ‹æ‘„ã€ä¸Šä¼ ã€åˆ†äº«ã€æŸ¥çœ‹å®Œæ•´æµç¨‹
- **ç”¨æˆ·ä½“éªŒä¼˜ç§€**ï¼šå®æ—¶æ¨é€ã€æ–­ç‚¹ç»­ä¼ ã€å¤šç«¯é€‚é…
- **ç®¡ç†åŠŸèƒ½å¼ºå¤§**ï¼šæ ‡ç­¾åˆ†ç±»ã€å®¡æ ¸ç³»ç»Ÿã€æ•°æ®åˆ†æ
- **å•†ä¸šåŒ–å°±ç»ª**ï¼šç”¨æˆ·ç³»ç»Ÿã€è®¡è´¹æ¨¡å¼ã€APIå¼€æ”¾

### 8.3 å®æ–½å¯è¡Œæ€§
- **åˆ†é˜¶æ®µå¼€å‘**ï¼šMVPâ†’åŠŸèƒ½å¢å¼ºâ†’å•†ä¸šåŒ–ï¼Œé£é™©å¯æ§
- **æˆæœ¬åˆç†**ï¼šå¼€å‘å’Œè¿è¥æˆæœ¬åœ¨å¯æ¥å—èŒƒå›´
- **å›¢é˜Ÿè¦æ±‚æ˜ç¡®**ï¼šæŠ€èƒ½è¦æ±‚å’Œäººå‘˜é…ç½®æ¸…æ™°
- **é£é™©å¯æ§**ï¼šè¯†åˆ«ä¸»è¦é£é™©å¹¶åˆ¶å®šåº”å¯¹ç­–ç•¥

### 8.4 å¸‚åœºå‰æ™¯
- **éœ€æ±‚æ˜ç¡®**ï¼šæ‘„å½±å¸ˆå’Œæ´»åŠ¨ç»„ç»‡è€…æœ‰çœŸå®éœ€æ±‚
- **å·®å¼‚åŒ–æ˜æ˜¾**ï¼šä¸“æ³¨äºä¸“ä¸šæ‘„å½±åœºæ™¯
- **å•†ä¸šæ¨¡å¼æ¸…æ™°**ï¼šå¤šç§æ”¶è´¹æ¨¡å¼ï¼Œå¯æŒç»­å‘å±•
- **æ‰©å±•æ€§å¼º**ï¼šå¯æ‹“å±•åˆ°æ›´å¤šå‚ç›´é¢†åŸŸ

**å»ºè®®ç«‹å³å¯åŠ¨MVPå¼€å‘ï¼ŒéªŒè¯æ ¸å¿ƒåŠŸèƒ½å’Œå¸‚åœºéœ€æ±‚ï¼Œä¸ºåç»­åŠŸèƒ½è¿­ä»£å’Œå•†ä¸šåŒ–å¥ å®šåŸºç¡€ã€‚** fetch(`${this.baseUrl}/ver100/shooting/liveview`);
      if (response.ok) {
        return await response.blob();
      }
    } catch (error) {
      console.error('è·å–å®æ—¶é¢„è§ˆå¤±è´¥:', error);
    }

    return null;
  }

  // æ–­å¼€è¿æ¥
  async disconnect() {
    if (this.sessionId) {
      try {
        await fetch(`${this.baseUrl}/ver100/session`, {
          method: 'DELETE'
        });
      } catch (error) {
        console.error('æ–­å¼€è¿æ¥å¤±è´¥:', error);
      }
    }

    this.isConnected = false;
    this.sessionId = null;
    this.baseUrl = null;
  }

  // ç”ŸæˆIPèŒƒå›´
  generateIPRange(subnet, start, end) {
    const ips = [];
    for (let i = start; i <= end; i++) {
      ips.push(`${subnet}.${i}`);
    }
    return ips;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const camera = new CanonWiFiCamera();

async function initializeCamera() {
  try {
    const cameraInfo = await camera.discoverCamera();
    console.log('å‘ç°ç›¸æœº:', cameraInfo);

    await camera.connect();
    console.log('ç›¸æœºè¿æ¥æˆåŠŸ');

    // å¼€å§‹å®æ—¶é¢„è§ˆ
    startLiveView();

    // è®¾ç½®æ‹æ‘„äº‹ä»¶ç›‘å¬
    document.getElementById('capture-btn').addEventListener('click', async () => {
      try {
        const photoInfo = await camera.takePicture();
        console.log('æ‹æ‘„å®Œæˆ:', photoInfo);

        // ä¸‹è½½å¹¶ä¸Šä¼ ç…§ç‰‡
        const photoData = await camera.downloadPhoto(photoInfo.url);
        await uploadPhotoToServer(photoData, photoInfo.filename);

      } catch (error) {
        console.error('æ‹æ‘„å¤±è´¥:', error);
      }
    });

  } catch (error) {
    console.error('åˆå§‹åŒ–ç›¸æœºå¤±è´¥:', error);
  }
}

// å®æ—¶é¢„è§ˆ
async function startLiveView() {
  const previewElement = document.getElementById('live-preview');

  setInterval(async () => {
    try {
      const liveViewBlob = await camera.getLiveView();
      if (liveViewBlob) {
        const url = URL.createObjectURL(liveViewBlob);
        previewElement.src = url;
      }
    } catch (error) {
      console.error('æ›´æ–°é¢„è§ˆå¤±è´¥:', error);
    }
  }, 100); // 10fps
}
```

#### 3.4.2 USBç›¸æœºè¿æ¥ï¼ˆä½¿ç”¨gPhoto2ï¼‰

```javascript
// lib/camera/usb_camera.js - USBç›¸æœºè¿æ¥
const { spawn } = require('child_process');
const fs = require('fs').promises;
const path = require('path');

class USBCamera {
  constructor() {
    this.isConnected = false;
    this.cameraModel = null;
  }

  // æ£€æµ‹ç›¸æœº
  async detectCamera() {
    return new Promise((resolve, reject) => {
      const gphoto = spawn('gphoto2', ['--auto-detect']);
      let output = '';

      gphoto.stdout.on('data', (data) => {
        output += data.toString();
      });

      gphoto.on('close', (code) => {
        if (code === 0) {
          const lines = output.split('\n').filter(line => line.trim());
          const cameraLines = lines.filter(line => line.includes('usb:'));

          if (cameraLines.length > 0) {
            const cameraInfo = cameraLines[0].split('usb:')[0].trim();
            this.cameraModel = cameraInfo;
            this.isConnected = true;
            resolve({
              model: cameraInfo,
              connection: 'USB'
            });
          } else {
            reject(new Error('æœªæ£€æµ‹åˆ°USBç›¸æœº'));
          }
        } else {
          reject(new Error('gphoto2å‘½ä»¤æ‰§è¡Œå¤±è´¥'));
        }
      });
    });
  }

  // æ‹æ‘„ç…§ç‰‡
  async captureImage(filename) {
    if (!this.isConnected) {
      throw new Error('ç›¸æœºæœªè¿æ¥');
    }

    const outputPath = path.join('/tmp', filename || `photo_${Date.now()}.jpg`);

    return new Promise((resolve, reject) => {
      const gphoto = spawn('gphoto2', [
        '--capture-image-and-download',
        '--filename', outputPath
      ]);

      let output = '';
      let errorOutput = '';

      gphoto.stdout.on('data', (data) => {
        output += data.toString();
      });

      gphoto.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      gphoto.on('close', async (code) => {
        if (code === 0) {
          try {
            // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
            await fs.access(outputPath);
            resolve({
              filename: path.basename(outputPath),
              path: outputPath,
              size: (await fs.stat(outputPath)).size
            });
          } catch (error) {
            reject(new Error('æ‹æ‘„çš„ç…§ç‰‡æ–‡ä»¶ä¸å­˜åœ¨'));
          }
        } else {
          reject(new Error(`æ‹æ‘„å¤±è´¥: ${errorOutput}`));
        }
      });
    });
  }

  // è·å–ç›¸æœºé…ç½®
  async getCameraConfig() {
    return new Promise((resolve, reject) => {
      const gphoto = spawn('gphoto2', ['--list-config']);
      let output = '';

      gphoto.stdout.on('data', (data) => {
        output += data.toString();
      });

      gphoto.on('close', (code) => {
        if (code === 0) {
          const configs = output.split('\n').filter(line => line.trim());
          resolve(configs);
        } else {
          reject(new Error('è·å–ç›¸æœºé…ç½®å¤±è´¥'));
        }
      });
    });
  }

  // è®¾ç½®ç›¸æœºå‚æ•°
  async setCameraConfig(setting, value) {
    return new Promise((resolve, reject) => {
      const gphoto = spawn('gphoto2', ['--set-config', `${setting}=${value}`]);

      gphoto.on('close', (code) => {
        if (code === 0) {
          resolve(true);
        } else {
          reject(new Error(`è®¾ç½®å‚æ•°å¤±è´¥: ${setting}=${value}`));
        }
      });
    });
  }

  // è·å–å®æ—¶é¢„è§ˆ
  async startLiveView(previewCallback) {
    if (!this.isConnected) {
      throw new Error('ç›¸æœºæœªè¿æ¥');
    }

    const previewProcess = spawn('gphoto2', [
      '--capture-preview',
      '--stdout'
    ]);

    previewProcess.stdout.on('data', (data) => {
      if (previewCallback) {
        previewCallback(data);
      }
    });

    return previewProcess;
  }
}

// Node.js Expressè·¯ç”±é›†æˆ
app.post('/api/camera/capture', async (req, res) => {
  try {
    const camera = new USBCamera();
    await camera.detectCamera();

    const photoInfo = await camera.captureImage();

    // è¯»å–ç…§ç‰‡æ–‡ä»¶
    const photoBuffer = await fs.readFile(photoInfo.path);

    // ä¸Šä¼ åˆ°äº‘å­˜å‚¨
    const uploadResult = await uploadToOSS(photoBuffer, photoInfo.filename);

    // ä¿å­˜åˆ°æ•°æ®åº“
    const photo = await db.photos.create({
      session_id: req.body.sessionId,
      filename: photoInfo.filename,
      original_url: uploadResult.url,
      file_size: photoInfo.size,
      upload_time: new Date()
    });

    // é€šè¿‡WebSocketæ¨é€
    io.to(`session_${req.body.sessionId}`).emit('new_photo', {
      id: photo.id,
      thumbnail_url: uploadResult.thumbnailUrl,
      original_url: uploadResult.url,
      upload_time: photo.upload_time
    });

    // æ¸…ç†ä¸´æ—¶æ–‡ä»¶
    await fs.unlink(photoInfo.path);

    res.json({
      code: 200,
      message: 'æ‹æ‘„æˆåŠŸ',
      data: photo
    });

  } catch (error) {
    res.status(500).json({
      code: 500,
      message: 'æ‹æ‘„å¤±è´¥',
      error: error.message
    });
  }
});
```

## 4. æ–°å¢åŠŸèƒ½å®ç°è¯¦è§£

### 4.1 å¤šåˆ†è¾¨ç‡å›¾ç‰‡å¤„ç†

```javascript
// lib/imageProcessor.js - å¢å¼ºç‰ˆå›¾ç‰‡å¤„ç†
const sharp = require('sharp');
const path = require('path');

// ç”Ÿæˆå¤šåˆ†è¾¨ç‡ç‰ˆæœ¬
async function generateMultiResolution(inputPath, watermarkOptions = null) {
  const versions = {};
  
  // è¯»å–åŸå›¾
  let pipeline = sharp(inputPath);
  
  // æ·»åŠ æ°´å°
  if (watermarkOptions) {
    const watermarkSvg = generateWatermarkSvg(watermarkOptions);
    pipeline = pipeline.composite([{
      input: Buffer.from(watermarkSvg),
      gravity: watermarkOptions.position === 'bottom-right' ? 'southeast' : 'southwest'
    }]);
  }
  
  // ç”Ÿæˆç¼©ç•¥å›¾ (300x300)
  versions.thumbnail = await pipeline
    .clone()
    .resize(300, 300, { fit: 'cover' })
    .jpeg({ quality: 80, progressive: true })
    .toBuffer();
  
  // ç”Ÿæˆä¸­ç­‰å°ºå¯¸ (800px)
  versions.medium = await pipeline
    .clone()
    .resize(800, 800, { fit: 'inside', withoutEnlargement: true })
    .jpeg({ quality: 85, progressive: true })
    .toBuffer();
  
  // ç”ŸæˆåŸå›¾å‹ç¼©ç‰ˆ (2048px)
  versions.original = await pipeline
    .clone()
    .resize(2048, 2048, { fit: 'inside', withoutEnlargement: true })
    .jpeg({ quality: 90, progressive: true })
    .toBuffer();
  
  // ç”ŸæˆWebPç‰ˆæœ¬
  versions.webp = await pipeline
    .clone()
    .resize(1200, 1200, { fit: 'inside', withoutEnlargement: true })
    .webp({ quality: 85, effort: 4 })
    .toBuffer();
  
  return versions;
}

// ç”Ÿæˆæ°´å°SVG
function generateWatermarkSvg(options) {
  const { text, opacity = 0.7 } = options;
  return `
    <svg width="200" height="50">
      <text x="10" y="35" 
            font-family="Arial" 
            font-size="16" 
            fill="white" 
            fill-opacity="${opacity}"
            stroke="black" 
            stroke-width="0.5" 
            stroke-opacity="${opacity * 0.5}">
        ${text}
      </text>
    </svg>
  `;
}

module.exports = { generateMultiResolution };
```

### 4.2 AIæ ‡ç­¾è¯†åˆ«æœåŠ¡

```javascript
// services/aiTaggingService.js - AIæ ‡ç­¾è¯†åˆ«
const tf = require('@tensorflow/tfjs-node');
const mobilenet = require('@tensorflow-models/mobilenet');
const sharp = require('sharp');

class AITaggingService {
  constructor() {
    this.model = null;
    this.customTags = {
      'person': ['äººç‰©', 'è‚–åƒ'],
      'wedding': ['å©šç¤¼', 'æ–°äºº'],
      'group': ['åˆç…§', 'é›†ä½“'],
      'indoor': ['å®¤å†…'],
      'outdoor': ['æˆ·å¤–', 'å¤–æ™¯'],
      'formal': ['æ­£å¼', 'åº„é‡'],
      'casual': ['è½»æ¾', 'éšæ„']
    };
  }

  async initialize() {
    if (!this.model) {
      this.model = await mobilenet.load();
    }
  }

  async analyzImage(imagePath) {
    await this.initialize();
    
    try {
      // é¢„å¤„ç†å›¾ç‰‡
      const imageBuffer = await sharp(imagePath)
        .resize(224, 224)
        .removeAlpha()
        .toBuffer();
      
      // è½¬æ¢ä¸ºtensor
      const tensor = tf.node.decodeImage(imageBuffer, 3)
        .expandDims(0)
        .div(255.0);
      
      // è¿›è¡Œé¢„æµ‹
      const predictions = await this.model.classify(tensor);
      
      // è½¬æ¢ä¸ºä¸­æ–‡æ ‡ç­¾
      const tags = this.convertToChineseTags(predictions);
      
      // æ¸…ç†tensor
      tensor.dispose();
      
      return tags;
    } catch (error) {
      console.error('AIæ ‡ç­¾è¯†åˆ«å¤±è´¥:', error);
      return [];
    }
  }

  convertToChineseTags(predictions) {
    const tags = [];
    
    for (const prediction of predictions) {
      if (prediction.probability > 0.3) {
        const className = prediction.className.toLowerCase();
        
        // æ£€æŸ¥è‡ªå®šä¹‰æ ‡ç­¾æ˜ å°„
        for (const [key, chineseTags] of Object.entries(this.customTags)) {
          if (className.includes(key)) {
            tags.push(...chineseTags);
          }
        }
        
        // ç‰¹æ®Šåœºæ™¯è¯†åˆ«
        if (className.includes('suit') || className.includes('dress')) {
          tags.push('æ­£å¼', 'ç¤¼æœ');
        }
        
        if (className.includes('flower') || className.includes('bouquet')) {
          tags.push('èŠ±æŸ', 'è£…é¥°');
        }
      }
    }
    
    // å»é‡å¹¶è¿”å›
    return [...new Set(tags)];
  }
}

module.exports = new AITaggingService();
```

### 4.3 è®¿é—®ç éªŒè¯ä¸­é—´ä»¶

```javascript
// middleware/accessControl.js - è®¿é—®æ§åˆ¶
const db = require('../models');

// è®¿é—®ç éªŒè¯ä¸­é—´ä»¶
function verifyAccessCode(req, res, next) {
  return async (req, res, next) => {
    try {
      const sessionId = req.params.sessionId;
      const accessCode = req.query.code || req.body.access_code;
      
      // è·å–ç›¸å†Œä¿¡æ¯
      const session = await db.sessions.findById(sessionId);
      
      if (!session) {
        return res.status(404).json({
          code: 404,
          message: 'ç›¸å†Œä¸å­˜åœ¨'
        });
      }
      
      // æ£€æŸ¥æ˜¯å¦éœ€è¦è®¿é—®ç 
      if (session.settings.access_protection?.enabled) {
        if (!accessCode) {
          return res.status(401).json({
            code: 401,
            message: 'éœ€è¦è®¿é—®ç ',
            error: 'access_code_required'
          });
        }
        
        if (accessCode !== session.settings.access_protection.access_code) {
          return res.status(403).json({
            code: 403,
            message: 'è®¿é—®ç é”™è¯¯',
            error: 'invalid_access_code'
          });
        }
      }
      
      // å°†ç›¸å†Œä¿¡æ¯æ·»åŠ åˆ°è¯·æ±‚å¯¹è±¡
      req.session = session;
      next();
      
    } catch (error) {
      res.status(500).json({
        code: 500,
        message: 'éªŒè¯å¤±è´¥',
        error: error.message
      });
    }
  };
}

module.exports = { verifyAccessCode };
```

### 4.4 æ–­ç‚¹ç»­ä¼ å®ç°

```javascript
// lib/resumableUpload.js - æ–­ç‚¹ç»­ä¼ 
const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');

class ResumableUpload {
  constructor(uploadDir = './uploads/chunks') {
    this.uploadDir = uploadDir;
  }

  // åˆå§‹åŒ–ä¸Šä¼ 
  async initUpload(filename, fileSize, chunkSize = 1024 * 1024) {
    const uploadId = crypto.randomUUID();
    const totalChunks = Math.ceil(fileSize / chunkSize);
    
    const uploadInfo = {
      uploadId,
      filename,
      fileSize,
      chunkSize,
      totalChunks,
      uploadedChunks: [],
      createdAt: new Date()
    };
    
    // ä¿å­˜ä¸Šä¼ ä¿¡æ¯
    await this.saveUploadInfo(uploadId, uploadInfo);
    
    return {
      uploadId,
      chunkSize,
      totalChunks
    };
  }

  // ä¸Šä¼ åˆ†ç‰‡
  async uploadChunk(uploadId, chunkIndex, chunkData) {
    const uploadInfo = await this.getUploadInfo(uploadId);
    
    if (!uploadInfo) {
      throw new Error('ä¸Šä¼ ç›¸å†Œä¸å­˜åœ¨');
    }
    
    // ä¿å­˜åˆ†ç‰‡æ–‡ä»¶
    const chunkPath = path.join(this.uploadDir, `${uploadId}_${chunkIndex}`);
    await fs.writeFile(chunkPath, chunkData);
    
    // æ›´æ–°ä¸Šä¼ ä¿¡æ¯
    uploadInfo.uploadedChunks.push(chunkIndex);
    await this.saveUploadInfo(uploadId, uploadInfo);
    
    // æ£€æŸ¥æ˜¯å¦ä¸Šä¼ å®Œæˆ
    if (uploadInfo.uploadedChunks.length === uploadInfo.totalChunks) {
      return await this.completeUpload(uploadId);
    }
    
    return {
      uploaded: uploadInfo.uploadedChunks.length,
      total: uploadInfo.totalChunks,
      completed: false
    };
  }

  // å®Œæˆä¸Šä¼ 
  async completeUpload(uploadId) {
    const uploadInfo = await this.getUploadInfo(uploadId);
    
    // åˆå¹¶åˆ†ç‰‡
    const finalPath = path.join(this.uploadDir, uploadInfo.filename);
    const writeStream = await fs.open(finalPath, 'w');
    
    for (let i = 0; i < uploadInfo.totalChunks; i++) {
      const chunkPath = path.join(this.uploadDir, `${uploadId}_${i}`);
      const chunkData = await fs.readFile(chunkPath);
      await writeStream.write(chunkData);
      
      // åˆ é™¤åˆ†ç‰‡æ–‡ä»¶
      await fs.unlink(chunkPath);
    }
    
    await writeStream.close();
    
    // æ¸…ç†ä¸Šä¼ ä¿¡æ¯
    await this.deleteUploadInfo(uploadId);
    
    return {
      completed: true,
      filePath: finalPath,
      fileSize: uploadInfo.fileSize
    };
  }

  // è·å–ä¸Šä¼ çŠ¶æ€
  async getUploadStatus(uploadId) {
    const uploadInfo = await this.getUploadInfo(uploadId);
    
    if (!uploadInfo) {
      return null;
    }
    
    return {
      uploaded: uploadInfo.uploadedChunks.length,
      total: uploadInfo.totalChunks,
      missingChunks: this.getMissingChunks(uploadInfo)
    };
  }

  getMissingChunks(uploadInfo) {
    const missing = [];
    for (let i = 0; i < uploadInfo.totalChunks; i++) {
      if (!uploadInfo.uploadedChunks.includes(i)) {
        missing.push(i);
      }
    }
    return missing;
  }

  async saveUploadInfo(uploadId, info) {
    // è¿™é‡Œå¯ä»¥ä½¿ç”¨Redisæˆ–æ•°æ®åº“å­˜å‚¨
    // ç®€åŒ–ç¤ºä¾‹ä½¿ç”¨æ–‡ä»¶å­˜å‚¨
    const infoPath = path.join(this.uploadDir, `${uploadId}.json`);
    await fs.writeFile(infoPath, JSON.stringify(info));
  }

  async getUploadInfo(uploadId) {
    try {
      const infoPath = path.join(this.uploadDir, `${uploadId}.json`);
      const data = await fs.readFile(infoPath, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      return null;
    }
  }

  async deleteUploadInfo(uploadId) {
    try {
      const infoPath = path.join(this.uploadDir, `${uploadId}.json`);
      await fs.unlink(infoPath);
    } catch (error) {
      // å¿½ç•¥åˆ é™¤é”™è¯¯
    }
  }
}

module.exports = ResumableUpload;
```

### 4.5 å¤šè¯­è¨€æ”¯æŒ

```javascript
// lib/i18n.js - å›½é™…åŒ–æ”¯æŒ
const i18n = require('i18next');
const Backend = require('i18next-fs-backend');

// åˆå§‹åŒ–i18n
i18n
  .use(Backend)
  .init({
    lng: 'zh-CN',
    fallbackLng: 'zh-CN',
    backend: {
      loadPath: './locales/{{lng}}/{{ns}}.json'
    },
    interpolation: {
      escapeValue: false
    }
  });

// ä¸­é—´ä»¶
function i18nMiddleware(req, res, next) {
  const lang = req.headers['accept-language'] || 
               req.query.lang || 
               req.body.language || 
               'zh-CN';
  
  req.t = i18n.getFixedT(lang);
  next();
}

module.exports = { i18n, i18nMiddleware };
```

```json
// locales/zh-CN/common.json
{
  "upload": {
    "success": "ä¸Šä¼ æˆåŠŸ",
    "failed": "ä¸Šä¼ å¤±è´¥",
    "processing": "å¤„ç†ä¸­..."
  },
  "session": {
    "created": "ç›¸å†Œåˆ›å»ºæˆåŠŸ",
    "not_found": "ç›¸å†Œä¸å­˜åœ¨",
    "access_denied": "è®¿é—®è¢«æ‹’ç»"
  },
  "photo": {
    "approved": "ç…§ç‰‡å·²é€šè¿‡å®¡æ ¸",
    "rejected": "ç…§ç‰‡å·²è¢«æ‹’ç»",
    "pending": "ç­‰å¾…å®¡æ ¸"
  },
  "tags": {
    "bride_groom": "æ–°éƒæ–°å¨˜",
    "group_photo": "å…¨ä½“åˆç…§",
    "indoor": "å®¤å†…",
    "outdoor": "æˆ·å¤–",
    "formal": "æ­£å¼",
    "casual": "è½»æ¾"
  }
}
```

```json
// locales/en-US/common.json
{
  "upload": {
    "success": "Upload successful",
    "failed": "Upload failed",
    "processing": "Processing..."
  },
  "session": {
    "created": "Session created successfully",
    "not_found": "Session not found",
    "access_denied": "Access denied"
  },
  "photo": {
    "approved": "Photo approved",
    "rejected": "Photo rejected",
    "pending": "Pending review"
  },
  "tags": {
    "bride_groom": "Bride & Groom",
    "group_photo": "Group Photo",
    "indoor": "Indoor",
    "outdoor": "Outdoor",
    "formal": "Formal",
    "casual": "Casual"
  }
}
```

## 5. éƒ¨ç½²å’Œè¿ç»´

### 4.1 DockeråŒ–éƒ¨ç½²

```yaml
# docker-compose.yml
version: '3.8'

services:
  # åç«¯APIæœåŠ¡
  api:
    build: 
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://user:password@postgres:5432/photolive
      - REDIS_URL=redis://redis:6379
      - OSS_ACCESS_KEY=${OSS_ACCESS_KEY}
      - OSS_SECRET_KEY=${OSS_SECRET_KEY}
      - OSS_BUCKET=${OSS_BUCKET}
    volumes:
      - ./uploads:/app/uploads
      - ./logs:/app/logs
    depends_on:
      - postgres
      - redis
    restart: unless-stopped

  # Webå‰ç«¯æœåŠ¡
  web:
    build:
      context: ./frontend-web
      dockerfile: Dockerfile
    ports:
      - "3001:3000"
    environment:
      - NEXT_PUBLIC_API_URL=https://api.yourdomain.com
      - NEXT_PUBLIC_WS_URL=wss://api.yourdomain.com
    depends_on:
      - api
    restart: unless-stopped

  # PostgreSQLæ•°æ®åº“
  postgres:
    image: postgres:14-alpine
    environment:
      - POSTGRES_DB=photolive
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql
    restart: unless-stopped

  # Redisç¼“å­˜
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    restart: unless-stopped

  # Nginxåå‘ä»£ç†
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
      - ./nginx/logs:/var/log/nginx
    depends_on:
      - api
      - web
    restart: unless-stopped

  # å›¾ç‰‡å¤„ç†é˜Ÿåˆ—
  image_processor:
    build:
      context: ./image-processor
      dockerfile: Dockerfile
    environment:
      - REDIS_URL=redis://redis:6379
      - OSS_ACCESS_KEY=${OSS_ACCESS_KEY}
      - OSS_SECRET_KEY=${OSS_SECRET_KEY}
    depends_on:
      - redis
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

```dockerfile
# backend/Dockerfile
FROM node:18-alpine

WORKDIR /app

# å®‰è£…gphoto2ï¼ˆç”¨äºUSBç›¸æœºï¼‰
RUN apk add --no-cache gphoto2 libgphoto2-dev

# å¤åˆ¶packageæ–‡ä»¶
COPY package*.json ./

# å®‰è£…ä¾èµ–
RUN npm ci --only=production

# å¤åˆ¶æºä»£ç 
COPY . .

# åˆ›å»ºå¿…è¦ç›®å½•
RUN mkdir -p uploads logs

# æš´éœ²ç«¯å£
EXPOSE 3000

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# å¯åŠ¨å‘½ä»¤
CMD ["npm", "start"]
```

```nginx
# nginx/nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream api_backend {
        server api:3000;
    }

    upstream web_backend {
        server web:3000;
    }

    # APIæœåŠ¡
    server {
        listen 80;
        server_name api.yourdomain.com;

        # HTTPé‡å®šå‘åˆ°HTTPS
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name api.yourdomain.com;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;

        # æ–‡ä»¶ä¸Šä¼ å¤§å°é™åˆ¶
        client_max_body_size 100M;

        # APIè·¯ç”±
        location /api/ {
            proxy_pass http://api_backend/api/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # WebSocketè·¯ç”±
        location /socket.io/ {
            proxy_pass http://api_backend/socket.io/;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }

    # Webå‰ç«¯æœåŠ¡
    server {
        listen 80;
        server_name yourdomain.com www.yourdomain.com;

        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name yourdomain.com www.yourdomain.com;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;

        location / {
            proxy_pass http://web_backend/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # é™æ€æ–‡ä»¶ç¼“å­˜
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
            proxy_pass http://web_backend;
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }
}
```

### 4.2 ç›‘æ§å’Œæ—¥å¿—

```javascript
// utils/logger.js - æ—¥å¿—ç³»ç»Ÿ
const winston = require('winston');
const path = require('path');

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'photo-live-api' },
  transports: [
    // é”™è¯¯æ—¥å¿—
    new winston.transports.File({
      filename: path.join(__dirname, '../logs/error.log'),
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),

    // ç»¼åˆæ—¥å¿—
    new winston.transports.File({
      filename: path.join(__dirname, '../logs/combined.log'),
      maxsize: 5242880,
      maxFiles: 5
    }),

    // æ§åˆ¶å°è¾“å‡º
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    })
  ]
});

module.exports = logger;

// middleware/requestLogger.js - è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶
const logger = require('../utils/logger');

function requestLogger(req, res, next) {
  const start = Date.now();

  // è®°å½•è¯·æ±‚å¼€å§‹
  logger.info('Request started', {
    method: req.method,
    url: req.url,
    ip: req.ip,
    userAgent: req.get('User-Agent')
  });

  // æ‹¦æˆªå“åº”ç»“æŸ
  const originalSend = res.send;
  res.send = function(data) {
    const duration = Date.now() - start;

    logger.info('Request completed', {
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      contentLength: data ? data.length : 0
    });

    return originalSend.call(this, data);
  };

  next();
}

module.exports = requestLogger;
```

```bash
#!/bin/bash
# scripts/backup.sh - æ•°æ®å¤‡ä»½è„šæœ¬

# é…ç½®
BACKUP_DIR="/opt/backups/photolive"
DB_NAME="photolive"
DB_USER="user"
RETENTION_DAYS=30

# åˆ›å»ºå¤‡ä»½ç›®å½•
mkdir -p $BACKUP_DIR

# æ•°æ®åº“å¤‡ä»½
DATE=$(date +%Y%m%d_%H%M%S)
DB_BACKUP_FILE="$BACKUP_DIR/db_backup_$DATE.sql"

echo "å¼€å§‹æ•°æ®åº“å¤‡ä»½..."
docker exec photolive_postgres_1 pg_dump -U $DB_USER $DB_NAME > $DB_BACKUP_FILE

if [ $? -eq 0 ]; then
    echo "æ•°æ®åº“å¤‡ä»½æˆåŠŸ: $DB_BACKUP_FILE"
    gzip $DB_BACKUP_FILE
else
    echo "æ•°æ®åº“å¤‡ä»½å¤±è´¥"
    exit 1
fi

# æ–‡ä»¶å¤‡ä»½
FILES_BACKUP_FILE="$BACKUP_DIR/files_backup_$DATE.tar.gz"
echo "å¼€å§‹æ–‡ä»¶å¤‡ä»½..."
tar -czf $FILES_BACKUP_FILE -C /opt/photolive uploads logs

if [ $? -eq 0 ]; then
    echo "æ–‡ä»¶å¤‡ä»½æˆåŠŸ: $FILES_BACKUP_FILE"
else
    echo "æ–‡ä»¶å¤‡ä»½å¤±è´¥"
    exit 1
fi

# æ¸…ç†æ—§å¤‡ä»½
echo "æ¸…ç†æ—§å¤‡ä»½æ–‡ä»¶..."
find $BACKUP_DIR -name "*.sql.gz" -mtime +$RETENTION_DAYS -delete
find $BACKUP_DIR -name "*.tar.gz" -mtime +$RETENTION_DAYS -delete

echo "å¤‡ä»½å®Œæˆ"
```

### 4.3 æ€§èƒ½ä¼˜åŒ–é…ç½®

```javascript
// config/performance.js - æ€§èƒ½ä¼˜åŒ–é…ç½®
module.exports = {
  // å›¾ç‰‡å¤„ç†é…ç½®
  image: {
    thumbnailSize: 300,
    maxOriginalSize: 2048,
    quality: {
      thumbnail: 80,
      original: 85
    },
    formats: ['jpeg', 'webp'], // æ”¯æŒWebPæ ¼å¼
    progressive: true
  },

  // ç¼“å­˜é…ç½®
  cache: {
    redis: {
      ttl: 3600, // 1å°æ—¶
      maxMemory: '256mb'
    },
    cdn: {
      maxAge: 31536000, // 1å¹´
      sMaxAge: 86400 // 1å¤©
    }
  },

  // ä¸Šä¼ é…ç½®
  upload: {
    concurrent: 3, // å¹¶å‘ä¸Šä¼ æ•°é‡
    chunkSize: 1024 * 1024, // 1MBåˆ†å—
    timeout: 30000 // 30ç§’è¶…æ—¶
  },

  // WebSocketé…ç½®
  websocket: {
    pingTimeout: 60000,
    pingInterval: 25000,
    maxConnections: 1000
  }
};

// lib/imageProcessor.js - å›¾ç‰‡å¤„ç†ä¼˜åŒ–
const sharp = require('sharp');
const Queue = require('bull');

// åˆ›å»ºå›¾ç‰‡å¤„ç†é˜Ÿåˆ—
const imageQueue = new Queue('image processing', {
  redis: { port: 6379, host: 'redis' }
});

// å¤„ç†å›¾ç‰‡ä»»åŠ¡
imageQueue.process('optimize', async (job) => {
  const { inputPath, outputPath, options } = job.data;

  try {
    await sharp(inputPath)
      .resize(options.width, options.height, {
        fit: options.fit || 'cover',
        withoutEnlargement: true
      })
      .jpeg({
        quality: options.quality,
        progressive: true,
        mozjpeg: true // ä½¿ç”¨mozjpegç¼–ç å™¨
      })
      .toFile(outputPath);

    return { success: true, outputPath };
  } catch (error) {
    throw new Error(`å›¾ç‰‡å¤„ç†å¤±è´¥: ${error.message}`);
  }
});

// æ‰¹é‡å¤„ç†æ¥å£
async function processImageBatch(images) {
  const jobs = images.map(image => ({
    name: 'optimize',
    data: image,
    opts: {
      removeOnComplete: 5,
      removeOnFail: 10,
      attempts: 3,
      backoff: 'exponential'
    }
  }));

  return Promise.all(jobs.map(job => imageQueue.add(job.name, job.data, job.opts)));
}

module.exports = { imageQueue, processImageBatch };
```

## 5. æµ‹è¯•æ–¹æ¡ˆ

### 5.1 å•å…ƒæµ‹è¯•

```javascript
// tests/api/session.test.js
const request = require('supertest');
const app = require('../../app');
const db = require('../../models');

describe('Session API', () => {
  beforeEach(async () => {
    await db.sessions.destroy({ where: {} });
  });

  describe('POST /api/sessions', () => {
    it('åº”è¯¥æˆåŠŸåˆ›å»ºç›¸å†Œ', async () => {
      const sessionData = {
        name: 'æµ‹è¯•ç›¸å†Œ',
        description: 'æµ‹è¯•æè¿°'
      };

      const response = await request(app)
        .post('/api/sessions')
        .send(sessionData)
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.name).toBe(sessionData.name);
      expect(response.body.data.session_id).toBeDefined();
    });

    it('åº”è¯¥éªŒè¯å¿…å¡«å­—æ®µ', async () => {
      const response = await request(app)
        .post('/api/sessions')
        .send({})
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('name');
    });
  });

  describe('GET /api/sessions/:id', () => {
    it('åº”è¯¥è¿”å›ç›¸å†Œè¯¦æƒ…', async () => {
      const session = await db.sessions.create({
        name: 'æµ‹è¯•ç›¸å†Œ',
        description: 'æµ‹è¯•æè¿°'
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}`)
        .expect(200);

      expect(response.body.data.name).toBe(session.name);
    });

    it('åº”è¯¥è¿”å›404å½“ç›¸å†Œä¸å­˜åœ¨', async () => {
      const response = await request(app)
        .get('/api/sessions/nonexistent')
        .expect(404);

      expect(response.body.code).toBe(404);
    });
  });
});
```

```javascript
// tests/api/photo.test.js
const request = require('supertest');
const path = require('path');
const app = require('../../app');
const db = require('../../models');

describe('Photo API', () => {
  let session;

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
    
    session = await db.sessions.create({
      name: 'æµ‹è¯•ç›¸å†Œ',
      description: 'æµ‹è¯•æè¿°'
    });
  });

  describe('POST /api/sessions/:id/photos', () => {
    it('åº”è¯¥æˆåŠŸä¸Šä¼ ç…§ç‰‡', async () => {
      const testImagePath = path.join(__dirname, '../fixtures/test-image.jpg');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testImagePath)
        .field('tags', JSON.stringify(['æµ‹è¯•', 'æ ·ä¾‹']))
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.photo_id).toBeDefined();
      expect(response.body.data.urls).toBeDefined();
    });

    it('åº”è¯¥æ‹’ç»éå›¾ç‰‡æ–‡ä»¶', async () => {
      const testFilePath = path.join(__dirname, '../fixtures/test-file.txt');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testFilePath)
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('å›¾ç‰‡');
    });
  });

  describe('GET /api/sessions/:id/photos', () => {
    it('åº”è¯¥è¿”å›ç…§ç‰‡åˆ—è¡¨', async () => {
      // åˆ›å»ºæµ‹è¯•ç…§ç‰‡
      await db.photos.create({
        session_id: session.id,
        filename: 'test.jpg',
        urls: { thumbnail: 'thumb.jpg', original: 'orig.jpg' },
        tags: ['æµ‹è¯•']
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].filename).toBe('test.jpg');
    });

    it('åº”è¯¥æ”¯æŒæ ‡ç­¾è¿‡æ»¤', async () => {
      await db.photos.bulkCreate([
        {
          session_id: session.id,
          filename: 'test1.jpg',
          urls: {},
          tags: ['äººç‰©']
        },
        {
          session_id: session.id,
          filename: 'test2.jpg',
          urls: {},
          tags: ['é£æ™¯']
        }
      ]);

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos?tags=äººç‰©`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].tags).toContain('äººç‰©');
    });
  });
});
```

### 5.2 é›†æˆæµ‹è¯•

```javascript
// tests/integration/workflow.test.js
const request = require('supertest');
const app = require('../../app');
const db = require('../../models');
const WebSocket = require('ws');

describe('å®Œæ•´å·¥ä½œæµç¨‹æµ‹è¯•', () => {
  let session;
  let ws;

  beforeAll(async () => {
    // å¯åŠ¨WebSocketè¿æ¥
    ws = new WebSocket('ws://localhost:3000');
    await new Promise(resolve => ws.on('open', resolve));
  });

  afterAll(() => {
    ws.close();
  });

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
  });

  it('åº”è¯¥å®Œæˆå®Œæ•´çš„æ‹æ‘„åˆ†äº«æµç¨‹', async () => {
    // 1. åˆ›å»ºç›¸å†Œ
    const sessionResponse = await request(app)
      .post('/api/sessions')
      .send({
        name: 'å©šç¤¼æ‹æ‘„',
        description: 'å¼ ä¸‰æå››çš„å©šç¤¼',
        settings: {
          watermark: {
            enabled: true,
            text: 'å¼ ä¸‰â¤æå›› 2024.01.01'
          },
          access_protection: {
            enabled: true,
            access_code: '1234'
          }
        }
      })
      .expect(201);

    const sessionId = sessionResponse.body.data.session_id;

    // 2. åŠ å…¥ç›¸å†ŒWebSocketæˆ¿é—´
    ws.send(JSON.stringify({
      type: 'join_session',
      session_id: sessionId
    }));

    // 3. ä¸Šä¼ ç…§ç‰‡
    const uploadResponse = await request(app)
      .post(`/api/sessions/${sessionId}/photos`)
      .attach('photo', path.join(__dirname, '../fixtures/wedding.jpg'))
      .field('watermark_text', 'å¼ ä¸‰â¤æå›› 2024.01.01')
      .field('auto_tag', 'true')
      .expect(201);

    const photoId = uploadResponse.body.data.photo_id;

    // 4. éªŒè¯WebSocketæ¨é€
    const wsMessage = await new Promise(resolve => {
      ws.on('message', data => {
        const message = JSON.parse(data);
        if (message.type === 'new_photo') {
          resolve(message);
        }
      });
    });

    expect(wsMessage.data.photo_id).toBe(photoId);

    // 5. è®¿å®¢è®¿é—®ï¼ˆéœ€è¦è®¿é—®ç ï¼‰
    const guestResponse = await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=1234`)
      .expect(200);

    expect(guestResponse.body.data.photos).toHaveLength(1);

    // 6. é”™è¯¯è®¿é—®ç æµ‹è¯•
    await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=wrong`)
      .expect(403);
  });

  it('åº”è¯¥æ”¯æŒæ–­ç‚¹ç»­ä¼ ', async () => {
    const session = await db.sessions.create({
      name: 'æµ‹è¯•ç›¸å†Œ'
    });

    // 1. åˆå§‹åŒ–ä¸Šä¼ 
    const initResponse = await request(app)
      .post('/api/upload/init')
      .send({
        filename: 'large-photo.jpg',
        fileSize: 5 * 1024 * 1024, // 5MB
        chunkSize: 1024 * 1024 // 1MB
      })
      .expect(200);

    const uploadId = initResponse.body.data.uploadId;

    // 2. ä¸Šä¼ åˆ†ç‰‡
    const chunk1 = Buffer.alloc(1024 * 1024, 'a');
    await request(app)
      .post(`/api/upload/chunk/${uploadId}/0`)
      .send(chunk1)
      .expect(200);

    // 3. æ£€æŸ¥ä¸Šä¼ çŠ¶æ€
    const statusResponse = await request(app)
      .get(`/api/upload/status/${uploadId}`)
      .expect(200);

    expect(statusResponse.body.data.uploaded).toBe(1);
    expect(statusResponse.body.data.total).toBe(5);
  });
});
```

### 5.3 æ€§èƒ½æµ‹è¯•

```javascript
// tests/performance/load.test.js
const autocannon = require('autocannon');
const app = require('../../app');

describe('æ€§èƒ½æµ‹è¯•', () => {
  let server;

  beforeAll(() => {
    server = app.listen(0);
  });

  afterAll(() => {
    server.close();
  });

  it('APIå¹¶å‘æ€§èƒ½æµ‹è¯•', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions`,
      method: 'GET',
      connections: 100,
      duration: 10,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    expect(result.errors).toBe(0);
    expect(result.requests.average).toBeGreaterThan(100); // å¹³å‡æ¯ç§’100+è¯·æ±‚
  });

  it('å›¾ç‰‡ä¸Šä¼ æ€§èƒ½æµ‹è¯•', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions/test/photos`,
      method: 'POST',
      connections: 10,
      duration: 30,
      setupClient: (client) => {
        // æ¨¡æ‹Ÿæ–‡ä»¶ä¸Šä¼ 
        client.setBody(Buffer.alloc(1024 * 100, 'test')); // 100KBæµ‹è¯•æ–‡ä»¶
        client.setHeaders({
          'Content-Type': 'multipart/form-data'
        });
      }
    });

    expect(result.errors).toBe(0);
    expect(result.latency.p99).toBeLessThan(5000); // 99%è¯·æ±‚åœ¨5ç§’å†…å®Œæˆ
  });
});
```

## 6. é¡¹ç›®è§„åˆ’

### 6.1 å¼€å‘é˜¶æ®µ

#### ç¬¬ä¸€é˜¶æ®µï¼šMVPç‰ˆæœ¬ï¼ˆ4-6å‘¨ï¼‰

**æ ¸å¿ƒåŠŸèƒ½**
- åŸºç¡€ç›¸å†Œç®¡ç†ï¼ˆåˆ›å»ºã€æŸ¥çœ‹ï¼‰
- ç…§ç‰‡ä¸Šä¼ å’Œå±•ç¤º
- ç®€å•çš„å®æ—¶æ¨é€
- åŸºç¡€çš„Webç«¯æŸ¥çœ‹ç•Œé¢
- ç§»åŠ¨ç«¯æ‹æ‘„åº”ç”¨ï¼ˆåŸºç¡€ç‰ˆï¼‰

**æŠ€æœ¯æ ˆ**
- åç«¯ï¼šNode.js + Express + PostgreSQL
- å‰ç«¯ï¼šNext.js + React
- ç§»åŠ¨ç«¯ï¼šFlutter
- å®æ—¶é€šä¿¡ï¼šSocket.IO
- æ–‡ä»¶å­˜å‚¨ï¼šæœ¬åœ°å­˜å‚¨

**é‡Œç¨‹ç¢‘**
- Week 1-2: åç«¯APIåŸºç¡€æ¶æ„
- Week 3-4: å‰ç«¯ç•Œé¢å¼€å‘
- Week 5-6: ç§»åŠ¨ç«¯åº”ç”¨å¼€å‘å’Œé›†æˆæµ‹è¯•

#### ç¬¬äºŒé˜¶æ®µï¼šåŠŸèƒ½å¢å¼ºï¼ˆ6-8å‘¨ï¼‰

**æ–°å¢åŠŸèƒ½**
- è®¿é—®ç ä¿æŠ¤
- å›¾ç‰‡æ°´å°
- å¤šåˆ†è¾¨ç‡æ”¯æŒ
- åŸºç¡€æ ‡ç­¾ç³»ç»Ÿ
- äº‘å­˜å‚¨é›†æˆï¼ˆé˜¿é‡Œäº‘OSSï¼‰
- æ€§èƒ½ä¼˜åŒ–

**æŠ€æœ¯å‡çº§**
- Redisç¼“å­˜
- å›¾ç‰‡å¤„ç†é˜Ÿåˆ—
- CDNé›†æˆ
- ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ

**é‡Œç¨‹ç¢‘**
- Week 1-2: å®‰å…¨åŠŸèƒ½å’Œè®¿é—®æ§åˆ¶
- Week 3-4: å›¾ç‰‡å¤„ç†å’Œå­˜å‚¨ä¼˜åŒ–
- Week 5-6: æ ‡ç­¾ç³»ç»Ÿå’Œæœç´¢åŠŸèƒ½
- Week 7-8: æ€§èƒ½ä¼˜åŒ–å’Œç›‘æ§

#### ç¬¬ä¸‰é˜¶æ®µï¼šé«˜çº§åŠŸèƒ½ï¼ˆ8-10å‘¨ï¼‰

**é«˜çº§åŠŸèƒ½**
- AIè‡ªåŠ¨æ ‡ç­¾
- ç…§ç‰‡å®¡æ ¸ç³»ç»Ÿ
- æ–­ç‚¹ç»­ä¼ 
- å¤šè¯­è¨€æ”¯æŒ
- é«˜çº§æ°´å°å®šåˆ¶
- æ‰¹é‡æ“ä½œ

**å•†ä¸šåŒ–åŠŸèƒ½**
- ç”¨æˆ·ç³»ç»Ÿå’Œæƒé™ç®¡ç†
- å¥—é¤å’Œè®¡è´¹
- æ•°æ®åˆ†æå’ŒæŠ¥è¡¨
- APIå¼€æ”¾å¹³å°

**é‡Œç¨‹ç¢‘**
- Week 1-3: AIåŠŸèƒ½é›†æˆ
- Week 4-6: å®¡æ ¸å’Œç®¡ç†ç³»ç»Ÿ
- Week 7-8: å•†ä¸šåŒ–åŠŸèƒ½
- Week 9-10: æµ‹è¯•å’Œä¸Šçº¿å‡†å¤‡

### 6.2 å›¢é˜Ÿé…ç½®

**æ ¸å¿ƒå›¢é˜Ÿï¼ˆ5-7äººï¼‰**
- é¡¹ç›®ç»ç† Ã— 1
- åç«¯å¼€å‘ Ã— 2
- å‰ç«¯å¼€å‘ Ã— 1
- ç§»åŠ¨ç«¯å¼€å‘ Ã— 1
- UI/UXè®¾è®¡å¸ˆ Ã— 1
- æµ‹è¯•å·¥ç¨‹å¸ˆ Ã— 1

**æŠ€èƒ½è¦æ±‚**
- åç«¯ï¼šNode.jsã€æ•°æ®åº“è®¾è®¡ã€äº‘æœåŠ¡ã€æ€§èƒ½ä¼˜åŒ–
- å‰ç«¯ï¼šReactã€Next.jsã€å“åº”å¼è®¾è®¡
- ç§»åŠ¨ç«¯ï¼šFlutterã€ç›¸æœºAPIã€æ–‡ä»¶ä¸Šä¼ 
- è®¾è®¡ï¼šUIè®¾è®¡ã€ç”¨æˆ·ä½“éªŒã€åŸå‹è®¾è®¡
- æµ‹è¯•ï¼šè‡ªåŠ¨åŒ–æµ‹è¯•ã€æ€§èƒ½æµ‹è¯•ã€å®‰å…¨æµ‹è¯•

### 6.3 æˆæœ¬ä¼°ç®—

#### å¼€å‘æˆæœ¬
- äººåŠ›æˆæœ¬ï¼š50-70ä¸‡ï¼ˆ6ä¸ªæœˆï¼‰
- è®¾å¤‡å’Œå·¥å…·ï¼š5-10ä¸‡
- ç¬¬ä¸‰æ–¹æœåŠ¡ï¼š2-5ä¸‡
- **æ€»è®¡ï¼š57-85ä¸‡**

#### è¿è¥æˆæœ¬ï¼ˆæœˆï¼‰
- æœåŠ¡å™¨ï¼š5,000-15,000å…ƒ
- äº‘å­˜å‚¨ï¼š2,000-8,000å…ƒ
- CDNï¼š1,000-5,000å…ƒ
- ç›‘æ§å’Œå®‰å…¨ï¼š1,000-3,000å…ƒ
- **æœˆè¿è¥æˆæœ¬ï¼š9,000-31,000å…ƒ**

#### æ”¶å…¥æ¨¡å¼
- åŸºç¡€ç‰ˆï¼šå…è´¹ï¼ˆé™åˆ¶åŠŸèƒ½ï¼‰
- ä¸“ä¸šç‰ˆï¼š299å…ƒ/æœˆï¼ˆå®Œæ•´åŠŸèƒ½ï¼‰
- ä¼ä¸šç‰ˆï¼š999å…ƒ/æœˆï¼ˆå®šåˆ¶æœåŠ¡ï¼‰
- æŒ‰éœ€æœåŠ¡ï¼š1-5å…ƒ/GBå­˜å‚¨

## 7. é£é™©è¯„ä¼°ä¸åº”å¯¹

### 7.1 æŠ€æœ¯é£é™©

#### é«˜é£é™©
**1. å¤§æ–‡ä»¶ä¸Šä¼ ç¨³å®šæ€§**
- é£é™©ï¼šç½‘ç»œä¸ç¨³å®šå¯¼è‡´ä¸Šä¼ å¤±è´¥
- åº”å¯¹ï¼šæ–­ç‚¹ç»­ä¼ ã€é‡è¯•æœºåˆ¶ã€è¿›åº¦ä¿å­˜
- é¢„æ¡ˆï¼šæœ¬åœ°ç¼“å­˜ã€ç¦»çº¿ä¸Šä¼ é˜Ÿåˆ—

**2. å®æ—¶æ€§èƒ½ç“¶é¢ˆ**
- é£é™©ï¼šé«˜å¹¶å‘æ—¶WebSocketè¿æ¥æ•°è¿‡å¤š
- åº”å¯¹ï¼šè¿æ¥æ± ç®¡ç†ã€è´Ÿè½½å‡è¡¡ã€Redisé›†ç¾¤
- é¢„æ¡ˆï¼šé™çº§ä¸ºè½®è¯¢æ¨¡å¼

#### ä¸­é£é™©
**3. å›¾ç‰‡å¤„ç†æ€§èƒ½**
- é£é™©ï¼šå¤§é‡å›¾ç‰‡åŒæ—¶å¤„ç†å¯¼è‡´æœåŠ¡å™¨å‹åŠ›
- åº”å¯¹ï¼šå¼‚æ­¥é˜Ÿåˆ—ã€åˆ†å¸ƒå¼å¤„ç†ã€ç¼“å­˜ç­–ç•¥
- é¢„æ¡ˆï¼šå¤–éƒ¨å›¾ç‰‡å¤„ç†æœåŠ¡

**4. å­˜å‚¨æˆæœ¬æ§åˆ¶**
- é£é™©ï¼šå­˜å‚¨è´¹ç”¨å¿«é€Ÿå¢é•¿
- åº”å¯¹ï¼šæ™ºèƒ½å‹ç¼©ã€å®šæœŸæ¸…ç†ã€åˆ†å±‚å­˜å‚¨
- é¢„æ¡ˆï¼šç”¨æˆ·ä»˜è´¹å­˜å‚¨æ¨¡å¼

### 7.2 ä¸šåŠ¡é£é™©

#### é«˜é£é™©
**1. ç”¨æˆ·éšç§å’Œæ•°æ®å®‰å…¨**
- é£é™©ï¼šç…§ç‰‡æ³„éœ²ã€æ•°æ®è¢«ç›—
- åº”å¯¹ï¼šåŠ å¯†å­˜å‚¨ã€è®¿é—®æ§åˆ¶ã€å®‰å…¨å®¡è®¡
- é¢„æ¡ˆï¼šä¿é™©å’Œæ³•å¾‹ä¿æŠ¤

**2. ç‰ˆæƒå’Œæ³•å¾‹é—®é¢˜**
- é£é™©ï¼šç”¨æˆ·ä¸Šä¼ ä¾µæƒå†…å®¹
- åº”å¯¹ï¼šå†…å®¹å®¡æ ¸ã€ç”¨æˆ·åè®®ã€ä¸¾æŠ¥æœºåˆ¶
- é¢„æ¡ˆï¼šå¿«é€Ÿåˆ é™¤å’Œæ³•å¾‹æ”¯æŒ

#### ä¸­é£é™©
**3. å¸‚åœºç«äº‰**
- é£é™©ï¼šå¤§å‚æ¨å‡ºç±»ä¼¼äº§å“
- åº”å¯¹ï¼šå·®å¼‚åŒ–åŠŸèƒ½ã€ç”¨æˆ·ç²˜æ€§ã€å¿«é€Ÿè¿­ä»£
- é¢„æ¡ˆï¼šç»†åˆ†å¸‚åœºå®šä½

**4. ç”¨æˆ·è·å–æˆæœ¬**
- é£é™©ï¼šè·å®¢æˆæœ¬è¿‡é«˜
- åº”å¯¹ï¼šå£ç¢‘è¥é”€ã€åˆä½œæ¨å¹¿ã€å…è´¹è¯•ç”¨
- é¢„æ¡ˆï¼šè°ƒæ•´å•†ä¸šæ¨¡å¼

### 7.3 è¿è¥é£é™©

#### ä¸­é£é™©
**1. æœåŠ¡å¯ç”¨æ€§**
- é£é™©ï¼šæœåŠ¡ä¸­æ–­å½±å“ç”¨æˆ·ä½“éªŒ
- åº”å¯¹ï¼šå¤šåœ°éƒ¨ç½²ã€è‡ªåŠ¨æ•…éšœè½¬ç§»ã€ç›‘æ§å‘Šè­¦
- é¢„æ¡ˆï¼šç´§æ€¥æ¢å¤æµç¨‹

**2. å›¢é˜Ÿç¨³å®šæ€§**
- é£é™©ï¼šæ ¸å¿ƒå¼€å‘äººå‘˜ç¦»èŒ
- åº”å¯¹ï¼šçŸ¥è¯†æ–‡æ¡£åŒ–ã€ä»£ç è§„èŒƒã€å›¢é˜Ÿå»ºè®¾
- é¢„æ¡ˆï¼šå¤–åŒ…å’Œæ‹›è˜è®¡åˆ’

### 7.4 åº”æ€¥é¢„æ¡ˆ

**æŠ€æœ¯æ•…éšœåº”æ€¥**
1. å»ºç«‹24å°æ—¶ç›‘æ§å’Œå‘Šè­¦
2. åˆ¶å®šæ•…éšœç­‰çº§å’Œå“åº”æ—¶é—´
3. å‡†å¤‡å›æ»šå’Œé™çº§æ–¹æ¡ˆ
4. å®šæœŸè¿›è¡Œæ•…éšœæ¼”ç»ƒ

**æ•°æ®å®‰å…¨åº”æ€¥**
1. å®šæœŸæ•°æ®å¤‡ä»½å’Œæ¢å¤æµ‹è¯•
2. å»ºç«‹æ•°æ®æ³„éœ²å“åº”æµç¨‹
3. å‡†å¤‡æ³•å¾‹å’Œå…¬å…³åº”å¯¹
4. ç”¨æˆ·é€šçŸ¥å’Œè¡¥å¿æœºåˆ¶

**ä¸šåŠ¡è¿ç»­æ€§**
1. å¤šäº‘éƒ¨ç½²é¿å…å•ç‚¹æ•…éšœ
2. æ ¸å¿ƒåŠŸèƒ½ç¦»çº¿å¯ç”¨
3. åˆä½œä¼™ä¼´å¤‡é€‰æ–¹æ¡ˆ
4. èµ„é‡‘å‚¨å¤‡å’Œèèµ„è®¡åˆ’

## 8. æ€»ç»“

æœ¬å¼€å‘æ–¹æ¡ˆä¸ºä¸ªäººç…§ç‰‡ç›´æ’­åº”ç”¨æä¾›äº†å®Œæ•´çš„æŠ€æœ¯æ¶æ„å’Œå®æ–½è·¯å¾„ã€‚æ–¹æ¡ˆå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

### 8.1 æŠ€æœ¯ä¼˜åŠ¿
- **ç°ä»£åŒ–æŠ€æœ¯æ ˆ**ï¼šé‡‡ç”¨Node.jsã€Reactã€Flutterç­‰ä¸»æµæŠ€æœ¯
- **å¯æ‰©å±•æ¶æ„**ï¼šå¾®æœåŠ¡è®¾è®¡ï¼Œæ”¯æŒæ°´å¹³æ‰©å±•
- **æ€§èƒ½ä¼˜åŒ–**ï¼šå¤šçº§ç¼“å­˜ã€CDNã€å›¾ç‰‡å‹ç¼©ç­‰ä¼˜åŒ–ç­–ç•¥
- **å®‰å…¨å¯é **ï¼šè®¿é—®æ§åˆ¶ã€æ•°æ®åŠ å¯†ã€å¤‡ä»½æ¢å¤

### 8.2 åŠŸèƒ½å®Œæ•´æ€§
- **æ ¸å¿ƒåŠŸèƒ½é½å…¨**ï¼šæ‹æ‘„ã€ä¸Šä¼ ã€åˆ†äº«ã€æŸ¥çœ‹å®Œæ•´æµç¨‹
- **ç”¨æˆ·ä½“éªŒä¼˜ç§€**ï¼šå®æ—¶æ¨é€ã€æ–­ç‚¹ç»­ä¼ ã€å¤šç«¯é€‚é…
- **ç®¡ç†åŠŸèƒ½å¼ºå¤§**ï¼šæ ‡ç­¾åˆ†ç±»ã€å®¡æ ¸ç³»ç»Ÿã€æ•°æ®åˆ†æ
- **å•†ä¸šåŒ–å°±ç»ª**ï¼šç”¨æˆ·ç³»ç»Ÿã€è®¡è´¹æ¨¡å¼ã€APIå¼€æ”¾

### 8.3 å®æ–½å¯è¡Œæ€§
- **åˆ†é˜¶æ®µå¼€å‘**ï¼šMVPâ†’åŠŸèƒ½å¢å¼ºâ†’å•†ä¸šåŒ–ï¼Œé£é™©å¯æ§
- **æˆæœ¬åˆç†**ï¼šå¼€å‘å’Œè¿è¥æˆæœ¬åœ¨å¯æ¥å—èŒƒå›´
- **å›¢é˜Ÿè¦æ±‚æ˜ç¡®**ï¼šæŠ€èƒ½è¦æ±‚å’Œäººå‘˜é…ç½®æ¸…æ™°
- **é£é™©å¯æ§**ï¼šè¯†åˆ«ä¸»è¦é£é™©å¹¶åˆ¶å®šåº”å¯¹ç­–ç•¥

### 8.4 å¸‚åœºå‰æ™¯
- **éœ€æ±‚æ˜ç¡®**ï¼šæ‘„å½±å¸ˆå’Œæ´»åŠ¨ç»„ç»‡è€…æœ‰çœŸå®éœ€æ±‚
- **å·®å¼‚åŒ–æ˜æ˜¾**ï¼šä¸“æ³¨äºä¸“ä¸šæ‘„å½±åœºæ™¯
- **å•†ä¸šæ¨¡å¼æ¸…æ™°**ï¼šå¤šç§æ”¶è´¹æ¨¡å¼ï¼Œå¯æŒç»­å‘å±•
- **æ‰©å±•æ€§å¼º**ï¼šå¯æ‹“å±•åˆ°æ›´å¤šå‚ç›´é¢†åŸŸ

**å»ºè®®ç«‹å³å¯åŠ¨MVPå¼€å‘ï¼ŒéªŒè¯æ ¸å¿ƒåŠŸèƒ½å’Œå¸‚åœºéœ€æ±‚ï¼Œä¸ºåç»­åŠŸèƒ½è¿­ä»£å’Œå•†ä¸šåŒ–å¥ å®šåŸºç¡€ã€‚**
```
