# 个人照片直播应用详细开发方案

## 1. 项目概述

### 1.1 产品定位

基于像素芝士功能模式，开发个人使用的多端照片直播应用，主要用于婚礼、活动等场景的实时照片分享。

### 1.2 核心价值

- **实时性**: 拍摄后立即分享给客人查看
- **便捷性**: 一键生成分享链接，客人扫码即看
- **专业性**: 支持专业相机，自动处理优化
- **私密性**: 个人部署，数据完全可控
- **安全性**: 支持访问码保护，防止链接泄露
- **智能化**: AI辅助选片，自动标签分类

## 2. 详细功能设计

### 2.1 拍摄端功能矩阵

| 功能模块     | 基础版 | 进阶版   | 专业版 |
| -------- | --- | ----- | --- |
| 手机拍照     | ✅   | ✅     | ✅   |
| 相机WiFi连接 | ❌   | ✅     | ✅   |
| 相机USB连接  | ❌   | ❌     | ✅   |
| 实时预览     | 手机  | 手机+相机 | 全设备 |
| 远程控制     | ❌   | 基础    | 高级  |
| 批量处理     | ❌   | ✅     | ✅   |
| AI选片     | ❌   | ❌     | ✅   |
| 访问码保护   | ❌   | ✅     | ✅   |
| 动态水印     | ❌   | ✅     | ✅   |
| 照片标签     | ❌   | ✅     | ✅   |
| 审核模式     | ❌   | ❌     | ✅   |
| 多语言支持   | ❌   | ✅     | ✅   |
| 断点续传     | ❌   | ✅     | ✅   |
| WebP压缩    | ❌   | ✅     | ✅   |

### 2.2 详细用户流程

#### 摄影师端流程

```mermaid
flowchart TD
    A[打开App] --> B[创建拍摄相册]
    B --> C[连接相机/使用手机]
    C --> D[开始拍摄]
    D --> E[照片自动上传]
    E --> F[生成分享链接]
    F --> G[分享给客人]
    G --> H[实时监控访问]

    D --> I[本地预览筛选]
    I --> J[批量上传选中照片]
    J --> E
```

#### 客人端流程

```mermaid
flowchart TD
    A[扫码/点击链接] --> B[进入展示页面]
    B --> C[查看实时照片]
    C --> D[点击放大查看]
    D --> E[选择下载照片]
    E --> F[批量打包下载]

    C --> G[分享给朋友]
    C --> H[收藏喜欢的照片]
```

## 3. 详细技术架构

### 3.1 整体架构图

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   拍摄端应用     │    │   云端服务       │    │   展示端应用     │
│                │    │                │    │                │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │ Flutter App │ │◄──►│ │ Node.js API │ │◄──►│ │ Next.js Web │ │
│ └─────────────┘ │    │ └─────────────┘ │    │ └─────────────┘ │
│ ┌─────────────┐ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │
│ │ Electron    │ │    │ │ WebSocket   │ │    │ │ Mobile PWA  │ │
│ └─────────────┘ │    │ └─────────────┘ │    │ └─────────────┘ │
└─────────────────┘    │ ┌─────────────┐ │    └─────────────────┘
                       │ │ 图片处理队列 │ │
                       │ └─────────────┘ │
                       │ ┌─────────────┐ │
                       │ │ OSS存储     │ │
                       │ └─────────────┘ │
                       └─────────────────┘
```

### 3.2 后端API详细设计

#### 3.2.1 API接口规范

```javascript
// 基础响应格式
{
  "code": 200,
  "message": "success",
  "data": {},
  "timestamp": 1640995200000
}

// 错误响应格式
{
  "code": 400,
  "message": "参数错误",
  "error": "validation_failed",
  "details": ["字段xxx不能为空"]
}
```

#### 3.2.2 核心API接口

```javascript
// routes/session.js - 相册管理
const express = require('express');
const router = express.Router();

// 创建拍摄相册
router.post('/sessions', async (req, res) => {
  /*
  POST /api/sessions
  Body: {
    "name": "小明婚礼现场",
    "description": "2024年6月1日婚礼",
    "settings": {
      "auto_upload": true,
      "quality": "high",
      "watermark": {
        "enabled": true,
        "text": "摄影师名称",
        "position": "bottom-right",
        "opacity": 0.7
      },
      "access_protection": {
        "enabled": true,
        "access_code": "1234"
      },
      "review_mode": false,
      "auto_tagging": true,
      "multi_resolution": true,
      "webp_compression": true,
      "language": "zh-CN"
    }
  }
  Response: {
    "data": {
      "id": 123,
      "name": "小明婚礼现场",
      "share_code": "ABC123",
      "share_url": "https://yourdomain.com/s/ABC123?code=1234",
      "qr_code": "data:image/png;base64,...",
      "access_code": "1234"
    }
  }
  */
});

// 获取相册详情
router.get('/sessions/:id', async (req, res) => {
  /*
  GET /api/sessions/123
  Response: {
    "data": {
      "id": 123,
      "name": "小明婚礼现场",
      "photo_count": 156,
      "view_count": 89,
      "created_at": "2024-06-01T10:00:00Z",
      "status": "active"
    }
  }
  */
});

// routes/photo.js - 图片管理
const multer = require('multer');
const sharp = require('sharp');

// 配置文件上传
const upload = multer({
  dest: 'uploads/',
  limits: {
    fileSize: 50 * 1024 * 1024 // 50MB
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('只允许上传图片文件'));
    }
  }
});

// 上传照片
router.post('/sessions/:sessionId/photos', upload.array('photos', 20), async (req, res) => {
  /*
  POST /api/sessions/123/photos
  Content-Type: multipart/form-data
  Files: photos[]
  Body: {
    "tags": ["新郎新娘", "全体合照"],
    "watermark_text": "摄影师名称",
    "auto_tag": true,
    "review_required": false
  }

  处理流程:
  1. 接收上传的图片文件
  2. AI自动标签识别（如果开启）
  3. 添加动态水印（如果开启）
  4. 生成多分辨率版本（缩略图、中等、原图）
  5. WebP和JPEG双格式压缩
  6. 上传到云存储
  7. 保存数据库记录（包含标签信息）
  8. 审核模式检查（如果开启）
  9. 通过WebSocket推送给在线用户
  */

  try {
    const files = req.files;
    const sessionId = req.params.sessionId;
    const { tags, watermark_text, auto_tag, review_required } = req.body;
    const uploadResults = [];
    const session = await db.sessions.findById(sessionId);

    for (const file of files) {
      let processedTags = tags || [];
      
      // AI自动标签识别
      if (auto_tag && session.settings.auto_tagging) {
        const aiTags = await aiTaggingService.analyzImage(file.path);
        processedTags = [...processedTags, ...aiTags];
      }

      // 添加动态水印
      let watermarkOptions = null;
      if (session.settings.watermark.enabled) {
        watermarkOptions = {
          text: watermark_text || session.settings.watermark.text,
          position: session.settings.watermark.position,
          opacity: session.settings.watermark.opacity
        };
      }

      // 生成多分辨率版本
      const versions = await generateMultiResolution(file.path, watermarkOptions);
      
      // 上传到云存储
      const uploadUrls = {};
      for (const [size, buffer] of Object.entries(versions)) {
        uploadUrls[size] = await uploadToOSS(buffer, `${size}/${file.filename}`);
      }

      // 保存到数据库
      const photo = await db.photos.create({
        session_id: sessionId,
        filename: file.originalname,
        original_url: uploadUrls.original,
        medium_url: uploadUrls.medium,
        thumbnail_url: uploadUrls.thumbnail,
        webp_url: uploadUrls.webp,
        file_size: versions.original.length,
        tags: processedTags,
        status: review_required ? 'pending' : 'published',
        upload_time: new Date()
      });

      uploadResults.push(photo);

      // WebSocket推送（仅发布状态的照片）
      if (photo.status === 'published') {
        io.to(`session_${sessionId}`).emit('new_photo', {
          id: photo.id,
          thumbnail_url: uploadUrls.thumbnail,
          webp_url: uploadUrls.webp,
          tags: processedTags,
          upload_time: photo.upload_time
        });
      }
    }

    res.json({
      code: 200,
      message: '上传成功',
      data: { photos: uploadResults }
    });

  } catch (error) {
    res.status(500).json({
      code: 500,
      message: '上传失败',
      error: error.message
    });
  }
});

// 获取相册照片列表
router.get('/sessions/:sessionId/photos', async (req, res) => {
  /*
  GET /api/sessions/123/photos?page=1&limit=20&sort=desc&tags=新郎新娘&code=1234
  Headers: {
    "Accept-Language": "zh-CN"
  }
  Response: {
    "data": {
      "photos": [
        {
          "id": 1001,
          "thumbnail_url": "https://cdn.example.com/thumbs/photo1.jpg",
          "medium_url": "https://cdn.example.com/medium/photo1.jpg",
          "original_url": "https://cdn.example.com/photos/photo1.jpg",
          "webp_url": "https://cdn.example.com/webp/photo1.webp",
          "upload_time": "2024-06-01T10:30:00Z",
          "file_size": 2048576,
          "tags": ["新郎新娘", "室内", "正式"],
          "status": "published"
        }
      ],
      "pagination": {
        "page": 1,
        "limit": 20,
        "total": 156,
        "has_more": true
      },
      "available_tags": ["新郎新娘", "全体合照", "室内", "户外", "正式", "轻松"]
    }
  }
  */
});

// 访问码验证
router.post('/sessions/:sessionId/verify', async (req, res) => {
  /*
  POST /api/sessions/123/verify
  Body: {
    "access_code": "1234"
  }
  Response: {
    "data": {
      "valid": true,
      "session_info": {
        "name": "小明婚礼现场",
        "description": "2024年6月1日婚礼",
        "photo_count": 156
      }
    }
  }
  */
});

// 照片审核管理
router.patch('/sessions/:sessionId/photos/:photoId/review', async (req, res) => {
  /*
  PATCH /api/sessions/123/photos/1001/review
  Body: {
    "action": "approve", // approve, reject
    "reason": "质量不佳" // 可选，拒绝原因
  }
  Response: {
    "data": {
      "id": 1001,
      "status": "published",
      "reviewed_at": "2024-06-01T10:35:00Z"
    }
  }
  */
});

// 批量照片操作
router.post('/sessions/:sessionId/photos/batch', async (req, res) => {
  /*
  POST /api/sessions/123/photos/batch
  Body: {
    "action": "add_tags", // add_tags, remove_tags, approve, reject
    "photo_ids": [1001, 1002, 1003],
    "tags": ["精选", "推荐"]
  }
  Response: {
    "data": {
      "updated_count": 3,
      "success": true
    }
  }
  */
});
```

#### 3.2.3 WebSocket实时通信

```javascript
// socket.js - WebSocket处理
const socketIo = require('socket.io');

function initSocket(server) {
  const io = socketIo(server, {
    cors: {
      origin: "*",
      methods: ["GET", "POST"]
    }
  });

  io.on('connection', (socket) => {
    console.log('用户连接:', socket.id);

    // 加入相册房间
    socket.on('join_session', (sessionId) => {
      socket.join(`session_${sessionId}`);
      console.log(`用户 ${socket.id} 加入相册 ${sessionId}`);

      // 广播在线人数
      const roomSize = io.sockets.adapter.rooms.get(`session_${sessionId}`)?.size || 0;
      io.to(`session_${sessionId}`).emit('online_count', roomSize);
    });

    // 离开相册房间
    socket.on('leave_session', (sessionId) => {
      socket.leave(`session_${sessionId}`);
      const roomSize = io.sockets.adapter.rooms.get(`session_${sessionId}`)?.size || 0;
      io.to(`session_${sessionId}`).emit('online_count', roomSize);
    });

    // 断开连接
    socket.on('disconnect', () => {
      console.log('用户断开连接:', socket.id);
    });
  });

  return io;
}

module.exports = initSocket;
```

### 3.3 前端详细实现

#### 3.3.1 Flutter移动端实现

```dart
// lib/models/session.dart - 数据模型
class Session {
  final int id;
  final String name;
  final String shareCode;
  final String shareUrl;
  final int photoCount;
  final DateTime createdAt;

  Session({
    required this.id,
    required this.name,
    required this.shareCode,
    required this.shareUrl,
    required this.photoCount,
    required this.createdAt,
  });

  factory Session.fromJson(Map<String, dynamic> json) {
    return Session(
      id: json['id'],
      name: json['name'],
      shareCode: json['share_code'],
      shareUrl: json['share_url'],
      photoCount: json['photo_count'],
      createdAt: DateTime.parse(json['created_at']),
    );
  }
}

// lib/services/api_service.dart - API服务
class ApiService {
  static const String baseUrl = 'https://your-api.com/api';
  final Dio _dio = Dio();

  ApiService() {
    _dio.options.baseUrl = baseUrl;
    _dio.options.connectTimeout = Duration(seconds: 10);
    _dio.options.receiveTimeout = Duration(seconds: 30);
  }

  // 创建相册
  Future<Session> createSession(String name, String description) async {
    try {
      final response = await _dio.post('/sessions', data: {
        'name': name,
        'description': description,
        'settings': {
          'auto_upload': true,
          'quality': 'high',
          'watermark': false,
        }
      });

      if (response.data['code'] == 200) {
        return Session.fromJson(response.data['data']);
      } else {
        throw Exception(response.data['message']);
      }
    } catch (e) {
      throw Exception('创建相册失败: $e');
    }
  }

  // 上传照片
  Future<List<Photo>> uploadPhotos(int sessionId, List<File> photos) async {
    try {
      FormData formData = FormData();

      for (int i = 0; i < photos.length; i++) {
        formData.files.add(MapEntry(
          'photos',
          await MultipartFile.fromFile(
            photos[i].path,
            filename: 'photo_${DateTime.now().millisecondsSinceEpoch}_$i.jpg',
          ),
        ));
      }

      final response = await _dio.post(
        '/sessions/$sessionId/photos',
        data: formData,
        onSendProgress: (sent, total) {
          print('上传进度: ${(sent / total * 100).toStringAsFixed(1)}%');
        },
      );

      if (response.data['code'] == 200) {
        List<Photo> uploadedPhotos = [];
        for (var photoJson in response.data['data']['photos']) {
          uploadedPhotos.add(Photo.fromJson(photoJson));
        }
        return uploadedPhotos;
      } else {
        throw Exception(response.data['message']);
      }
    } catch (e) {
      throw Exception('上传失败: $e');
    }
  }
}

// lib/screens/camera_screen.dart - 拍摄界面
class CameraScreen extends StatefulWidget {
  final Session session;

  CameraScreen({required this.session});

  @override
  _CameraScreenState createState() => _CameraScreenState();
}

class _CameraScreenState extends State<CameraScreen> {
  CameraController? _controller;
  bool _isInitialized = false;
  List<File> _pendingPhotos = [];
  bool _isUploading = false;

  @override
  void initState() {
    super.initState();
    _initializeCamera();
  }

  Future<void> _initializeCamera() async {
    final cameras = await availableCameras();
    if (cameras.isNotEmpty) {
      _controller = CameraController(
        cameras.first,
        ResolutionPreset.high,
        enableAudio: false,
      );

      await _controller!.initialize();
      setState(() {
        _isInitialized = true;
      });
    }
  }

  Future<void> _takePicture() async {
    if (!_controller!.value.isInitialized) return;

    try {
      final XFile photo = await _controller!.takePicture();
      final File photoFile = File(photo.path);

      setState(() {
        _pendingPhotos.add(photoFile);
      });

      // 自动上传（如果开启）
      if (widget.session.settings.autoUpload) {
        _uploadPendingPhotos();
      }

      // 播放快门音效
      SystemSound.play(SystemSoundType.click);

    } catch (e) {
      print('拍照失败: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('拍照失败: $e')),
      );
    }
  }

  Future<void> _uploadPendingPhotos() async {
    if (_pendingPhotos.isEmpty || _isUploading) return;

    setState(() {
      _isUploading = true;
    });

    try {
      final apiService = GetIt.instance<ApiService>();
      await apiService.uploadPhotos(widget.session.id, _pendingPhotos);

      setState(() {
        _pendingPhotos.clear();
      });

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('${_pendingPhotos.length}张照片上传成功')),
      );

    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('上传失败: $e')),
      );
    } finally {
      setState(() {
        _isUploading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (!_isInitialized) {
      return Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    return Scaffold(
      body: Stack(
        children: [
          // 相机预览
          Positioned.fill(
            child: CameraPreview(_controller!),
          ),

          // 顶部工具栏
          Positioned(
            top: MediaQuery.of(context).padding.top,
            left: 0,
            right: 0,
            child: Container(
              padding: EdgeInsets.all(16),
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: [Colors.black54, Colors.transparent],
                ),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  IconButton(
                    icon: Icon(Icons.arrow_back, color: Colors.white),
                    onPressed: () => Navigator.pop(context),
                  ),
                  Text(
                    widget.session.name,
                    style: TextStyle(color: Colors.white, fontSize: 18),
                  ),
                  IconButton(
                    icon: Icon(Icons.settings, color: Colors.white),
                    onPressed: () {
                      // 打开设置
                    },
                  ),
                ],
              ),
            ),
          ),

          // 底部控制栏
          Positioned(
            bottom: 0,
            left: 0,
            right: 0,
            child: Container(
              padding: EdgeInsets.all(20),
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.bottomCenter,
                  end: Alignment.topCenter,
                  colors: [Colors.black54, Colors.transparent],
                ),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  // 照片预览
                  GestureDetector(
                    onTap: () {
                      // 查看待上传照片
                    },
                    child: Container(
                      width: 60,
                      height: 60,
                      decoration: BoxDecoration(
                        border: Border.all(color: Colors.white, width: 2),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Stack(
                        children: [
                          if (_pendingPhotos.isNotEmpty)
                            ClipRRect(
                              borderRadius: BorderRadius.circular(6),
                              child: Image.file(
                                _pendingPhotos.last,
                                width: 56,
                                height: 56,
                                fit: BoxFit.cover,
                              ),
                            ),
                          if (_pendingPhotos.length > 1)
                            Positioned(
                              top: 4,
                              right: 4,
                              child: Container(
                                padding: EdgeInsets.all(2),
                                decoration: BoxDecoration(
                                  color: Colors.red,
                                  borderRadius: BorderRadius.circular(10),
                                ),
                                child: Text(
                                  '${_pendingPhotos.length}',
                                  style: TextStyle(
                                    color: Colors.white,
                                    fontSize: 12,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ),
                            ),
                        ],
                      ),
                    ),
                  ),

                  // 拍照按钮
                  GestureDetector(
                    onTap: _takePicture,
                    child: Container(
                      width: 80,
                      height: 80,
                      decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        border: Border.all(color: Colors.white, width: 4),
                      ),
                      child: Container(
                        margin: EdgeInsets.all(8),
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          color: Colors.white,
                        ),
                      ),
                    ),
                  ),

                  // 上传状态
                  Container(
                    width: 60,
                    height: 60,
                    child: _isUploading
                        ? CircularProgressIndicator(color: Colors.white)
                        : IconButton(
                            icon: Icon(Icons.cloud_upload, color: Colors.white, size: 30),
                            onPressed: _uploadPendingPhotos,
                          ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}
```

#### 3.3.2 Next.js Web端实现

```javascript
// pages/s/[shareCode].js - 分享展示页面
import { useState, useEffect } from 'react';
import { useRouter } from 'next/router';
import io from 'socket.io-client';
import Masonry from 'react-masonry-css';
import Lightbox from 'react-image-lightbox';
import 'react-image-lightbox/style.css';

export default function SharePage({ session, photos: initialPhotos }) {
  const router = useRouter();
  const { shareCode } = router.query;

  const [photos, setPhotos] = useState(initialPhotos || []);
  const [socket, setSocket] = useState(null);
  const [onlineCount, setOnlineCount] = useState(0);
  const [lightboxIndex, setLightboxIndex] = useState(-1);
  const [selectedPhotos, setSelectedPhotos] = useState(new Set());

  useEffect(() => {
    if (!session) return;

    // 建立WebSocket连接
    const newSocket = io(process.env.NEXT_PUBLIC_API_URL);

    newSocket.on('connect', () => {
      console.log('WebSocket已连接');
      newSocket.emit('join_session', session.id);
    });

    newSocket.on('new_photo', (photo) => {
      setPhotos(prev => [photo, ...prev]);

      // 显示新照片通知
      showNotification('新照片已添加!');
    });

    newSocket.on('online_count', (count) => {
      setOnlineCount(count);
    });

    setSocket(newSocket);

    return () => {
      newSocket.emit('leave_session', session.id);
      newSocket.disconnect();
    };
  }, [session]);

  const showNotification = (message) => {
    if (Notification.permission === 'granted') {
      new Notification('照片直播', {
        body: message,
        icon: '/icon-192x192.png'
      });
    }
  };

  const togglePhotoSelection = (photoId) => {
    const newSelection = new Set(selectedPhotos);
    if (newSelection.has(photoId)) {
      newSelection.delete(photoId);
    } else {
      newSelection.add(photoId);
    }
    setSelectedPhotos(newSelection);
  };

  const downloadSelectedPhotos = async () => {
    if (selectedPhotos.size === 0) return;

    const photoIds = Array.from(selectedPhotos);
    try {
      const response = await request(app)
        .post('/api/sessions')
        .send(sessionData)
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.name).toBe(sessionData.name);
      expect(response.body.data.session_id).toBeDefined();
    });

    it('应该验证必填字段', async () => {
      const response = await request(app)
        .post('/api/sessions')
        .send({})
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('name');
    });
  });

  describe('GET /api/sessions/:id', () => {
    it('应该返回相册详情', async () => {
      const session = await db.sessions.create({
        name: '测试相册',
        description: '测试描述'
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}`)
        .expect(200);

      expect(response.body.data.name).toBe(session.name);
    });

    it('应该返回404当相册不存在', async () => {
      const response = await request(app)
        .get('/api/sessions/nonexistent')
        .expect(404);

      expect(response.body.code).toBe(404);
    });
  });
});
```

```javascript
// tests/api/photo.test.js
const request = require('supertest');
const path = require('path');
const app = require('../../app');
const db = require('../../models');

describe('Photo API', () => {
  let session;

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
    
    session = await db.sessions.create({
      name: '测试相册',
      description: '测试描述'
    });
  });

  describe('POST /api/sessions/:id/photos', () => {
    it('应该成功上传照片', async () => {
      const testImagePath = path.join(__dirname, '../fixtures/test-image.jpg');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testImagePath)
        .field('tags', JSON.stringify(['测试', '样例']))
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.photo_id).toBeDefined();
      expect(response.body.data.urls).toBeDefined();
    });

    it('应该拒绝非图片文件', async () => {
      const testFilePath = path.join(__dirname, '../fixtures/test-file.txt');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testFilePath)
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('图片');
    });
  });

  describe('GET /api/sessions/:id/photos', () => {
    it('应该返回照片列表', async () => {
      // 创建测试照片
      await db.photos.create({
        session_id: session.id,
        filename: 'test.jpg',
        urls: { thumbnail: 'thumb.jpg', original: 'orig.jpg' },
        tags: ['测试']
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].filename).toBe('test.jpg');
    });

    it('应该支持标签过滤', async () => {
      await db.photos.bulkCreate([
        {
          session_id: session.id,
          filename: 'test1.jpg',
          urls: {},
          tags: ['人物']
        },
        {
          session_id: session.id,
          filename: 'test2.jpg',
          urls: {},
          tags: ['风景']
        }
      ]);

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos?tags=人物`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].tags).toContain('人物');
    });
  });
});
```

### 5.2 集成测试

```javascript
// tests/integration/workflow.test.js
const request = require('supertest');
const app = require('../../app');
const db = require('../../models');
const WebSocket = require('ws');

describe('完整工作流程测试', () => {
  let session;
  let ws;

  beforeAll(async () => {
    // 启动WebSocket连接
    ws = new WebSocket('ws://localhost:3000');
    await new Promise(resolve => ws.on('open', resolve));
  });

  afterAll(() => {
    ws.close();
  });

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
  });

  it('应该完成完整的拍摄分享流程', async () => {
    // 1. 创建相册
    const sessionResponse = await request(app)
      .post('/api/sessions')
      .send({
        name: '婚礼拍摄',
        description: '张三李四的婚礼',
        settings: {
          watermark: {
            enabled: true,
            text: '张三❤李四 2024.01.01'
          },
          access_protection: {
            enabled: true,
            access_code: '1234'
          }
        }
      })
      .expect(201);

    const sessionId = sessionResponse.body.data.session_id;

    // 2. 加入相册WebSocket房间
    ws.send(JSON.stringify({
      type: 'join_session',
      session_id: sessionId
    }));

    // 3. 上传照片
    const uploadResponse = await request(app)
      .post(`/api/sessions/${sessionId}/photos`)
      .attach('photo', path.join(__dirname, '../fixtures/wedding.jpg'))
      .field('watermark_text', '张三❤李四 2024.01.01')
      .field('auto_tag', 'true')
      .expect(201);

    const photoId = uploadResponse.body.data.photo_id;

    // 4. 验证WebSocket推送
    const wsMessage = await new Promise(resolve => {
      ws.on('message', data => {
        const message = JSON.parse(data);
        if (message.type === 'new_photo') {
          resolve(message);
        }
      });
    });

    expect(wsMessage.data.photo_id).toBe(photoId);

    // 5. 访客访问（需要访问码）
    const guestResponse = await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=1234`)
      .expect(200);

    expect(guestResponse.body.data.photos).toHaveLength(1);

    // 6. 错误访问码测试
    await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=wrong`)
      .expect(403);
  });

  it('应该支持断点续传', async () => {
    const session = await db.sessions.create({
      name: '测试相册'
    });

    // 1. 初始化上传
    const initResponse = await request(app)
      .post('/api/upload/init')
      .send({
        filename: 'large-photo.jpg',
        fileSize: 5 * 1024 * 1024, // 5MB
        chunkSize: 1024 * 1024 // 1MB
      })
      .expect(200);

    const uploadId = initResponse.body.data.uploadId;

    // 2. 上传分片
    const chunk1 = Buffer.alloc(1024 * 1024, 'a');
    await request(app)
      .post(`/api/upload/chunk/${uploadId}/0`)
      .send(chunk1)
      .expect(200);

    // 3. 检查上传状态
    const statusResponse = await request(app)
      .get(`/api/upload/status/${uploadId}`)
      .expect(200);

    expect(statusResponse.body.data.uploaded).toBe(1);
    expect(statusResponse.body.data.total).toBe(5);
  });
});
```

### 5.3 性能测试

```javascript
// tests/performance/load.test.js
const autocannon = require('autocannon');
const app = require('../../app');

describe('性能测试', () => {
  let server;

  beforeAll(() => {
    server = app.listen(0);
  });

  afterAll(() => {
    server.close();
  });

  it('API并发性能测试', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions`,
      method: 'GET',
      connections: 100,
      duration: 10,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    expect(result.errors).toBe(0);
    expect(result.requests.average).toBeGreaterThan(100); // 平均每秒100+请求
  });

  it('图片上传性能测试', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions/test/photos`,
      method: 'POST',
      connections: 10,
      duration: 30,
      setupClient: (client) => {
        // 模拟文件上传
        client.setBody(Buffer.alloc(1024 * 100, 'test')); // 100KB测试文件
        client.setHeaders({
          'Content-Type': 'multipart/form-data'
        });
      }
    });

    expect(result.errors).toBe(0);
    expect(result.latency.p99).toBeLessThan(5000); // 99%请求在5秒内完成
  });
});
```

## 6. 项目规划

### 6.1 开发阶段

#### 第一阶段：MVP版本（4-6周）

**核心功能**
- 基础相册管理（创建、查看）
- 照片上传和展示
- 简单的实时推送
- 基础的Web端查看界面
- 移动端拍摄应用（基础版）

**技术栈**
- 后端：Node.js + Express + PostgreSQL
- 前端：Next.js + React
- 移动端：Flutter
- 实时通信：Socket.IO
- 文件存储：本地存储

**里程碑**
- Week 1-2: 后端API基础架构
- Week 3-4: 前端界面开发
- Week 5-6: 移动端应用开发和集成测试

#### 第二阶段：功能增强（6-8周）

**新增功能**
- 访问码保护
- 图片水印
- 多分辨率支持
- 基础标签系统
- 云存储集成（阿里云OSS）
- 性能优化

**技术升级**
- Redis缓存
- 图片处理队列
- CDN集成
- 监控和日志系统

**里程碑**
- Week 1-2: 安全功能和访问控制
- Week 3-4: 图片处理和存储优化
- Week 5-6: 标签系统和搜索功能
- Week 7-8: 性能优化和监控

#### 第三阶段：高级功能（8-10周）

**高级功能**
- AI自动标签
- 照片审核系统
- 断点续传
- 多语言支持
- 高级水印定制
- 批量操作

**商业化功能**
- 用户系统和权限管理
- 套餐和计费
- 数据分析和报表
- API开放平台

**里程碑**
- Week 1-3: AI功能集成
- Week 4-6: 审核和管理系统
- Week 7-8: 商业化功能
- Week 9-10: 测试和上线准备

### 6.2 团队配置

**核心团队（5-7人）**
- 项目经理 × 1
- 后端开发 × 2
- 前端开发 × 1
- 移动端开发 × 1
- UI/UX设计师 × 1
- 测试工程师 × 1

**技能要求**
- 后端：Node.js、数据库设计、云服务、性能优化
- 前端：React、Next.js、响应式设计
- 移动端：Flutter、相机API、文件上传
- 设计：UI设计、用户体验、原型设计
- 测试：自动化测试、性能测试、安全测试

### 6.3 成本估算

#### 开发成本
- 人力成本：50-70万（6个月）
- 设备和工具：5-10万
- 第三方服务：2-5万
- **总计：57-85万**

#### 运营成本（月）
- 服务器：5,000-15,000元
- 云存储：2,000-8,000元
- CDN：1,000-5,000元
- 监控和安全：1,000-3,000元
- **月运营成本：9,000-31,000元**

#### 收入模式
- 基础版：免费（限制功能）
- 专业版：299元/月（完整功能）
- 企业版：999元/月（定制服务）
- 按需服务：1-5元/GB存储

## 7. 风险评估与应对

### 7.1 技术风险

#### 高风险
**1. 大文件上传稳定性**
- 风险：网络不稳定导致上传失败
- 应对：断点续传、重试机制、进度保存
- 预案：本地缓存、离线上传队列

**2. 实时性能瓶颈**
- 风险：高并发时WebSocket连接数过多
- 应对：连接池管理、负载均衡、Redis集群
- 预案：降级为轮询模式

#### 中风险
**3. 图片处理性能**
- 风险：大量图片同时处理导致服务器压力
- 应对：异步队列、分布式处理、缓存策略
- 预案：外部图片处理服务

**4. 存储成本控制**
- 风险：存储费用快速增长
- 应对：智能压缩、定期清理、分层存储
- 预案：用户付费存储模式

### 7.2 业务风险

#### 高风险
**1. 用户隐私和数据安全**
- 风险：照片泄露、数据被盗
- 应对：加密存储、访问控制、安全审计
- 预案：保险和法律保护

**2. 版权和法律问题**
- 风险：用户上传侵权内容
- 应对：内容审核、用户协议、举报机制
- 预案：快速删除和法律支持

#### 中风险
**3. 市场竞争**
- 风险：大厂推出类似产品
- 应对：差异化功能、用户粘性、快速迭代
- 预案：细分市场定位

**4. 用户获取成本**
- 风险：获客成本过高
- 应对：口碑营销、合作推广、免费试用
- 预案：调整商业模式

### 7.3 运营风险

#### 中风险
**1. 服务可用性**
- 风险：服务中断影响用户体验
- 应对：多地部署、自动故障转移、监控告警
- 预案：紧急恢复流程

**2. 团队稳定性**
- 风险：核心开发人员离职
- 应对：知识文档化、代码规范、团队建设
- 预案：外包和招聘计划

### 7.4 应急预案

**技术故障应急**
1. 建立24小时监控和告警
2. 制定故障等级和响应时间
3. 准备回滚和降级方案
4. 定期进行故障演练

**数据安全应急**
1. 定期数据备份和恢复测试
2. 建立数据泄露响应流程
3. 准备法律和公关应对
4. 用户通知和补偿机制

**业务连续性**
1. 多云部署避免单点故障
2. 核心功能离线可用
3. 合作伙伴备选方案
4. 资金储备和融资计划

## 8. 总结

本开发方案为个人照片直播应用提供了完整的技术架构和实施路径。方案具有以下特点：

### 8.1 技术优势
- **现代化技术栈**：采用Node.js、React、Flutter等主流技术
- **可扩展架构**：微服务设计，支持水平扩展
- **性能优化**：多级缓存、CDN、图片压缩等优化策略
- **安全可靠**：访问控制、数据加密、备份恢复

### 8.2 功能完整性
- **核心功能齐全**：拍摄、上传、分享、查看完整流程
- **用户体验优秀**：实时推送、断点续传、多端适配
- **管理功能强大**：标签分类、审核系统、数据分析
- **商业化就绪**：用户系统、计费模式、API开放

### 8.3 实施可行性
- **分阶段开发**：MVP→功能增强→商业化，风险可控
- **成本合理**：开发和运营成本在可接受范围
- **团队要求明确**：技能要求和人员配置清晰
- **风险可控**：识别主要风险并制定应对策略

### 8.4 市场前景
- **需求明确**：摄影师和活动组织者有真实需求
- **差异化明显**：专注于专业摄影场景
- **商业模式清晰**：多种收费模式，可持续发展
- **扩展性强**：可拓展到更多垂直领域

**建议立即启动MVP开发，验证核心功能和市场需求，为后续功能迭代和商业化奠定基础。** fetch(`/api/download`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sessionId: session.id,
          photoIds: photoIds
        })
      });

      if (response.ok) {
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${session.name}_selected_photos.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
      } else {
        throw new Error('下载失败');
      }
    } catch (error) {
      alert('下载失败: ' + error.message);
    }
  };

  const breakpointColumns = {
    default: 4,
    1100: 3,
    700: 2,
    500: 1
  };

  if (!session) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="text-center">
          <h1 className="text-2xl font-bold text-gray-800 mb-4">
            找不到此分享
          </h1>
          <p className="text-gray-600">
            请检查链接是否正确，或联系分享者
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50">
      {/* 头部 */}
      <header className="bg-white shadow-sm border-b">
        <div className="container mx-auto px-4 py-4">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-2xl font-bold text-gray-800">
                {session.name}
              </h1>
              <p className="text-gray-600">
                {photos.length} 张照片 · {onlineCount} 人在线
              </p>
            </div>

            <div className="flex items-center space-x-4">
              {selectedPhotos.size > 0 && (
                <button
                  onClick={downloadSelectedPhotos}
                  className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors"
                >
                  下载选中 ({selectedPhotos.size})
                </button>
              )}

              <button className="bg-gray-200 text-gray-800 px-4 py-2 rounded-lg hover:bg-gray-300 transition-colors">
                分享
              </button>
            </div>
          </div>
        </div>
      </header>

      {/* 照片网格 */}
      <main className="container mx-auto px-4 py-6">
        {photos.length === 0 ? (
          <div className="text-center py-12">
            <div className="text-6xl mb-4">📸</div>
            <h3 className="text-xl font-semibold text-gray-800 mb-2">
              暂无照片
            </h3>
            <p className="text-gray-600">
              摄影师正在准备中，请稍后刷新页面
            </p>
          </div>
        ) : (
          <Masonry
            breakpointCols={breakpointColumns}
            className="flex w-auto -ml-4"
            columnClassName="pl-4 bg-clip-padding"
          >
            {photos.map((photo, index) => (
              <div
                key={photo.id}
                className="mb-4 relative group cursor-pointer"
                onClick={() => setLightboxIndex(index)}
              >
                <img
                  src={photo.thumbnail_url}
                  alt={`照片 ${photo.id}`}
                  className="w-full rounded-lg shadow-md hover:shadow-lg transition-shadow"
                  loading="lazy"
                />

                {/* 选择覆盖层 */}
                <div className="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-20 transition-all rounded-lg flex items-center justify-center">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      togglePhotoSelection(photo.id);
                    }}
                    className={`w-8 h-8 rounded-full border-2 transition-all ${
                      selectedPhotos.has(photo.id)
                        ? 'bg-blue-600 border-blue-600'
                        : 'border-white bg-white bg-opacity-80'
                    } opacity-0 group-hover:opacity-100`}
                  >
                    {selectedPhotos.has(photo.id) && (
                      <svg className="w-4 h-4 text-white mx-auto" fill="currentColor" viewBox="0 0 20 20">
                        <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                      </svg>
                    )}
                  </button>
                </div>

                {/* 时间戳 */}
                <div className="absolute bottom-2 left-2 bg-black bg-opacity-60 text-white text-xs px-2 py-1 rounded">
                  {new Date(photo.upload_time).toLocaleTimeString()}
                </div>
              </div>
            ))}
          </Masonry>
        )}
      </main>

      {/* 灯箱组件 */}
      {lightboxIndex >= 0 && (
        <Lightbox
          mainSrc={photos[lightboxIndex].original_url}
          nextSrc={photos[(lightboxIndex + 1) % photos.length]?.original_url}
          prevSrc={photos[(lightboxIndex + photos.length - 1) % photos.length]?.original_url}
          onCloseRequest={() => setLightboxIndex(-1)}
          onMovePrevRequest={() =>
            setLightboxIndex((lightboxIndex + photos.length - 1) % photos.length)
          }
          onMoveNextRequest={() =>
            setLightboxIndex((lightboxIndex + 1) % photos.length)
          }
          imageTitle={`照片 ${lightboxIndex + 1} / ${photos.length}`}
          imageCaption={new Date(photos[lightboxIndex].upload_time).toLocaleString()}
        />
      )}
    </div>
  );
}

// 服务端渲染获取数据
export async function getServerSideProps({ params }) {
  const { shareCode } = params;

  try {
    const sessionResponse = await fetch(`${process.env.API_URL}/api/sessions/by-code/${shareCode}`);
    if (!sessionResponse.ok) {
      return { props: { session: null, photos: [] } };
    }

    const sessionData = await sessionResponse.json();
    const session = sessionData.data;

    const photosResponse = await fetch(`${process.env.API_URL}/api/sessions/${session.id}/photos?limit=50`);
    const photosData = await photosResponse.json();
    const photos = photosData.data.photos;

    return {
      props: {
        session,
        photos
      }
    };
  } catch (error) {
    console.error('获取数据失败:', error);
    return { props: { session: null, photos: [] } };
  }
}
```

### 3.4 相机连接详细实现

#### 3.4.1 WiFi相机连接（以佳能为例）

```javascript
// lib/camera/canon_wifi.js - 佳能WiFi连接
class CanonWiFiCamera {
  constructor() {
    this.baseUrl = null;
    this.sessionId = null;
    this.isConnected = false;
  }

  // 发现相机
  async discoverCamera() {
    // 扫描局域网中的佳能相机
    const possibleIPs = this.generateIPRange('192.168.1', 1, 254);

    for (const ip of possibleIPs) {
      try {
        const response = await request(app)
        .post('/api/sessions')
        .send(sessionData)
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.name).toBe(sessionData.name);
      expect(response.body.data.session_id).toBeDefined();
    });

    it('应该验证必填字段', async () => {
      const response = await request(app)
        .post('/api/sessions')
        .send({})
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('name');
    });
  });

  describe('GET /api/sessions/:id', () => {
    it('应该返回相册详情', async () => {
      const session = await db.sessions.create({
        name: '测试相册',
        description: '测试描述'
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}`)
        .expect(200);

      expect(response.body.data.name).toBe(session.name);
    });

    it('应该返回404当相册不存在', async () => {
      const response = await request(app)
        .get('/api/sessions/nonexistent')
        .expect(404);

      expect(response.body.code).toBe(404);
    });
  });
});
```

```javascript
// tests/api/photo.test.js
const request = require('supertest');
const path = require('path');
const app = require('../../app');
const db = require('../../models');

describe('Photo API', () => {
  let session;

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
    
    session = await db.sessions.create({
      name: '测试相册',
      description: '测试描述'
    });
  });

  describe('POST /api/sessions/:id/photos', () => {
    it('应该成功上传照片', async () => {
      const testImagePath = path.join(__dirname, '../fixtures/test-image.jpg');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testImagePath)
        .field('tags', JSON.stringify(['测试', '样例']))
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.photo_id).toBeDefined();
      expect(response.body.data.urls).toBeDefined();
    });

    it('应该拒绝非图片文件', async () => {
      const testFilePath = path.join(__dirname, '../fixtures/test-file.txt');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testFilePath)
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('图片');
    });
  });

  describe('GET /api/sessions/:id/photos', () => {
    it('应该返回照片列表', async () => {
      // 创建测试照片
      await db.photos.create({
        session_id: session.id,
        filename: 'test.jpg',
        urls: { thumbnail: 'thumb.jpg', original: 'orig.jpg' },
        tags: ['测试']
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].filename).toBe('test.jpg');
    });

    it('应该支持标签过滤', async () => {
      await db.photos.bulkCreate([
        {
          session_id: session.id,
          filename: 'test1.jpg',
          urls: {},
          tags: ['人物']
        },
        {
          session_id: session.id,
          filename: 'test2.jpg',
          urls: {},
          tags: ['风景']
        }
      ]);

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos?tags=人物`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].tags).toContain('人物');
    });
  });
});
```

### 5.2 集成测试

```javascript
// tests/integration/workflow.test.js
const request = require('supertest');
const app = require('../../app');
const db = require('../../models');
const WebSocket = require('ws');

describe('完整工作流程测试', () => {
  let session;
  let ws;

  beforeAll(async () => {
    // 启动WebSocket连接
    ws = new WebSocket('ws://localhost:3000');
    await new Promise(resolve => ws.on('open', resolve));
  });

  afterAll(() => {
    ws.close();
  });

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
  });

  it('应该完成完整的拍摄分享流程', async () => {
    // 1. 创建相册
    const sessionResponse = await request(app)
      .post('/api/sessions')
      .send({
        name: '婚礼拍摄',
        description: '张三李四的婚礼',
        settings: {
          watermark: {
            enabled: true,
            text: '张三❤李四 2024.01.01'
          },
          access_protection: {
            enabled: true,
            access_code: '1234'
          }
        }
      })
      .expect(201);

    const sessionId = sessionResponse.body.data.session_id;

    // 2. 加入相册WebSocket房间
    ws.send(JSON.stringify({
      type: 'join_session',
      session_id: sessionId
    }));

    // 3. 上传照片
    const uploadResponse = await request(app)
      .post(`/api/sessions/${sessionId}/photos`)
      .attach('photo', path.join(__dirname, '../fixtures/wedding.jpg'))
      .field('watermark_text', '张三❤李四 2024.01.01')
      .field('auto_tag', 'true')
      .expect(201);

    const photoId = uploadResponse.body.data.photo_id;

    // 4. 验证WebSocket推送
    const wsMessage = await new Promise(resolve => {
      ws.on('message', data => {
        const message = JSON.parse(data);
        if (message.type === 'new_photo') {
          resolve(message);
        }
      });
    });

    expect(wsMessage.data.photo_id).toBe(photoId);

    // 5. 访客访问（需要访问码）
    const guestResponse = await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=1234`)
      .expect(200);

    expect(guestResponse.body.data.photos).toHaveLength(1);

    // 6. 错误访问码测试
    await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=wrong`)
      .expect(403);
  });

  it('应该支持断点续传', async () => {
    const session = await db.sessions.create({
      name: '测试相册'
    });

    // 1. 初始化上传
    const initResponse = await request(app)
      .post('/api/upload/init')
      .send({
        filename: 'large-photo.jpg',
        fileSize: 5 * 1024 * 1024, // 5MB
        chunkSize: 1024 * 1024 // 1MB
      })
      .expect(200);

    const uploadId = initResponse.body.data.uploadId;

    // 2. 上传分片
    const chunk1 = Buffer.alloc(1024 * 1024, 'a');
    await request(app)
      .post(`/api/upload/chunk/${uploadId}/0`)
      .send(chunk1)
      .expect(200);

    // 3. 检查上传状态
    const statusResponse = await request(app)
      .get(`/api/upload/status/${uploadId}`)
      .expect(200);

    expect(statusResponse.body.data.uploaded).toBe(1);
    expect(statusResponse.body.data.total).toBe(5);
  });
});
```

### 5.3 性能测试

```javascript
// tests/performance/load.test.js
const autocannon = require('autocannon');
const app = require('../../app');

describe('性能测试', () => {
  let server;

  beforeAll(() => {
    server = app.listen(0);
  });

  afterAll(() => {
    server.close();
  });

  it('API并发性能测试', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions`,
      method: 'GET',
      connections: 100,
      duration: 10,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    expect(result.errors).toBe(0);
    expect(result.requests.average).toBeGreaterThan(100); // 平均每秒100+请求
  });

  it('图片上传性能测试', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions/test/photos`,
      method: 'POST',
      connections: 10,
      duration: 30,
      setupClient: (client) => {
        // 模拟文件上传
        client.setBody(Buffer.alloc(1024 * 100, 'test')); // 100KB测试文件
        client.setHeaders({
          'Content-Type': 'multipart/form-data'
        });
      }
    });

    expect(result.errors).toBe(0);
    expect(result.latency.p99).toBeLessThan(5000); // 99%请求在5秒内完成
  });
});
```

## 6. 项目规划

### 6.1 开发阶段

#### 第一阶段：MVP版本（4-6周）

**核心功能**
- 基础相册管理（创建、查看）
- 照片上传和展示
- 简单的实时推送
- 基础的Web端查看界面
- 移动端拍摄应用（基础版）

**技术栈**
- 后端：Node.js + Express + PostgreSQL
- 前端：Next.js + React
- 移动端：Flutter
- 实时通信：Socket.IO
- 文件存储：本地存储

**里程碑**
- Week 1-2: 后端API基础架构
- Week 3-4: 前端界面开发
- Week 5-6: 移动端应用开发和集成测试

#### 第二阶段：功能增强（6-8周）

**新增功能**
- 访问码保护
- 图片水印
- 多分辨率支持
- 基础标签系统
- 云存储集成（阿里云OSS）
- 性能优化

**技术升级**
- Redis缓存
- 图片处理队列
- CDN集成
- 监控和日志系统

**里程碑**
- Week 1-2: 安全功能和访问控制
- Week 3-4: 图片处理和存储优化
- Week 5-6: 标签系统和搜索功能
- Week 7-8: 性能优化和监控

#### 第三阶段：高级功能（8-10周）

**高级功能**
- AI自动标签
- 照片审核系统
- 断点续传
- 多语言支持
- 高级水印定制
- 批量操作

**商业化功能**
- 用户系统和权限管理
- 套餐和计费
- 数据分析和报表
- API开放平台

**里程碑**
- Week 1-3: AI功能集成
- Week 4-6: 审核和管理系统
- Week 7-8: 商业化功能
- Week 9-10: 测试和上线准备

### 6.2 团队配置

**核心团队（5-7人）**
- 项目经理 × 1
- 后端开发 × 2
- 前端开发 × 1
- 移动端开发 × 1
- UI/UX设计师 × 1
- 测试工程师 × 1

**技能要求**
- 后端：Node.js、数据库设计、云服务、性能优化
- 前端：React、Next.js、响应式设计
- 移动端：Flutter、相机API、文件上传
- 设计：UI设计、用户体验、原型设计
- 测试：自动化测试、性能测试、安全测试

### 6.3 成本估算

#### 开发成本
- 人力成本：50-70万（6个月）
- 设备和工具：5-10万
- 第三方服务：2-5万
- **总计：57-85万**

#### 运营成本（月）
- 服务器：5,000-15,000元
- 云存储：2,000-8,000元
- CDN：1,000-5,000元
- 监控和安全：1,000-3,000元
- **月运营成本：9,000-31,000元**

#### 收入模式
- 基础版：免费（限制功能）
- 专业版：299元/月（完整功能）
- 企业版：999元/月（定制服务）
- 按需服务：1-5元/GB存储

## 7. 风险评估与应对

### 7.1 技术风险

#### 高风险
**1. 大文件上传稳定性**
- 风险：网络不稳定导致上传失败
- 应对：断点续传、重试机制、进度保存
- 预案：本地缓存、离线上传队列

**2. 实时性能瓶颈**
- 风险：高并发时WebSocket连接数过多
- 应对：连接池管理、负载均衡、Redis集群
- 预案：降级为轮询模式

#### 中风险
**3. 图片处理性能**
- 风险：大量图片同时处理导致服务器压力
- 应对：异步队列、分布式处理、缓存策略
- 预案：外部图片处理服务

**4. 存储成本控制**
- 风险：存储费用快速增长
- 应对：智能压缩、定期清理、分层存储
- 预案：用户付费存储模式

### 7.2 业务风险

#### 高风险
**1. 用户隐私和数据安全**
- 风险：照片泄露、数据被盗
- 应对：加密存储、访问控制、安全审计
- 预案：保险和法律保护

**2. 版权和法律问题**
- 风险：用户上传侵权内容
- 应对：内容审核、用户协议、举报机制
- 预案：快速删除和法律支持

#### 中风险
**3. 市场竞争**
- 风险：大厂推出类似产品
- 应对：差异化功能、用户粘性、快速迭代
- 预案：细分市场定位

**4. 用户获取成本**
- 风险：获客成本过高
- 应对：口碑营销、合作推广、免费试用
- 预案：调整商业模式

### 7.3 运营风险

#### 中风险
**1. 服务可用性**
- 风险：服务中断影响用户体验
- 应对：多地部署、自动故障转移、监控告警
- 预案：紧急恢复流程

**2. 团队稳定性**
- 风险：核心开发人员离职
- 应对：知识文档化、代码规范、团队建设
- 预案：外包和招聘计划

### 7.4 应急预案

**技术故障应急**
1. 建立24小时监控和告警
2. 制定故障等级和响应时间
3. 准备回滚和降级方案
4. 定期进行故障演练

**数据安全应急**
1. 定期数据备份和恢复测试
2. 建立数据泄露响应流程
3. 准备法律和公关应对
4. 用户通知和补偿机制

**业务连续性**
1. 多云部署避免单点故障
2. 核心功能离线可用
3. 合作伙伴备选方案
4. 资金储备和融资计划

## 8. 总结

本开发方案为个人照片直播应用提供了完整的技术架构和实施路径。方案具有以下特点：

### 8.1 技术优势
- **现代化技术栈**：采用Node.js、React、Flutter等主流技术
- **可扩展架构**：微服务设计，支持水平扩展
- **性能优化**：多级缓存、CDN、图片压缩等优化策略
- **安全可靠**：访问控制、数据加密、备份恢复

### 8.2 功能完整性
- **核心功能齐全**：拍摄、上传、分享、查看完整流程
- **用户体验优秀**：实时推送、断点续传、多端适配
- **管理功能强大**：标签分类、审核系统、数据分析
- **商业化就绪**：用户系统、计费模式、API开放

### 8.3 实施可行性
- **分阶段开发**：MVP→功能增强→商业化，风险可控
- **成本合理**：开发和运营成本在可接受范围
- **团队要求明确**：技能要求和人员配置清晰
- **风险可控**：识别主要风险并制定应对策略

### 8.4 市场前景
- **需求明确**：摄影师和活动组织者有真实需求
- **差异化明显**：专注于专业摄影场景
- **商业模式清晰**：多种收费模式，可持续发展
- **扩展性强**：可拓展到更多垂直领域

**建议立即启动MVP开发，验证核心功能和市场需求，为后续功能迭代和商业化奠定基础。** fetch(`http://${ip}:8080/ccapi`, {
          timeout: 1000
        });

        if (response.ok) {
          const data = await response.json();
          if (data.manufacturer === 'Canon') {
            this.baseUrl = `http://${ip}:8080/ccapi`;
            return {
              ip: ip,
              model: data.productname,
              firmware: data.firmwareversion
            };
          }
        }
      } catch (error) {
        // 忽略连接错误，继续扫描
        continue;
      }
    }

    throw new Error('未找到佳能相机');
  }

  // 建立连接
  async connect() {
    if (!this.baseUrl) {
      await this.discoverCamera();
    }

    try {
      // 获取相册ID
      const sessionResponse = await fetch(`${this.baseUrl}/ver100/session`, {
        method: 'POST'
      });

      if (sessionResponse.ok) {
        const sessionData = await sessionResponse.json();
        this.sessionId = sessionData.sessionid;
        this.isConnected = true;
        return true;
      }
    } catch (error) {
      throw new Error(`连接相机失败: ${error.message}`);
    }

    return false;
  }

  // 拍摄照片
  async takePicture() {
    if (!this.isConnected) {
      throw new Error('相机未连接');
    }

    try {
      // 触发拍摄
      const shootResponse = await fetch(`${this.baseUrl}/ver100/shooting/control/shutterbutton`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          action: 'full_press'
        })
      });

      if (!shootResponse.ok) {
        throw new Error('拍摄失败');
      }

      // 等待拍摄完成
      await this.waitForCapture();

      // 获取最新照片
      const photoInfo = await this.getLatestPhoto();
      return photoInfo;

    } catch (error) {
      throw new Error(`拍摄失败: ${error.message}`);
    }
  }

  // 等待拍摄完成
  async waitForCapture(maxWait = 10000) {
    const startTime = Date.now();

    while (Date.now() - startTime < maxWait) {
      try {
        const statusResponse = await fetch(`${this.baseUrl}/ver100/shooting/control/shutterbutton`);
        const statusData = await statusResponse.json();

        if (statusData.state === 'release') {
          return true;
        }

        await new Promise(resolve => setTimeout(resolve, 100));
      } catch (error) {
        // 继续等待
      }
    }

    throw new Error('拍摄超时');
  }

  // 获取最新照片信息
  async getLatestPhoto() {
    try {
      const contentsResponse = await fetch(`${this.baseUrl}/ver100/contents/sd`);
      const contentsData = await contentsResponse.json();

      // 获取最新的照片
      const latestPhoto = contentsData.contents[0];

      return {
        filename: latestPhoto.name,
        url: `${this.baseUrl}${latestPhoto.url}`,
        size: latestPhoto.size,
        datetime: latestPhoto.datetime
      };
    } catch (error) {
      throw new Error(`获取照片信息失败: ${error.message}`);
    }
  }

  // 下载照片
  async downloadPhoto(photoUrl) {
    try {
      const response = await request(app)
        .post('/api/sessions')
        .send(sessionData)
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.name).toBe(sessionData.name);
      expect(response.body.data.session_id).toBeDefined();
    });

    it('应该验证必填字段', async () => {
      const response = await request(app)
        .post('/api/sessions')
        .send({})
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('name');
    });
  });

  describe('GET /api/sessions/:id', () => {
    it('应该返回相册详情', async () => {
      const session = await db.sessions.create({
        name: '测试相册',
        description: '测试描述'
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}`)
        .expect(200);

      expect(response.body.data.name).toBe(session.name);
    });

    it('应该返回404当相册不存在', async () => {
      const response = await request(app)
        .get('/api/sessions/nonexistent')
        .expect(404);

      expect(response.body.code).toBe(404);
    });
  });
});
```

```javascript
// tests/api/photo.test.js
const request = require('supertest');
const path = require('path');
const app = require('../../app');
const db = require('../../models');

describe('Photo API', () => {
  let session;

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
    
    session = await db.sessions.create({
      name: '测试相册',
      description: '测试描述'
    });
  });

  describe('POST /api/sessions/:id/photos', () => {
    it('应该成功上传照片', async () => {
      const testImagePath = path.join(__dirname, '../fixtures/test-image.jpg');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testImagePath)
        .field('tags', JSON.stringify(['测试', '样例']))
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.photo_id).toBeDefined();
      expect(response.body.data.urls).toBeDefined();
    });

    it('应该拒绝非图片文件', async () => {
      const testFilePath = path.join(__dirname, '../fixtures/test-file.txt');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testFilePath)
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('图片');
    });
  });

  describe('GET /api/sessions/:id/photos', () => {
    it('应该返回照片列表', async () => {
      // 创建测试照片
      await db.photos.create({
        session_id: session.id,
        filename: 'test.jpg',
        urls: { thumbnail: 'thumb.jpg', original: 'orig.jpg' },
        tags: ['测试']
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].filename).toBe('test.jpg');
    });

    it('应该支持标签过滤', async () => {
      await db.photos.bulkCreate([
        {
          session_id: session.id,
          filename: 'test1.jpg',
          urls: {},
          tags: ['人物']
        },
        {
          session_id: session.id,
          filename: 'test2.jpg',
          urls: {},
          tags: ['风景']
        }
      ]);

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos?tags=人物`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].tags).toContain('人物');
    });
  });
});
```

### 5.2 集成测试

```javascript
// tests/integration/workflow.test.js
const request = require('supertest');
const app = require('../../app');
const db = require('../../models');
const WebSocket = require('ws');

describe('完整工作流程测试', () => {
  let session;
  let ws;

  beforeAll(async () => {
    // 启动WebSocket连接
    ws = new WebSocket('ws://localhost:3000');
    await new Promise(resolve => ws.on('open', resolve));
  });

  afterAll(() => {
    ws.close();
  });

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
  });

  it('应该完成完整的拍摄分享流程', async () => {
    // 1. 创建相册
    const sessionResponse = await request(app)
      .post('/api/sessions')
      .send({
        name: '婚礼拍摄',
        description: '张三李四的婚礼',
        settings: {
          watermark: {
            enabled: true,
            text: '张三❤李四 2024.01.01'
          },
          access_protection: {
            enabled: true,
            access_code: '1234'
          }
        }
      })
      .expect(201);

    const sessionId = sessionResponse.body.data.session_id;

    // 2. 加入相册WebSocket房间
    ws.send(JSON.stringify({
      type: 'join_session',
      session_id: sessionId
    }));

    // 3. 上传照片
    const uploadResponse = await request(app)
      .post(`/api/sessions/${sessionId}/photos`)
      .attach('photo', path.join(__dirname, '../fixtures/wedding.jpg'))
      .field('watermark_text', '张三❤李四 2024.01.01')
      .field('auto_tag', 'true')
      .expect(201);

    const photoId = uploadResponse.body.data.photo_id;

    // 4. 验证WebSocket推送
    const wsMessage = await new Promise(resolve => {
      ws.on('message', data => {
        const message = JSON.parse(data);
        if (message.type === 'new_photo') {
          resolve(message);
        }
      });
    });

    expect(wsMessage.data.photo_id).toBe(photoId);

    // 5. 访客访问（需要访问码）
    const guestResponse = await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=1234`)
      .expect(200);

    expect(guestResponse.body.data.photos).toHaveLength(1);

    // 6. 错误访问码测试
    await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=wrong`)
      .expect(403);
  });

  it('应该支持断点续传', async () => {
    const session = await db.sessions.create({
      name: '测试相册'
    });

    // 1. 初始化上传
    const initResponse = await request(app)
      .post('/api/upload/init')
      .send({
        filename: 'large-photo.jpg',
        fileSize: 5 * 1024 * 1024, // 5MB
        chunkSize: 1024 * 1024 // 1MB
      })
      .expect(200);

    const uploadId = initResponse.body.data.uploadId;

    // 2. 上传分片
    const chunk1 = Buffer.alloc(1024 * 1024, 'a');
    await request(app)
      .post(`/api/upload/chunk/${uploadId}/0`)
      .send(chunk1)
      .expect(200);

    // 3. 检查上传状态
    const statusResponse = await request(app)
      .get(`/api/upload/status/${uploadId}`)
      .expect(200);

    expect(statusResponse.body.data.uploaded).toBe(1);
    expect(statusResponse.body.data.total).toBe(5);
  });
});
```

### 5.3 性能测试

```javascript
// tests/performance/load.test.js
const autocannon = require('autocannon');
const app = require('../../app');

describe('性能测试', () => {
  let server;

  beforeAll(() => {
    server = app.listen(0);
  });

  afterAll(() => {
    server.close();
  });

  it('API并发性能测试', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions`,
      method: 'GET',
      connections: 100,
      duration: 10,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    expect(result.errors).toBe(0);
    expect(result.requests.average).toBeGreaterThan(100); // 平均每秒100+请求
  });

  it('图片上传性能测试', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions/test/photos`,
      method: 'POST',
      connections: 10,
      duration: 30,
      setupClient: (client) => {
        // 模拟文件上传
        client.setBody(Buffer.alloc(1024 * 100, 'test')); // 100KB测试文件
        client.setHeaders({
          'Content-Type': 'multipart/form-data'
        });
      }
    });

    expect(result.errors).toBe(0);
    expect(result.latency.p99).toBeLessThan(5000); // 99%请求在5秒内完成
  });
});
```

## 6. 项目规划

### 6.1 开发阶段

#### 第一阶段：MVP版本（4-6周）

**核心功能**
- 基础相册管理（创建、查看）
- 照片上传和展示
- 简单的实时推送
- 基础的Web端查看界面
- 移动端拍摄应用（基础版）

**技术栈**
- 后端：Node.js + Express + PostgreSQL
- 前端：Next.js + React
- 移动端：Flutter
- 实时通信：Socket.IO
- 文件存储：本地存储

**里程碑**
- Week 1-2: 后端API基础架构
- Week 3-4: 前端界面开发
- Week 5-6: 移动端应用开发和集成测试

#### 第二阶段：功能增强（6-8周）

**新增功能**
- 访问码保护
- 图片水印
- 多分辨率支持
- 基础标签系统
- 云存储集成（阿里云OSS）
- 性能优化

**技术升级**
- Redis缓存
- 图片处理队列
- CDN集成
- 监控和日志系统

**里程碑**
- Week 1-2: 安全功能和访问控制
- Week 3-4: 图片处理和存储优化
- Week 5-6: 标签系统和搜索功能
- Week 7-8: 性能优化和监控

#### 第三阶段：高级功能（8-10周）

**高级功能**
- AI自动标签
- 照片审核系统
- 断点续传
- 多语言支持
- 高级水印定制
- 批量操作

**商业化功能**
- 用户系统和权限管理
- 套餐和计费
- 数据分析和报表
- API开放平台

**里程碑**
- Week 1-3: AI功能集成
- Week 4-6: 审核和管理系统
- Week 7-8: 商业化功能
- Week 9-10: 测试和上线准备

### 6.2 团队配置

**核心团队（5-7人）**
- 项目经理 × 1
- 后端开发 × 2
- 前端开发 × 1
- 移动端开发 × 1
- UI/UX设计师 × 1
- 测试工程师 × 1

**技能要求**
- 后端：Node.js、数据库设计、云服务、性能优化
- 前端：React、Next.js、响应式设计
- 移动端：Flutter、相机API、文件上传
- 设计：UI设计、用户体验、原型设计
- 测试：自动化测试、性能测试、安全测试

### 6.3 成本估算

#### 开发成本
- 人力成本：50-70万（6个月）
- 设备和工具：5-10万
- 第三方服务：2-5万
- **总计：57-85万**

#### 运营成本（月）
- 服务器：5,000-15,000元
- 云存储：2,000-8,000元
- CDN：1,000-5,000元
- 监控和安全：1,000-3,000元
- **月运营成本：9,000-31,000元**

#### 收入模式
- 基础版：免费（限制功能）
- 专业版：299元/月（完整功能）
- 企业版：999元/月（定制服务）
- 按需服务：1-5元/GB存储

## 7. 风险评估与应对

### 7.1 技术风险

#### 高风险
**1. 大文件上传稳定性**
- 风险：网络不稳定导致上传失败
- 应对：断点续传、重试机制、进度保存
- 预案：本地缓存、离线上传队列

**2. 实时性能瓶颈**
- 风险：高并发时WebSocket连接数过多
- 应对：连接池管理、负载均衡、Redis集群
- 预案：降级为轮询模式

#### 中风险
**3. 图片处理性能**
- 风险：大量图片同时处理导致服务器压力
- 应对：异步队列、分布式处理、缓存策略
- 预案：外部图片处理服务

**4. 存储成本控制**
- 风险：存储费用快速增长
- 应对：智能压缩、定期清理、分层存储
- 预案：用户付费存储模式

### 7.2 业务风险

#### 高风险
**1. 用户隐私和数据安全**
- 风险：照片泄露、数据被盗
- 应对：加密存储、访问控制、安全审计
- 预案：保险和法律保护

**2. 版权和法律问题**
- 风险：用户上传侵权内容
- 应对：内容审核、用户协议、举报机制
- 预案：快速删除和法律支持

#### 中风险
**3. 市场竞争**
- 风险：大厂推出类似产品
- 应对：差异化功能、用户粘性、快速迭代
- 预案：细分市场定位

**4. 用户获取成本**
- 风险：获客成本过高
- 应对：口碑营销、合作推广、免费试用
- 预案：调整商业模式

### 7.3 运营风险

#### 中风险
**1. 服务可用性**
- 风险：服务中断影响用户体验
- 应对：多地部署、自动故障转移、监控告警
- 预案：紧急恢复流程

**2. 团队稳定性**
- 风险：核心开发人员离职
- 应对：知识文档化、代码规范、团队建设
- 预案：外包和招聘计划

### 7.4 应急预案

**技术故障应急**
1. 建立24小时监控和告警
2. 制定故障等级和响应时间
3. 准备回滚和降级方案
4. 定期进行故障演练

**数据安全应急**
1. 定期数据备份和恢复测试
2. 建立数据泄露响应流程
3. 准备法律和公关应对
4. 用户通知和补偿机制

**业务连续性**
1. 多云部署避免单点故障
2. 核心功能离线可用
3. 合作伙伴备选方案
4. 资金储备和融资计划

## 8. 总结

本开发方案为个人照片直播应用提供了完整的技术架构和实施路径。方案具有以下特点：

### 8.1 技术优势
- **现代化技术栈**：采用Node.js、React、Flutter等主流技术
- **可扩展架构**：微服务设计，支持水平扩展
- **性能优化**：多级缓存、CDN、图片压缩等优化策略
- **安全可靠**：访问控制、数据加密、备份恢复

### 8.2 功能完整性
- **核心功能齐全**：拍摄、上传、分享、查看完整流程
- **用户体验优秀**：实时推送、断点续传、多端适配
- **管理功能强大**：标签分类、审核系统、数据分析
- **商业化就绪**：用户系统、计费模式、API开放

### 8.3 实施可行性
- **分阶段开发**：MVP→功能增强→商业化，风险可控
- **成本合理**：开发和运营成本在可接受范围
- **团队要求明确**：技能要求和人员配置清晰
- **风险可控**：识别主要风险并制定应对策略

### 8.4 市场前景
- **需求明确**：摄影师和活动组织者有真实需求
- **差异化明显**：专注于专业摄影场景
- **商业模式清晰**：多种收费模式，可持续发展
- **扩展性强**：可拓展到更多垂直领域

**建议立即启动MVP开发，验证核心功能和市场需求，为后续功能迭代和商业化奠定基础。** fetch(photoUrl);
      if (response.ok) {
        return await response.arrayBuffer();
      } else {
        throw new Error('下载失败');
      }
    } catch (error) {
      throw new Error(`下载照片失败: ${error.message}`);
    }
  }

  // 获取实时预览
  async getLiveView() {
    if (!this.isConnected) return null;

    try {
      const response = await request(app)
        .post('/api/sessions')
        .send(sessionData)
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.name).toBe(sessionData.name);
      expect(response.body.data.session_id).toBeDefined();
    });

    it('应该验证必填字段', async () => {
      const response = await request(app)
        .post('/api/sessions')
        .send({})
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('name');
    });
  });

  describe('GET /api/sessions/:id', () => {
    it('应该返回相册详情', async () => {
      const session = await db.sessions.create({
        name: '测试相册',
        description: '测试描述'
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}`)
        .expect(200);

      expect(response.body.data.name).toBe(session.name);
    });

    it('应该返回404当相册不存在', async () => {
      const response = await request(app)
        .get('/api/sessions/nonexistent')
        .expect(404);

      expect(response.body.code).toBe(404);
    });
  });
});
```

```javascript
// tests/api/photo.test.js
const request = require('supertest');
const path = require('path');
const app = require('../../app');
const db = require('../../models');

describe('Photo API', () => {
  let session;

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
    
    session = await db.sessions.create({
      name: '测试相册',
      description: '测试描述'
    });
  });

  describe('POST /api/sessions/:id/photos', () => {
    it('应该成功上传照片', async () => {
      const testImagePath = path.join(__dirname, '../fixtures/test-image.jpg');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testImagePath)
        .field('tags', JSON.stringify(['测试', '样例']))
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.photo_id).toBeDefined();
      expect(response.body.data.urls).toBeDefined();
    });

    it('应该拒绝非图片文件', async () => {
      const testFilePath = path.join(__dirname, '../fixtures/test-file.txt');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testFilePath)
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('图片');
    });
  });

  describe('GET /api/sessions/:id/photos', () => {
    it('应该返回照片列表', async () => {
      // 创建测试照片
      await db.photos.create({
        session_id: session.id,
        filename: 'test.jpg',
        urls: { thumbnail: 'thumb.jpg', original: 'orig.jpg' },
        tags: ['测试']
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].filename).toBe('test.jpg');
    });

    it('应该支持标签过滤', async () => {
      await db.photos.bulkCreate([
        {
          session_id: session.id,
          filename: 'test1.jpg',
          urls: {},
          tags: ['人物']
        },
        {
          session_id: session.id,
          filename: 'test2.jpg',
          urls: {},
          tags: ['风景']
        }
      ]);

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos?tags=人物`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].tags).toContain('人物');
    });
  });
});
```

### 5.2 集成测试

```javascript
// tests/integration/workflow.test.js
const request = require('supertest');
const app = require('../../app');
const db = require('../../models');
const WebSocket = require('ws');

describe('完整工作流程测试', () => {
  let session;
  let ws;

  beforeAll(async () => {
    // 启动WebSocket连接
    ws = new WebSocket('ws://localhost:3000');
    await new Promise(resolve => ws.on('open', resolve));
  });

  afterAll(() => {
    ws.close();
  });

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
  });

  it('应该完成完整的拍摄分享流程', async () => {
    // 1. 创建相册
    const sessionResponse = await request(app)
      .post('/api/sessions')
      .send({
        name: '婚礼拍摄',
        description: '张三李四的婚礼',
        settings: {
          watermark: {
            enabled: true,
            text: '张三❤李四 2024.01.01'
          },
          access_protection: {
            enabled: true,
            access_code: '1234'
          }
        }
      })
      .expect(201);

    const sessionId = sessionResponse.body.data.session_id;

    // 2. 加入相册WebSocket房间
    ws.send(JSON.stringify({
      type: 'join_session',
      session_id: sessionId
    }));

    // 3. 上传照片
    const uploadResponse = await request(app)
      .post(`/api/sessions/${sessionId}/photos`)
      .attach('photo', path.join(__dirname, '../fixtures/wedding.jpg'))
      .field('watermark_text', '张三❤李四 2024.01.01')
      .field('auto_tag', 'true')
      .expect(201);

    const photoId = uploadResponse.body.data.photo_id;

    // 4. 验证WebSocket推送
    const wsMessage = await new Promise(resolve => {
      ws.on('message', data => {
        const message = JSON.parse(data);
        if (message.type === 'new_photo') {
          resolve(message);
        }
      });
    });

    expect(wsMessage.data.photo_id).toBe(photoId);

    // 5. 访客访问（需要访问码）
    const guestResponse = await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=1234`)
      .expect(200);

    expect(guestResponse.body.data.photos).toHaveLength(1);

    // 6. 错误访问码测试
    await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=wrong`)
      .expect(403);
  });

  it('应该支持断点续传', async () => {
    const session = await db.sessions.create({
      name: '测试相册'
    });

    // 1. 初始化上传
    const initResponse = await request(app)
      .post('/api/upload/init')
      .send({
        filename: 'large-photo.jpg',
        fileSize: 5 * 1024 * 1024, // 5MB
        chunkSize: 1024 * 1024 // 1MB
      })
      .expect(200);

    const uploadId = initResponse.body.data.uploadId;

    // 2. 上传分片
    const chunk1 = Buffer.alloc(1024 * 1024, 'a');
    await request(app)
      .post(`/api/upload/chunk/${uploadId}/0`)
      .send(chunk1)
      .expect(200);

    // 3. 检查上传状态
    const statusResponse = await request(app)
      .get(`/api/upload/status/${uploadId}`)
      .expect(200);

    expect(statusResponse.body.data.uploaded).toBe(1);
    expect(statusResponse.body.data.total).toBe(5);
  });
});
```

### 5.3 性能测试

```javascript
// tests/performance/load.test.js
const autocannon = require('autocannon');
const app = require('../../app');

describe('性能测试', () => {
  let server;

  beforeAll(() => {
    server = app.listen(0);
  });

  afterAll(() => {
    server.close();
  });

  it('API并发性能测试', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions`,
      method: 'GET',
      connections: 100,
      duration: 10,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    expect(result.errors).toBe(0);
    expect(result.requests.average).toBeGreaterThan(100); // 平均每秒100+请求
  });

  it('图片上传性能测试', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions/test/photos`,
      method: 'POST',
      connections: 10,
      duration: 30,
      setupClient: (client) => {
        // 模拟文件上传
        client.setBody(Buffer.alloc(1024 * 100, 'test')); // 100KB测试文件
        client.setHeaders({
          'Content-Type': 'multipart/form-data'
        });
      }
    });

    expect(result.errors).toBe(0);
    expect(result.latency.p99).toBeLessThan(5000); // 99%请求在5秒内完成
  });
});
```

## 6. 项目规划

### 6.1 开发阶段

#### 第一阶段：MVP版本（4-6周）

**核心功能**
- 基础相册管理（创建、查看）
- 照片上传和展示
- 简单的实时推送
- 基础的Web端查看界面
- 移动端拍摄应用（基础版）

**技术栈**
- 后端：Node.js + Express + PostgreSQL
- 前端：Next.js + React
- 移动端：Flutter
- 实时通信：Socket.IO
- 文件存储：本地存储

**里程碑**
- Week 1-2: 后端API基础架构
- Week 3-4: 前端界面开发
- Week 5-6: 移动端应用开发和集成测试

#### 第二阶段：功能增强（6-8周）

**新增功能**
- 访问码保护
- 图片水印
- 多分辨率支持
- 基础标签系统
- 云存储集成（阿里云OSS）
- 性能优化

**技术升级**
- Redis缓存
- 图片处理队列
- CDN集成
- 监控和日志系统

**里程碑**
- Week 1-2: 安全功能和访问控制
- Week 3-4: 图片处理和存储优化
- Week 5-6: 标签系统和搜索功能
- Week 7-8: 性能优化和监控

#### 第三阶段：高级功能（8-10周）

**高级功能**
- AI自动标签
- 照片审核系统
- 断点续传
- 多语言支持
- 高级水印定制
- 批量操作

**商业化功能**
- 用户系统和权限管理
- 套餐和计费
- 数据分析和报表
- API开放平台

**里程碑**
- Week 1-3: AI功能集成
- Week 4-6: 审核和管理系统
- Week 7-8: 商业化功能
- Week 9-10: 测试和上线准备

### 6.2 团队配置

**核心团队（5-7人）**
- 项目经理 × 1
- 后端开发 × 2
- 前端开发 × 1
- 移动端开发 × 1
- UI/UX设计师 × 1
- 测试工程师 × 1

**技能要求**
- 后端：Node.js、数据库设计、云服务、性能优化
- 前端：React、Next.js、响应式设计
- 移动端：Flutter、相机API、文件上传
- 设计：UI设计、用户体验、原型设计
- 测试：自动化测试、性能测试、安全测试

### 6.3 成本估算

#### 开发成本
- 人力成本：50-70万（6个月）
- 设备和工具：5-10万
- 第三方服务：2-5万
- **总计：57-85万**

#### 运营成本（月）
- 服务器：5,000-15,000元
- 云存储：2,000-8,000元
- CDN：1,000-5,000元
- 监控和安全：1,000-3,000元
- **月运营成本：9,000-31,000元**

#### 收入模式
- 基础版：免费（限制功能）
- 专业版：299元/月（完整功能）
- 企业版：999元/月（定制服务）
- 按需服务：1-5元/GB存储

## 7. 风险评估与应对

### 7.1 技术风险

#### 高风险
**1. 大文件上传稳定性**
- 风险：网络不稳定导致上传失败
- 应对：断点续传、重试机制、进度保存
- 预案：本地缓存、离线上传队列

**2. 实时性能瓶颈**
- 风险：高并发时WebSocket连接数过多
- 应对：连接池管理、负载均衡、Redis集群
- 预案：降级为轮询模式

#### 中风险
**3. 图片处理性能**
- 风险：大量图片同时处理导致服务器压力
- 应对：异步队列、分布式处理、缓存策略
- 预案：外部图片处理服务

**4. 存储成本控制**
- 风险：存储费用快速增长
- 应对：智能压缩、定期清理、分层存储
- 预案：用户付费存储模式

### 7.2 业务风险

#### 高风险
**1. 用户隐私和数据安全**
- 风险：照片泄露、数据被盗
- 应对：加密存储、访问控制、安全审计
- 预案：保险和法律保护

**2. 版权和法律问题**
- 风险：用户上传侵权内容
- 应对：内容审核、用户协议、举报机制
- 预案：快速删除和法律支持

#### 中风险
**3. 市场竞争**
- 风险：大厂推出类似产品
- 应对：差异化功能、用户粘性、快速迭代
- 预案：细分市场定位

**4. 用户获取成本**
- 风险：获客成本过高
- 应对：口碑营销、合作推广、免费试用
- 预案：调整商业模式

### 7.3 运营风险

#### 中风险
**1. 服务可用性**
- 风险：服务中断影响用户体验
- 应对：多地部署、自动故障转移、监控告警
- 预案：紧急恢复流程

**2. 团队稳定性**
- 风险：核心开发人员离职
- 应对：知识文档化、代码规范、团队建设
- 预案：外包和招聘计划

### 7.4 应急预案

**技术故障应急**
1. 建立24小时监控和告警
2. 制定故障等级和响应时间
3. 准备回滚和降级方案
4. 定期进行故障演练

**数据安全应急**
1. 定期数据备份和恢复测试
2. 建立数据泄露响应流程
3. 准备法律和公关应对
4. 用户通知和补偿机制

**业务连续性**
1. 多云部署避免单点故障
2. 核心功能离线可用
3. 合作伙伴备选方案
4. 资金储备和融资计划

## 8. 总结

本开发方案为个人照片直播应用提供了完整的技术架构和实施路径。方案具有以下特点：

### 8.1 技术优势
- **现代化技术栈**：采用Node.js、React、Flutter等主流技术
- **可扩展架构**：微服务设计，支持水平扩展
- **性能优化**：多级缓存、CDN、图片压缩等优化策略
- **安全可靠**：访问控制、数据加密、备份恢复

### 8.2 功能完整性
- **核心功能齐全**：拍摄、上传、分享、查看完整流程
- **用户体验优秀**：实时推送、断点续传、多端适配
- **管理功能强大**：标签分类、审核系统、数据分析
- **商业化就绪**：用户系统、计费模式、API开放

### 8.3 实施可行性
- **分阶段开发**：MVP→功能增强→商业化，风险可控
- **成本合理**：开发和运营成本在可接受范围
- **团队要求明确**：技能要求和人员配置清晰
- **风险可控**：识别主要风险并制定应对策略

### 8.4 市场前景
- **需求明确**：摄影师和活动组织者有真实需求
- **差异化明显**：专注于专业摄影场景
- **商业模式清晰**：多种收费模式，可持续发展
- **扩展性强**：可拓展到更多垂直领域

**建议立即启动MVP开发，验证核心功能和市场需求，为后续功能迭代和商业化奠定基础。** fetch(`${this.baseUrl}/ver100/shooting/liveview`);
      if (response.ok) {
        return await response.blob();
      }
    } catch (error) {
      console.error('获取实时预览失败:', error);
    }

    return null;
  }

  // 断开连接
  async disconnect() {
    if (this.sessionId) {
      try {
        await fetch(`${this.baseUrl}/ver100/session`, {
          method: 'DELETE'
        });
      } catch (error) {
        console.error('断开连接失败:', error);
      }
    }

    this.isConnected = false;
    this.sessionId = null;
    this.baseUrl = null;
  }

  // 生成IP范围
  generateIPRange(subnet, start, end) {
    const ips = [];
    for (let i = start; i <= end; i++) {
      ips.push(`${subnet}.${i}`);
    }
    return ips;
  }
}

// 使用示例
const camera = new CanonWiFiCamera();

async function initializeCamera() {
  try {
    const cameraInfo = await camera.discoverCamera();
    console.log('发现相机:', cameraInfo);

    await camera.connect();
    console.log('相机连接成功');

    // 开始实时预览
    startLiveView();

    // 设置拍摄事件监听
    document.getElementById('capture-btn').addEventListener('click', async () => {
      try {
        const photoInfo = await camera.takePicture();
        console.log('拍摄完成:', photoInfo);

        // 下载并上传照片
        const photoData = await camera.downloadPhoto(photoInfo.url);
        await uploadPhotoToServer(photoData, photoInfo.filename);

      } catch (error) {
        console.error('拍摄失败:', error);
      }
    });

  } catch (error) {
    console.error('初始化相机失败:', error);
  }
}

// 实时预览
async function startLiveView() {
  const previewElement = document.getElementById('live-preview');

  setInterval(async () => {
    try {
      const liveViewBlob = await camera.getLiveView();
      if (liveViewBlob) {
        const url = URL.createObjectURL(liveViewBlob);
        previewElement.src = url;
      }
    } catch (error) {
      console.error('更新预览失败:', error);
    }
  }, 100); // 10fps
}
```

#### 3.4.2 USB相机连接（使用gPhoto2）

```javascript
// lib/camera/usb_camera.js - USB相机连接
const { spawn } = require('child_process');
const fs = require('fs').promises;
const path = require('path');

class USBCamera {
  constructor() {
    this.isConnected = false;
    this.cameraModel = null;
  }

  // 检测相机
  async detectCamera() {
    return new Promise((resolve, reject) => {
      const gphoto = spawn('gphoto2', ['--auto-detect']);
      let output = '';

      gphoto.stdout.on('data', (data) => {
        output += data.toString();
      });

      gphoto.on('close', (code) => {
        if (code === 0) {
          const lines = output.split('\n').filter(line => line.trim());
          const cameraLines = lines.filter(line => line.includes('usb:'));

          if (cameraLines.length > 0) {
            const cameraInfo = cameraLines[0].split('usb:')[0].trim();
            this.cameraModel = cameraInfo;
            this.isConnected = true;
            resolve({
              model: cameraInfo,
              connection: 'USB'
            });
          } else {
            reject(new Error('未检测到USB相机'));
          }
        } else {
          reject(new Error('gphoto2命令执行失败'));
        }
      });
    });
  }

  // 拍摄照片
  async captureImage(filename) {
    if (!this.isConnected) {
      throw new Error('相机未连接');
    }

    const outputPath = path.join('/tmp', filename || `photo_${Date.now()}.jpg`);

    return new Promise((resolve, reject) => {
      const gphoto = spawn('gphoto2', [
        '--capture-image-and-download',
        '--filename', outputPath
      ]);

      let output = '';
      let errorOutput = '';

      gphoto.stdout.on('data', (data) => {
        output += data.toString();
      });

      gphoto.stderr.on('data', (data) => {
        errorOutput += data.toString();
      });

      gphoto.on('close', async (code) => {
        if (code === 0) {
          try {
            // 检查文件是否存在
            await fs.access(outputPath);
            resolve({
              filename: path.basename(outputPath),
              path: outputPath,
              size: (await fs.stat(outputPath)).size
            });
          } catch (error) {
            reject(new Error('拍摄的照片文件不存在'));
          }
        } else {
          reject(new Error(`拍摄失败: ${errorOutput}`));
        }
      });
    });
  }

  // 获取相机配置
  async getCameraConfig() {
    return new Promise((resolve, reject) => {
      const gphoto = spawn('gphoto2', ['--list-config']);
      let output = '';

      gphoto.stdout.on('data', (data) => {
        output += data.toString();
      });

      gphoto.on('close', (code) => {
        if (code === 0) {
          const configs = output.split('\n').filter(line => line.trim());
          resolve(configs);
        } else {
          reject(new Error('获取相机配置失败'));
        }
      });
    });
  }

  // 设置相机参数
  async setCameraConfig(setting, value) {
    return new Promise((resolve, reject) => {
      const gphoto = spawn('gphoto2', ['--set-config', `${setting}=${value}`]);

      gphoto.on('close', (code) => {
        if (code === 0) {
          resolve(true);
        } else {
          reject(new Error(`设置参数失败: ${setting}=${value}`));
        }
      });
    });
  }

  // 获取实时预览
  async startLiveView(previewCallback) {
    if (!this.isConnected) {
      throw new Error('相机未连接');
    }

    const previewProcess = spawn('gphoto2', [
      '--capture-preview',
      '--stdout'
    ]);

    previewProcess.stdout.on('data', (data) => {
      if (previewCallback) {
        previewCallback(data);
      }
    });

    return previewProcess;
  }
}

// Node.js Express路由集成
app.post('/api/camera/capture', async (req, res) => {
  try {
    const camera = new USBCamera();
    await camera.detectCamera();

    const photoInfo = await camera.captureImage();

    // 读取照片文件
    const photoBuffer = await fs.readFile(photoInfo.path);

    // 上传到云存储
    const uploadResult = await uploadToOSS(photoBuffer, photoInfo.filename);

    // 保存到数据库
    const photo = await db.photos.create({
      session_id: req.body.sessionId,
      filename: photoInfo.filename,
      original_url: uploadResult.url,
      file_size: photoInfo.size,
      upload_time: new Date()
    });

    // 通过WebSocket推送
    io.to(`session_${req.body.sessionId}`).emit('new_photo', {
      id: photo.id,
      thumbnail_url: uploadResult.thumbnailUrl,
      original_url: uploadResult.url,
      upload_time: photo.upload_time
    });

    // 清理临时文件
    await fs.unlink(photoInfo.path);

    res.json({
      code: 200,
      message: '拍摄成功',
      data: photo
    });

  } catch (error) {
    res.status(500).json({
      code: 500,
      message: '拍摄失败',
      error: error.message
    });
  }
});
```

## 4. 新增功能实现详解

### 4.1 多分辨率图片处理

```javascript
// lib/imageProcessor.js - 增强版图片处理
const sharp = require('sharp');
const path = require('path');

// 生成多分辨率版本
async function generateMultiResolution(inputPath, watermarkOptions = null) {
  const versions = {};
  
  // 读取原图
  let pipeline = sharp(inputPath);
  
  // 添加水印
  if (watermarkOptions) {
    const watermarkSvg = generateWatermarkSvg(watermarkOptions);
    pipeline = pipeline.composite([{
      input: Buffer.from(watermarkSvg),
      gravity: watermarkOptions.position === 'bottom-right' ? 'southeast' : 'southwest'
    }]);
  }
  
  // 生成缩略图 (300x300)
  versions.thumbnail = await pipeline
    .clone()
    .resize(300, 300, { fit: 'cover' })
    .jpeg({ quality: 80, progressive: true })
    .toBuffer();
  
  // 生成中等尺寸 (800px)
  versions.medium = await pipeline
    .clone()
    .resize(800, 800, { fit: 'inside', withoutEnlargement: true })
    .jpeg({ quality: 85, progressive: true })
    .toBuffer();
  
  // 生成原图压缩版 (2048px)
  versions.original = await pipeline
    .clone()
    .resize(2048, 2048, { fit: 'inside', withoutEnlargement: true })
    .jpeg({ quality: 90, progressive: true })
    .toBuffer();
  
  // 生成WebP版本
  versions.webp = await pipeline
    .clone()
    .resize(1200, 1200, { fit: 'inside', withoutEnlargement: true })
    .webp({ quality: 85, effort: 4 })
    .toBuffer();
  
  return versions;
}

// 生成水印SVG
function generateWatermarkSvg(options) {
  const { text, opacity = 0.7 } = options;
  return `
    <svg width="200" height="50">
      <text x="10" y="35" 
            font-family="Arial" 
            font-size="16" 
            fill="white" 
            fill-opacity="${opacity}"
            stroke="black" 
            stroke-width="0.5" 
            stroke-opacity="${opacity * 0.5}">
        ${text}
      </text>
    </svg>
  `;
}

module.exports = { generateMultiResolution };
```

### 4.2 AI标签识别服务

```javascript
// services/aiTaggingService.js - AI标签识别
const tf = require('@tensorflow/tfjs-node');
const mobilenet = require('@tensorflow-models/mobilenet');
const sharp = require('sharp');

class AITaggingService {
  constructor() {
    this.model = null;
    this.customTags = {
      'person': ['人物', '肖像'],
      'wedding': ['婚礼', '新人'],
      'group': ['合照', '集体'],
      'indoor': ['室内'],
      'outdoor': ['户外', '外景'],
      'formal': ['正式', '庄重'],
      'casual': ['轻松', '随意']
    };
  }

  async initialize() {
    if (!this.model) {
      this.model = await mobilenet.load();
    }
  }

  async analyzImage(imagePath) {
    await this.initialize();
    
    try {
      // 预处理图片
      const imageBuffer = await sharp(imagePath)
        .resize(224, 224)
        .removeAlpha()
        .toBuffer();
      
      // 转换为tensor
      const tensor = tf.node.decodeImage(imageBuffer, 3)
        .expandDims(0)
        .div(255.0);
      
      // 进行预测
      const predictions = await this.model.classify(tensor);
      
      // 转换为中文标签
      const tags = this.convertToChineseTags(predictions);
      
      // 清理tensor
      tensor.dispose();
      
      return tags;
    } catch (error) {
      console.error('AI标签识别失败:', error);
      return [];
    }
  }

  convertToChineseTags(predictions) {
    const tags = [];
    
    for (const prediction of predictions) {
      if (prediction.probability > 0.3) {
        const className = prediction.className.toLowerCase();
        
        // 检查自定义标签映射
        for (const [key, chineseTags] of Object.entries(this.customTags)) {
          if (className.includes(key)) {
            tags.push(...chineseTags);
          }
        }
        
        // 特殊场景识别
        if (className.includes('suit') || className.includes('dress')) {
          tags.push('正式', '礼服');
        }
        
        if (className.includes('flower') || className.includes('bouquet')) {
          tags.push('花束', '装饰');
        }
      }
    }
    
    // 去重并返回
    return [...new Set(tags)];
  }
}

module.exports = new AITaggingService();
```

### 4.3 访问码验证中间件

```javascript
// middleware/accessControl.js - 访问控制
const db = require('../models');

// 访问码验证中间件
function verifyAccessCode(req, res, next) {
  return async (req, res, next) => {
    try {
      const sessionId = req.params.sessionId;
      const accessCode = req.query.code || req.body.access_code;
      
      // 获取相册信息
      const session = await db.sessions.findById(sessionId);
      
      if (!session) {
        return res.status(404).json({
          code: 404,
          message: '相册不存在'
        });
      }
      
      // 检查是否需要访问码
      if (session.settings.access_protection?.enabled) {
        if (!accessCode) {
          return res.status(401).json({
            code: 401,
            message: '需要访问码',
            error: 'access_code_required'
          });
        }
        
        if (accessCode !== session.settings.access_protection.access_code) {
          return res.status(403).json({
            code: 403,
            message: '访问码错误',
            error: 'invalid_access_code'
          });
        }
      }
      
      // 将相册信息添加到请求对象
      req.session = session;
      next();
      
    } catch (error) {
      res.status(500).json({
        code: 500,
        message: '验证失败',
        error: error.message
      });
    }
  };
}

module.exports = { verifyAccessCode };
```

### 4.4 断点续传实现

```javascript
// lib/resumableUpload.js - 断点续传
const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');

class ResumableUpload {
  constructor(uploadDir = './uploads/chunks') {
    this.uploadDir = uploadDir;
  }

  // 初始化上传
  async initUpload(filename, fileSize, chunkSize = 1024 * 1024) {
    const uploadId = crypto.randomUUID();
    const totalChunks = Math.ceil(fileSize / chunkSize);
    
    const uploadInfo = {
      uploadId,
      filename,
      fileSize,
      chunkSize,
      totalChunks,
      uploadedChunks: [],
      createdAt: new Date()
    };
    
    // 保存上传信息
    await this.saveUploadInfo(uploadId, uploadInfo);
    
    return {
      uploadId,
      chunkSize,
      totalChunks
    };
  }

  // 上传分片
  async uploadChunk(uploadId, chunkIndex, chunkData) {
    const uploadInfo = await this.getUploadInfo(uploadId);
    
    if (!uploadInfo) {
      throw new Error('上传相册不存在');
    }
    
    // 保存分片文件
    const chunkPath = path.join(this.uploadDir, `${uploadId}_${chunkIndex}`);
    await fs.writeFile(chunkPath, chunkData);
    
    // 更新上传信息
    uploadInfo.uploadedChunks.push(chunkIndex);
    await this.saveUploadInfo(uploadId, uploadInfo);
    
    // 检查是否上传完成
    if (uploadInfo.uploadedChunks.length === uploadInfo.totalChunks) {
      return await this.completeUpload(uploadId);
    }
    
    return {
      uploaded: uploadInfo.uploadedChunks.length,
      total: uploadInfo.totalChunks,
      completed: false
    };
  }

  // 完成上传
  async completeUpload(uploadId) {
    const uploadInfo = await this.getUploadInfo(uploadId);
    
    // 合并分片
    const finalPath = path.join(this.uploadDir, uploadInfo.filename);
    const writeStream = await fs.open(finalPath, 'w');
    
    for (let i = 0; i < uploadInfo.totalChunks; i++) {
      const chunkPath = path.join(this.uploadDir, `${uploadId}_${i}`);
      const chunkData = await fs.readFile(chunkPath);
      await writeStream.write(chunkData);
      
      // 删除分片文件
      await fs.unlink(chunkPath);
    }
    
    await writeStream.close();
    
    // 清理上传信息
    await this.deleteUploadInfo(uploadId);
    
    return {
      completed: true,
      filePath: finalPath,
      fileSize: uploadInfo.fileSize
    };
  }

  // 获取上传状态
  async getUploadStatus(uploadId) {
    const uploadInfo = await this.getUploadInfo(uploadId);
    
    if (!uploadInfo) {
      return null;
    }
    
    return {
      uploaded: uploadInfo.uploadedChunks.length,
      total: uploadInfo.totalChunks,
      missingChunks: this.getMissingChunks(uploadInfo)
    };
  }

  getMissingChunks(uploadInfo) {
    const missing = [];
    for (let i = 0; i < uploadInfo.totalChunks; i++) {
      if (!uploadInfo.uploadedChunks.includes(i)) {
        missing.push(i);
      }
    }
    return missing;
  }

  async saveUploadInfo(uploadId, info) {
    // 这里可以使用Redis或数据库存储
    // 简化示例使用文件存储
    const infoPath = path.join(this.uploadDir, `${uploadId}.json`);
    await fs.writeFile(infoPath, JSON.stringify(info));
  }

  async getUploadInfo(uploadId) {
    try {
      const infoPath = path.join(this.uploadDir, `${uploadId}.json`);
      const data = await fs.readFile(infoPath, 'utf8');
      return JSON.parse(data);
    } catch (error) {
      return null;
    }
  }

  async deleteUploadInfo(uploadId) {
    try {
      const infoPath = path.join(this.uploadDir, `${uploadId}.json`);
      await fs.unlink(infoPath);
    } catch (error) {
      // 忽略删除错误
    }
  }
}

module.exports = ResumableUpload;
```

### 4.5 多语言支持

```javascript
// lib/i18n.js - 国际化支持
const i18n = require('i18next');
const Backend = require('i18next-fs-backend');

// 初始化i18n
i18n
  .use(Backend)
  .init({
    lng: 'zh-CN',
    fallbackLng: 'zh-CN',
    backend: {
      loadPath: './locales/{{lng}}/{{ns}}.json'
    },
    interpolation: {
      escapeValue: false
    }
  });

// 中间件
function i18nMiddleware(req, res, next) {
  const lang = req.headers['accept-language'] || 
               req.query.lang || 
               req.body.language || 
               'zh-CN';
  
  req.t = i18n.getFixedT(lang);
  next();
}

module.exports = { i18n, i18nMiddleware };
```

```json
// locales/zh-CN/common.json
{
  "upload": {
    "success": "上传成功",
    "failed": "上传失败",
    "processing": "处理中..."
  },
  "session": {
    "created": "相册创建成功",
    "not_found": "相册不存在",
    "access_denied": "访问被拒绝"
  },
  "photo": {
    "approved": "照片已通过审核",
    "rejected": "照片已被拒绝",
    "pending": "等待审核"
  },
  "tags": {
    "bride_groom": "新郎新娘",
    "group_photo": "全体合照",
    "indoor": "室内",
    "outdoor": "户外",
    "formal": "正式",
    "casual": "轻松"
  }
}
```

```json
// locales/en-US/common.json
{
  "upload": {
    "success": "Upload successful",
    "failed": "Upload failed",
    "processing": "Processing..."
  },
  "session": {
    "created": "Session created successfully",
    "not_found": "Session not found",
    "access_denied": "Access denied"
  },
  "photo": {
    "approved": "Photo approved",
    "rejected": "Photo rejected",
    "pending": "Pending review"
  },
  "tags": {
    "bride_groom": "Bride & Groom",
    "group_photo": "Group Photo",
    "indoor": "Indoor",
    "outdoor": "Outdoor",
    "formal": "Formal",
    "casual": "Casual"
  }
}
```

## 5. 部署和运维

### 4.1 Docker化部署

```yaml
# docker-compose.yml
version: '3.8'

services:
  # 后端API服务
  api:
    build: 
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://user:password@postgres:5432/photolive
      - REDIS_URL=redis://redis:6379
      - OSS_ACCESS_KEY=${OSS_ACCESS_KEY}
      - OSS_SECRET_KEY=${OSS_SECRET_KEY}
      - OSS_BUCKET=${OSS_BUCKET}
    volumes:
      - ./uploads:/app/uploads
      - ./logs:/app/logs
    depends_on:
      - postgres
      - redis
    restart: unless-stopped

  # Web前端服务
  web:
    build:
      context: ./frontend-web
      dockerfile: Dockerfile
    ports:
      - "3001:3000"
    environment:
      - NEXT_PUBLIC_API_URL=https://api.yourdomain.com
      - NEXT_PUBLIC_WS_URL=wss://api.yourdomain.com
    depends_on:
      - api
    restart: unless-stopped

  # PostgreSQL数据库
  postgres:
    image: postgres:14-alpine
    environment:
      - POSTGRES_DB=photolive
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql
    restart: unless-stopped

  # Redis缓存
  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes
    volumes:
      - redis_data:/data
    restart: unless-stopped

  # Nginx反向代理
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
      - ./nginx/logs:/var/log/nginx
    depends_on:
      - api
      - web
    restart: unless-stopped

  # 图片处理队列
  image_processor:
    build:
      context: ./image-processor
      dockerfile: Dockerfile
    environment:
      - REDIS_URL=redis://redis:6379
      - OSS_ACCESS_KEY=${OSS_ACCESS_KEY}
      - OSS_SECRET_KEY=${OSS_SECRET_KEY}
    depends_on:
      - redis
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

```dockerfile
# backend/Dockerfile
FROM node:18-alpine

WORKDIR /app

# 安装gphoto2（用于USB相机）
RUN apk add --no-cache gphoto2 libgphoto2-dev

# 复制package文件
COPY package*.json ./

# 安装依赖
RUN npm ci --only=production

# 复制源代码
COPY . .

# 创建必要目录
RUN mkdir -p uploads logs

# 暴露端口
EXPOSE 3000

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

# 启动命令
CMD ["npm", "start"]
```

```nginx
# nginx/nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream api_backend {
        server api:3000;
    }

    upstream web_backend {
        server web:3000;
    }

    # API服务
    server {
        listen 80;
        server_name api.yourdomain.com;

        # HTTP重定向到HTTPS
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name api.yourdomain.com;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;

        # 文件上传大小限制
        client_max_body_size 100M;

        # API路由
        location /api/ {
            proxy_pass http://api_backend/api/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # WebSocket路由
        location /socket.io/ {
            proxy_pass http://api_backend/socket.io/;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }

    # Web前端服务
    server {
        listen 80;
        server_name yourdomain.com www.yourdomain.com;

        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name yourdomain.com www.yourdomain.com;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;

        location / {
            proxy_pass http://web_backend/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # 静态文件缓存
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
            proxy_pass http://web_backend;
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }
}
```

### 4.2 监控和日志

```javascript
// utils/logger.js - 日志系统
const winston = require('winston');
const path = require('path');

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'photo-live-api' },
  transports: [
    // 错误日志
    new winston.transports.File({
      filename: path.join(__dirname, '../logs/error.log'),
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5
    }),

    // 综合日志
    new winston.transports.File({
      filename: path.join(__dirname, '../logs/combined.log'),
      maxsize: 5242880,
      maxFiles: 5
    }),

    // 控制台输出
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    })
  ]
});

module.exports = logger;

// middleware/requestLogger.js - 请求日志中间件
const logger = require('../utils/logger');

function requestLogger(req, res, next) {
  const start = Date.now();

  // 记录请求开始
  logger.info('Request started', {
    method: req.method,
    url: req.url,
    ip: req.ip,
    userAgent: req.get('User-Agent')
  });

  // 拦截响应结束
  const originalSend = res.send;
  res.send = function(data) {
    const duration = Date.now() - start;

    logger.info('Request completed', {
      method: req.method,
      url: req.url,
      statusCode: res.statusCode,
      duration: `${duration}ms`,
      contentLength: data ? data.length : 0
    });

    return originalSend.call(this, data);
  };

  next();
}

module.exports = requestLogger;
```

```bash
#!/bin/bash
# scripts/backup.sh - 数据备份脚本

# 配置
BACKUP_DIR="/opt/backups/photolive"
DB_NAME="photolive"
DB_USER="user"
RETENTION_DAYS=30

# 创建备份目录
mkdir -p $BACKUP_DIR

# 数据库备份
DATE=$(date +%Y%m%d_%H%M%S)
DB_BACKUP_FILE="$BACKUP_DIR/db_backup_$DATE.sql"

echo "开始数据库备份..."
docker exec photolive_postgres_1 pg_dump -U $DB_USER $DB_NAME > $DB_BACKUP_FILE

if [ $? -eq 0 ]; then
    echo "数据库备份成功: $DB_BACKUP_FILE"
    gzip $DB_BACKUP_FILE
else
    echo "数据库备份失败"
    exit 1
fi

# 文件备份
FILES_BACKUP_FILE="$BACKUP_DIR/files_backup_$DATE.tar.gz"
echo "开始文件备份..."
tar -czf $FILES_BACKUP_FILE -C /opt/photolive uploads logs

if [ $? -eq 0 ]; then
    echo "文件备份成功: $FILES_BACKUP_FILE"
else
    echo "文件备份失败"
    exit 1
fi

# 清理旧备份
echo "清理旧备份文件..."
find $BACKUP_DIR -name "*.sql.gz" -mtime +$RETENTION_DAYS -delete
find $BACKUP_DIR -name "*.tar.gz" -mtime +$RETENTION_DAYS -delete

echo "备份完成"
```

### 4.3 性能优化配置

```javascript
// config/performance.js - 性能优化配置
module.exports = {
  // 图片处理配置
  image: {
    thumbnailSize: 300,
    maxOriginalSize: 2048,
    quality: {
      thumbnail: 80,
      original: 85
    },
    formats: ['jpeg', 'webp'], // 支持WebP格式
    progressive: true
  },

  // 缓存配置
  cache: {
    redis: {
      ttl: 3600, // 1小时
      maxMemory: '256mb'
    },
    cdn: {
      maxAge: 31536000, // 1年
      sMaxAge: 86400 // 1天
    }
  },

  // 上传配置
  upload: {
    concurrent: 3, // 并发上传数量
    chunkSize: 1024 * 1024, // 1MB分块
    timeout: 30000 // 30秒超时
  },

  // WebSocket配置
  websocket: {
    pingTimeout: 60000,
    pingInterval: 25000,
    maxConnections: 1000
  }
};

// lib/imageProcessor.js - 图片处理优化
const sharp = require('sharp');
const Queue = require('bull');

// 创建图片处理队列
const imageQueue = new Queue('image processing', {
  redis: { port: 6379, host: 'redis' }
});

// 处理图片任务
imageQueue.process('optimize', async (job) => {
  const { inputPath, outputPath, options } = job.data;

  try {
    await sharp(inputPath)
      .resize(options.width, options.height, {
        fit: options.fit || 'cover',
        withoutEnlargement: true
      })
      .jpeg({
        quality: options.quality,
        progressive: true,
        mozjpeg: true // 使用mozjpeg编码器
      })
      .toFile(outputPath);

    return { success: true, outputPath };
  } catch (error) {
    throw new Error(`图片处理失败: ${error.message}`);
  }
});

// 批量处理接口
async function processImageBatch(images) {
  const jobs = images.map(image => ({
    name: 'optimize',
    data: image,
    opts: {
      removeOnComplete: 5,
      removeOnFail: 10,
      attempts: 3,
      backoff: 'exponential'
    }
  }));

  return Promise.all(jobs.map(job => imageQueue.add(job.name, job.data, job.opts)));
}

module.exports = { imageQueue, processImageBatch };
```

## 5. 测试方案

### 5.1 单元测试

```javascript
// tests/api/session.test.js
const request = require('supertest');
const app = require('../../app');
const db = require('../../models');

describe('Session API', () => {
  beforeEach(async () => {
    await db.sessions.destroy({ where: {} });
  });

  describe('POST /api/sessions', () => {
    it('应该成功创建相册', async () => {
      const sessionData = {
        name: '测试相册',
        description: '测试描述'
      };

      const response = await request(app)
        .post('/api/sessions')
        .send(sessionData)
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.name).toBe(sessionData.name);
      expect(response.body.data.session_id).toBeDefined();
    });

    it('应该验证必填字段', async () => {
      const response = await request(app)
        .post('/api/sessions')
        .send({})
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('name');
    });
  });

  describe('GET /api/sessions/:id', () => {
    it('应该返回相册详情', async () => {
      const session = await db.sessions.create({
        name: '测试相册',
        description: '测试描述'
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}`)
        .expect(200);

      expect(response.body.data.name).toBe(session.name);
    });

    it('应该返回404当相册不存在', async () => {
      const response = await request(app)
        .get('/api/sessions/nonexistent')
        .expect(404);

      expect(response.body.code).toBe(404);
    });
  });
});
```

```javascript
// tests/api/photo.test.js
const request = require('supertest');
const path = require('path');
const app = require('../../app');
const db = require('../../models');

describe('Photo API', () => {
  let session;

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
    
    session = await db.sessions.create({
      name: '测试相册',
      description: '测试描述'
    });
  });

  describe('POST /api/sessions/:id/photos', () => {
    it('应该成功上传照片', async () => {
      const testImagePath = path.join(__dirname, '../fixtures/test-image.jpg');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testImagePath)
        .field('tags', JSON.stringify(['测试', '样例']))
        .expect(201);

      expect(response.body.code).toBe(200);
      expect(response.body.data.photo_id).toBeDefined();
      expect(response.body.data.urls).toBeDefined();
    });

    it('应该拒绝非图片文件', async () => {
      const testFilePath = path.join(__dirname, '../fixtures/test-file.txt');
      
      const response = await request(app)
        .post(`/api/sessions/${session.id}/photos`)
        .attach('photo', testFilePath)
        .expect(400);

      expect(response.body.code).toBe(400);
      expect(response.body.message).toContain('图片');
    });
  });

  describe('GET /api/sessions/:id/photos', () => {
    it('应该返回照片列表', async () => {
      // 创建测试照片
      await db.photos.create({
        session_id: session.id,
        filename: 'test.jpg',
        urls: { thumbnail: 'thumb.jpg', original: 'orig.jpg' },
        tags: ['测试']
      });

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].filename).toBe('test.jpg');
    });

    it('应该支持标签过滤', async () => {
      await db.photos.bulkCreate([
        {
          session_id: session.id,
          filename: 'test1.jpg',
          urls: {},
          tags: ['人物']
        },
        {
          session_id: session.id,
          filename: 'test2.jpg',
          urls: {},
          tags: ['风景']
        }
      ]);

      const response = await request(app)
        .get(`/api/sessions/${session.id}/photos?tags=人物`)
        .expect(200);

      expect(response.body.data.photos).toHaveLength(1);
      expect(response.body.data.photos[0].tags).toContain('人物');
    });
  });
});
```

### 5.2 集成测试

```javascript
// tests/integration/workflow.test.js
const request = require('supertest');
const app = require('../../app');
const db = require('../../models');
const WebSocket = require('ws');

describe('完整工作流程测试', () => {
  let session;
  let ws;

  beforeAll(async () => {
    // 启动WebSocket连接
    ws = new WebSocket('ws://localhost:3000');
    await new Promise(resolve => ws.on('open', resolve));
  });

  afterAll(() => {
    ws.close();
  });

  beforeEach(async () => {
    await db.photos.destroy({ where: {} });
    await db.sessions.destroy({ where: {} });
  });

  it('应该完成完整的拍摄分享流程', async () => {
    // 1. 创建相册
    const sessionResponse = await request(app)
      .post('/api/sessions')
      .send({
        name: '婚礼拍摄',
        description: '张三李四的婚礼',
        settings: {
          watermark: {
            enabled: true,
            text: '张三❤李四 2024.01.01'
          },
          access_protection: {
            enabled: true,
            access_code: '1234'
          }
        }
      })
      .expect(201);

    const sessionId = sessionResponse.body.data.session_id;

    // 2. 加入相册WebSocket房间
    ws.send(JSON.stringify({
      type: 'join_session',
      session_id: sessionId
    }));

    // 3. 上传照片
    const uploadResponse = await request(app)
      .post(`/api/sessions/${sessionId}/photos`)
      .attach('photo', path.join(__dirname, '../fixtures/wedding.jpg'))
      .field('watermark_text', '张三❤李四 2024.01.01')
      .field('auto_tag', 'true')
      .expect(201);

    const photoId = uploadResponse.body.data.photo_id;

    // 4. 验证WebSocket推送
    const wsMessage = await new Promise(resolve => {
      ws.on('message', data => {
        const message = JSON.parse(data);
        if (message.type === 'new_photo') {
          resolve(message);
        }
      });
    });

    expect(wsMessage.data.photo_id).toBe(photoId);

    // 5. 访客访问（需要访问码）
    const guestResponse = await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=1234`)
      .expect(200);

    expect(guestResponse.body.data.photos).toHaveLength(1);

    // 6. 错误访问码测试
    await request(app)
      .get(`/api/sessions/${sessionId}/photos?code=wrong`)
      .expect(403);
  });

  it('应该支持断点续传', async () => {
    const session = await db.sessions.create({
      name: '测试相册'
    });

    // 1. 初始化上传
    const initResponse = await request(app)
      .post('/api/upload/init')
      .send({
        filename: 'large-photo.jpg',
        fileSize: 5 * 1024 * 1024, // 5MB
        chunkSize: 1024 * 1024 // 1MB
      })
      .expect(200);

    const uploadId = initResponse.body.data.uploadId;

    // 2. 上传分片
    const chunk1 = Buffer.alloc(1024 * 1024, 'a');
    await request(app)
      .post(`/api/upload/chunk/${uploadId}/0`)
      .send(chunk1)
      .expect(200);

    // 3. 检查上传状态
    const statusResponse = await request(app)
      .get(`/api/upload/status/${uploadId}`)
      .expect(200);

    expect(statusResponse.body.data.uploaded).toBe(1);
    expect(statusResponse.body.data.total).toBe(5);
  });
});
```

### 5.3 性能测试

```javascript
// tests/performance/load.test.js
const autocannon = require('autocannon');
const app = require('../../app');

describe('性能测试', () => {
  let server;

  beforeAll(() => {
    server = app.listen(0);
  });

  afterAll(() => {
    server.close();
  });

  it('API并发性能测试', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions`,
      method: 'GET',
      connections: 100,
      duration: 10,
      headers: {
        'Content-Type': 'application/json'
      }
    });

    expect(result.errors).toBe(0);
    expect(result.requests.average).toBeGreaterThan(100); // 平均每秒100+请求
  });

  it('图片上传性能测试', async () => {
    const result = await autocannon({
      url: `http://localhost:${server.address().port}/api/sessions/test/photos`,
      method: 'POST',
      connections: 10,
      duration: 30,
      setupClient: (client) => {
        // 模拟文件上传
        client.setBody(Buffer.alloc(1024 * 100, 'test')); // 100KB测试文件
        client.setHeaders({
          'Content-Type': 'multipart/form-data'
        });
      }
    });

    expect(result.errors).toBe(0);
    expect(result.latency.p99).toBeLessThan(5000); // 99%请求在5秒内完成
  });
});
```

## 6. 项目规划

### 6.1 开发阶段

#### 第一阶段：MVP版本（4-6周）

**核心功能**
- 基础相册管理（创建、查看）
- 照片上传和展示
- 简单的实时推送
- 基础的Web端查看界面
- 移动端拍摄应用（基础版）

**技术栈**
- 后端：Node.js + Express + PostgreSQL
- 前端：Next.js + React
- 移动端：Flutter
- 实时通信：Socket.IO
- 文件存储：本地存储

**里程碑**
- Week 1-2: 后端API基础架构
- Week 3-4: 前端界面开发
- Week 5-6: 移动端应用开发和集成测试

#### 第二阶段：功能增强（6-8周）

**新增功能**
- 访问码保护
- 图片水印
- 多分辨率支持
- 基础标签系统
- 云存储集成（阿里云OSS）
- 性能优化

**技术升级**
- Redis缓存
- 图片处理队列
- CDN集成
- 监控和日志系统

**里程碑**
- Week 1-2: 安全功能和访问控制
- Week 3-4: 图片处理和存储优化
- Week 5-6: 标签系统和搜索功能
- Week 7-8: 性能优化和监控

#### 第三阶段：高级功能（8-10周）

**高级功能**
- AI自动标签
- 照片审核系统
- 断点续传
- 多语言支持
- 高级水印定制
- 批量操作

**商业化功能**
- 用户系统和权限管理
- 套餐和计费
- 数据分析和报表
- API开放平台

**里程碑**
- Week 1-3: AI功能集成
- Week 4-6: 审核和管理系统
- Week 7-8: 商业化功能
- Week 9-10: 测试和上线准备

### 6.2 团队配置

**核心团队（5-7人）**
- 项目经理 × 1
- 后端开发 × 2
- 前端开发 × 1
- 移动端开发 × 1
- UI/UX设计师 × 1
- 测试工程师 × 1

**技能要求**
- 后端：Node.js、数据库设计、云服务、性能优化
- 前端：React、Next.js、响应式设计
- 移动端：Flutter、相机API、文件上传
- 设计：UI设计、用户体验、原型设计
- 测试：自动化测试、性能测试、安全测试

### 6.3 成本估算

#### 开发成本
- 人力成本：50-70万（6个月）
- 设备和工具：5-10万
- 第三方服务：2-5万
- **总计：57-85万**

#### 运营成本（月）
- 服务器：5,000-15,000元
- 云存储：2,000-8,000元
- CDN：1,000-5,000元
- 监控和安全：1,000-3,000元
- **月运营成本：9,000-31,000元**

#### 收入模式
- 基础版：免费（限制功能）
- 专业版：299元/月（完整功能）
- 企业版：999元/月（定制服务）
- 按需服务：1-5元/GB存储

## 7. 风险评估与应对

### 7.1 技术风险

#### 高风险
**1. 大文件上传稳定性**
- 风险：网络不稳定导致上传失败
- 应对：断点续传、重试机制、进度保存
- 预案：本地缓存、离线上传队列

**2. 实时性能瓶颈**
- 风险：高并发时WebSocket连接数过多
- 应对：连接池管理、负载均衡、Redis集群
- 预案：降级为轮询模式

#### 中风险
**3. 图片处理性能**
- 风险：大量图片同时处理导致服务器压力
- 应对：异步队列、分布式处理、缓存策略
- 预案：外部图片处理服务

**4. 存储成本控制**
- 风险：存储费用快速增长
- 应对：智能压缩、定期清理、分层存储
- 预案：用户付费存储模式

### 7.2 业务风险

#### 高风险
**1. 用户隐私和数据安全**
- 风险：照片泄露、数据被盗
- 应对：加密存储、访问控制、安全审计
- 预案：保险和法律保护

**2. 版权和法律问题**
- 风险：用户上传侵权内容
- 应对：内容审核、用户协议、举报机制
- 预案：快速删除和法律支持

#### 中风险
**3. 市场竞争**
- 风险：大厂推出类似产品
- 应对：差异化功能、用户粘性、快速迭代
- 预案：细分市场定位

**4. 用户获取成本**
- 风险：获客成本过高
- 应对：口碑营销、合作推广、免费试用
- 预案：调整商业模式

### 7.3 运营风险

#### 中风险
**1. 服务可用性**
- 风险：服务中断影响用户体验
- 应对：多地部署、自动故障转移、监控告警
- 预案：紧急恢复流程

**2. 团队稳定性**
- 风险：核心开发人员离职
- 应对：知识文档化、代码规范、团队建设
- 预案：外包和招聘计划

### 7.4 应急预案

**技术故障应急**
1. 建立24小时监控和告警
2. 制定故障等级和响应时间
3. 准备回滚和降级方案
4. 定期进行故障演练

**数据安全应急**
1. 定期数据备份和恢复测试
2. 建立数据泄露响应流程
3. 准备法律和公关应对
4. 用户通知和补偿机制

**业务连续性**
1. 多云部署避免单点故障
2. 核心功能离线可用
3. 合作伙伴备选方案
4. 资金储备和融资计划

## 8. 总结

本开发方案为个人照片直播应用提供了完整的技术架构和实施路径。方案具有以下特点：

### 8.1 技术优势
- **现代化技术栈**：采用Node.js、React、Flutter等主流技术
- **可扩展架构**：微服务设计，支持水平扩展
- **性能优化**：多级缓存、CDN、图片压缩等优化策略
- **安全可靠**：访问控制、数据加密、备份恢复

### 8.2 功能完整性
- **核心功能齐全**：拍摄、上传、分享、查看完整流程
- **用户体验优秀**：实时推送、断点续传、多端适配
- **管理功能强大**：标签分类、审核系统、数据分析
- **商业化就绪**：用户系统、计费模式、API开放

### 8.3 实施可行性
- **分阶段开发**：MVP→功能增强→商业化，风险可控
- **成本合理**：开发和运营成本在可接受范围
- **团队要求明确**：技能要求和人员配置清晰
- **风险可控**：识别主要风险并制定应对策略

### 8.4 市场前景
- **需求明确**：摄影师和活动组织者有真实需求
- **差异化明显**：专注于专业摄影场景
- **商业模式清晰**：多种收费模式，可持续发展
- **扩展性强**：可拓展到更多垂直领域

**建议立即启动MVP开发，验证核心功能和市场需求，为后续功能迭代和商业化奠定基础。**
```
